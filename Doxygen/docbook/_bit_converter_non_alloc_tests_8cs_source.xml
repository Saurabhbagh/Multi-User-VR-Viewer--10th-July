<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="__bit_converter_non_alloc_tests_8cs_source">
<title>BitConverterNonAllocTests.cs</title>
<indexterm><primary>O:/GitHUBMINIPRoject/Assets/LeapMotion/Core/Scripts/Utils/Editor/BitConverterNonAllocTests.cs</primary></indexterm>
<programlisting>00001 <emphasis role="comment">/******************************************************************************</emphasis>
00002 <emphasis role="comment">&#32;*&#32;Copyright&#32;(C)&#32;Leap&#32;Motion,&#32;Inc.&#32;2011-2018.&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00003 <emphasis role="comment">&#32;*&#32;Leap&#32;Motion&#32;proprietary&#32;and&#32;confidential.&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00004 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00005 <emphasis role="comment">&#32;*&#32;Use&#32;subject&#32;to&#32;the&#32;terms&#32;of&#32;the&#32;Leap&#32;Motion&#32;SDK&#32;Agreement&#32;available&#32;at&#32;&#32;&#32;&#32;&#32;*</emphasis>
00006 <emphasis role="comment">&#32;*&#32;https://developer.leapmotion.com/sdk_agreement,&#32;or&#32;another&#32;agreement&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00007 <emphasis role="comment">&#32;*&#32;between&#32;Leap&#32;Motion&#32;and&#32;you,&#32;your&#32;company&#32;or&#32;other&#32;organization.&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00008 <emphasis role="comment">&#32;******************************************************************************/</emphasis>
00009 
00010 <emphasis role="keyword">using</emphasis>&#32;System;
00011 <emphasis role="keyword">using</emphasis>&#32;System.Linq;
00012 <emphasis role="keyword">using</emphasis>&#32;NUnit.Framework;
00013 
00014 <emphasis role="keyword">namespace&#32;</emphasis><link linkend="_namespace_leap_1_1_unity_1_1_tests">Leap.Unity.Tests</link>&#32;{
00015 
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00016"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests">00016</link> &#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keyword">class&#32;</emphasis><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests">BitConverterTests</link>&#32;{
00017 
00018 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keywordtype">byte</emphasis>[]&#32;_bytes;
00019 
00020 &#32;&#32;&#32;&#32;[<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a38158c62ddfc36d84fbf916abd532e9e">SetUp</link>]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00021"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a38158c62ddfc36d84fbf916abd532e9e">00021</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a38158c62ddfc36d84fbf916abd532e9e">SetUp</link>()&#32;{
00022 &#32;&#32;&#32;&#32;&#32;&#32;_bytes&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<emphasis role="keywordtype">byte</emphasis>[128];
00023 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;_bytes.Length;&#32;i++)&#32;{
00024 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_bytes[i]&#32;=&#32;(byte)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">int</emphasis>.MinValue,&#32;<emphasis role="keywordtype">int</emphasis>.MaxValue);
00025 &#32;&#32;&#32;&#32;&#32;&#32;}
00026 &#32;&#32;&#32;&#32;}
00027 
00028 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00029"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a199ab962faeb0c63a86d308e844f6b78">00029</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a199ab962faeb0c63a86d308e844f6b78">TestToUInt16</link>()&#32;{
00030 &#32;&#32;&#32;&#32;&#32;&#32;UInt16&#32;expected&#32;=&#32;BitConverter.ToUInt16(_bytes,&#32;0);
00031 &#32;&#32;&#32;&#32;&#32;&#32;UInt16&#32;actual&#32;=&#32;BitConverterNonAlloc.ToUInt16(_bytes,&#32;0);
00032 
00033 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00034 &#32;&#32;&#32;&#32;}
00035 
00036 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00037"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a942697952b353d2a70bf6922681fc84d">00037</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a942697952b353d2a70bf6922681fc84d">TestFromUInt16</link>()&#32;{
00038 &#32;&#32;&#32;&#32;&#32;&#32;UInt16&#32;value&#32;=&#32;(UInt16)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00039 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00040 
00041 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00042 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00043 
00044 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00045 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00046 &#32;&#32;&#32;&#32;}
00047 
00048 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00049"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a9eae1df51bd67e944cd6187e24c9970d">00049</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a9eae1df51bd67e944cd6187e24c9970d">TestToInt16</link>()&#32;{
00050 &#32;&#32;&#32;&#32;&#32;&#32;Int16&#32;expected&#32;=&#32;BitConverter.ToInt16(_bytes,&#32;0);
00051 &#32;&#32;&#32;&#32;&#32;&#32;Int16&#32;actual&#32;=&#32;BitConverterNonAlloc.ToInt16(_bytes,&#32;0);
00052 
00053 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00054 &#32;&#32;&#32;&#32;}
00055 
00056 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00057"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a250870475d05bc5878cfd30061f4792a">00057</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a250870475d05bc5878cfd30061f4792a">TestFromInt16</link>()&#32;{
00058 &#32;&#32;&#32;&#32;&#32;&#32;Int16&#32;value&#32;=&#32;(Int16)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00059 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00060 
00061 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00062 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00063 
00064 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00065 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00066 &#32;&#32;&#32;&#32;}
00067 
00068 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00069"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a78fec5203b5dc47a33a5735782bec30b">00069</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a78fec5203b5dc47a33a5735782bec30b">TestToUInt32</link>()&#32;{
00070 &#32;&#32;&#32;&#32;&#32;&#32;UInt32&#32;expected&#32;=&#32;BitConverter.ToUInt32(_bytes,&#32;0);
00071 &#32;&#32;&#32;&#32;&#32;&#32;UInt32&#32;actual&#32;=&#32;BitConverterNonAlloc.ToUInt32(_bytes,&#32;0);
00072 
00073 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00074 &#32;&#32;&#32;&#32;}
00075 
00076 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00077"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1aa374fcee30c22855e6f4b132532567d5">00077</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1aa374fcee30c22855e6f4b132532567d5">TestFromUInt32</link>()&#32;{
00078 &#32;&#32;&#32;&#32;&#32;&#32;UInt32&#32;value&#32;=&#32;(UInt32)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00079 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00080 
00081 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00082 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00083 
00084 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00085 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00086 &#32;&#32;&#32;&#32;}
00087 
00088 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00089"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a24f16755780736d9ba92617517d32cfb">00089</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a24f16755780736d9ba92617517d32cfb">TestToInt32</link>()&#32;{
00090 &#32;&#32;&#32;&#32;&#32;&#32;Int32&#32;expected&#32;=&#32;BitConverter.ToInt32(_bytes,&#32;0);
00091 &#32;&#32;&#32;&#32;&#32;&#32;Int32&#32;actual&#32;=&#32;BitConverterNonAlloc.ToInt32(_bytes,&#32;0);
00092 
00093 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00094 &#32;&#32;&#32;&#32;}
00095 
00096 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00097"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a6d4ac3673264676a8b0afad153f773b4">00097</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a6d4ac3673264676a8b0afad153f773b4">TestFromInt32</link>()&#32;{
00098 &#32;&#32;&#32;&#32;&#32;&#32;Int32&#32;value&#32;=&#32;(Int32)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00099 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00100 
00101 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00102 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00103 
00104 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00105 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00106 &#32;&#32;&#32;&#32;}
00107 
00108 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00109"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1ac10e4316cfdbc3172d9c402bc427833c">00109</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1ac10e4316cfdbc3172d9c402bc427833c">TestToUInt64</link>()&#32;{
00110 &#32;&#32;&#32;&#32;&#32;&#32;UInt64&#32;expected&#32;=&#32;BitConverter.ToUInt64(_bytes,&#32;0);
00111 &#32;&#32;&#32;&#32;&#32;&#32;UInt64&#32;actual&#32;=&#32;BitConverterNonAlloc.ToUInt64(_bytes,&#32;0);
00112 
00113 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00114 &#32;&#32;&#32;&#32;}
00115 
00116 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00117"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1ade521f67ff9ce1d65c1cad2c8b625817">00117</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1ade521f67ff9ce1d65c1cad2c8b625817">TestFromUInt64</link>()&#32;{
00118 &#32;&#32;&#32;&#32;&#32;&#32;UInt64&#32;value&#32;=&#32;(UInt64)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00119 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00120 
00121 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00122 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00123 
00124 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00125 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00126 &#32;&#32;&#32;&#32;}
00127 
00128 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00129"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a176e7913bf26bd19f3dfe341e1883390">00129</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a176e7913bf26bd19f3dfe341e1883390">TestToInt64</link>()&#32;{
00130 &#32;&#32;&#32;&#32;&#32;&#32;Int64&#32;expected&#32;=&#32;BitConverter.ToInt64(_bytes,&#32;0);
00131 &#32;&#32;&#32;&#32;&#32;&#32;Int64&#32;actual&#32;=&#32;BitConverterNonAlloc.ToInt64(_bytes,&#32;0);
00132 
00133 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00134 &#32;&#32;&#32;&#32;}
00135 
00136 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00137"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a5fb887344c07c258e439cfc2ff349af8">00137</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a5fb887344c07c258e439cfc2ff349af8">TestFromInt64</link>()&#32;{
00138 &#32;&#32;&#32;&#32;&#32;&#32;Int64&#32;value&#32;=&#32;(Int64)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00139 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00140 
00141 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00142 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00143 
00144 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00145 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00146 &#32;&#32;&#32;&#32;}
00147 
00148 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00149"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a36aae47dba48abf476acdb660cd4c51b">00149</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a36aae47dba48abf476acdb660cd4c51b">TestToSingle</link>()&#32;{
00150 &#32;&#32;&#32;&#32;&#32;&#32;Single&#32;expected&#32;=&#32;BitConverter.ToSingle(_bytes,&#32;0);
00151 &#32;&#32;&#32;&#32;&#32;&#32;Single&#32;actual&#32;=&#32;BitConverterNonAlloc.ToSingle(_bytes,&#32;0);
00152 
00153 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00154 &#32;&#32;&#32;&#32;}
00155 
00156 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00157"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a828348650fb61975c8ff55e2afb20b4b">00157</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a828348650fb61975c8ff55e2afb20b4b">TestFromSingle</link>()&#32;{
00158 &#32;&#32;&#32;&#32;&#32;&#32;Single&#32;value&#32;=&#32;(Single)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00159 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00160 
00161 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00162 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00163 
00164 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00165 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00166 &#32;&#32;&#32;&#32;}
00167 
00168 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00169"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a22cf885ce832a5d32331aaf7c0ccb9ca">00169</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a22cf885ce832a5d32331aaf7c0ccb9ca">TestToDouble</link>()&#32;{
00170 &#32;&#32;&#32;&#32;&#32;&#32;Double&#32;expected&#32;=&#32;BitConverter.ToDouble(_bytes,&#32;0);
00171 &#32;&#32;&#32;&#32;&#32;&#32;Double&#32;actual&#32;=&#32;BitConverterNonAlloc.ToDouble(_bytes,&#32;0);
00172 
00173 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(actual,&#32;Is.EqualTo(expected));
00174 &#32;&#32;&#32;&#32;}
00175 
00176 &#32;&#32;&#32;&#32;[Test]
<anchor xml:id="__bit_converter_non_alloc_tests_8cs_source_1l00177"/><link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a06356676d9aaa8eea43e4c753218981c">00177</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_tests_1_1_bit_converter_tests_1a06356676d9aaa8eea43e4c753218981c">TestFromDouble</link>()&#32;{
00178 &#32;&#32;&#32;&#32;&#32;&#32;Double&#32;value&#32;=&#32;(Double)<link linkend="_namespace_unity_engine">UnityEngine</link>.Random.Range(<emphasis role="keywordtype">float</emphasis>.MinValue,&#32;<emphasis role="keywordtype">float</emphasis>.MaxValue);
00179 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;actual&#32;=&#32;BitConverter.GetBytes(value);
00180 
00181 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;offset&#32;=&#32;0;
00182 &#32;&#32;&#32;&#32;&#32;&#32;BitConverterNonAlloc.GetBytes(value,&#32;_bytes,&#32;ref&#32;offset);
00183 
00184 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(offset,&#32;Is.EqualTo(actual.Length));
00185 &#32;&#32;&#32;&#32;&#32;&#32;Assert.That(_bytes.Take(offset),&#32;Is.EquivalentTo(actual));
00186 &#32;&#32;&#32;&#32;}
00187 &#32;&#32;}
00188 }
</programlisting></section>
