<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="__min_heap_8cs_source">
<title>MinHeap.cs</title>
<indexterm><primary>O:/GitHUBMINIPRoject/Assets/LeapMotion/Core/Scripts/DataStructures/MinHeap.cs</primary></indexterm>
<programlisting>00001 <emphasis role="comment">/******************************************************************************</emphasis>
00002 <emphasis role="comment">&#32;*&#32;Copyright&#32;(C)&#32;Leap&#32;Motion,&#32;Inc.&#32;2011-2018.&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00003 <emphasis role="comment">&#32;*&#32;Leap&#32;Motion&#32;proprietary&#32;and&#32;confidential.&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00004 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00005 <emphasis role="comment">&#32;*&#32;Use&#32;subject&#32;to&#32;the&#32;terms&#32;of&#32;the&#32;Leap&#32;Motion&#32;SDK&#32;Agreement&#32;available&#32;at&#32;&#32;&#32;&#32;&#32;*</emphasis>
00006 <emphasis role="comment">&#32;*&#32;https://developer.leapmotion.com/sdk_agreement,&#32;or&#32;another&#32;agreement&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00007 <emphasis role="comment">&#32;*&#32;between&#32;Leap&#32;Motion&#32;and&#32;you,&#32;your&#32;company&#32;or&#32;other&#32;organization.&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*</emphasis>
00008 <emphasis role="comment">&#32;******************************************************************************/</emphasis>
00009 
00010 <emphasis role="comment">//#define&#32;VALIDATE</emphasis>
00011 <emphasis role="keyword">using</emphasis>&#32;<link linkend="__balloon_8cs_1a7d67e097df9376eb709b6a23aa3c7d23">UnityEngine</link>;
00012 <emphasis role="keyword">using</emphasis>&#32;System;
00013 
00014 <emphasis role="keyword">namespace&#32;</emphasis><link linkend="_namespace_leap_1_1_unity">Leap.Unity</link>&#32;{
00015 
<anchor xml:id="__min_heap_8cs_source_1l00016"/><link linkend="_interface_leap_1_1_unity_1_1_i_min_heap_node">00016</link> &#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keyword">interface&#32;</emphasis><link linkend="_interface_leap_1_1_unity_1_1_i_min_heap_node">IMinHeapNode</link>&#32;{
<anchor xml:id="__min_heap_8cs_source_1l00017"/><link linkend="_interface_leap_1_1_unity_1_1_i_min_heap_node_1a49743555188d987616c9602bfbcfe97a">00017</link> &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_interface_leap_1_1_unity_1_1_i_min_heap_node_1a49743555188d987616c9602bfbcfe97a">heapIndex</link>&#32;{&#32;<emphasis role="keyword">get</emphasis>;&#32;<emphasis role="keyword">set</emphasis>;&#32;}
00018 &#32;&#32;}
00019 
<anchor xml:id="__min_heap_8cs_source_1l00020"/><link linkend="_class_leap_1_1_unity_1_1_min_heap">00020</link> &#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keyword">class&#32;</emphasis><link linkend="_class_leap_1_1_unity_1_1_min_heap">MinHeap</link>&lt;T&gt;&#32;where&#32;T&#32;:&#32;<link linkend="_interface_leap_1_1_unity_1_1_i_min_heap_node">IMinHeapNode</link>,&#32;IComparable&lt;T&gt;&#32;{
00021 
00022 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;T[]&#32;_array&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;T[4];
00023 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;_count&#32;=&#32;0;
00024 
<anchor xml:id="__min_heap_8cs_source_1l00025"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1a61f29a6626cf9ff04ec8a066dd39d1c1">00025</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1a61f29a6626cf9ff04ec8a066dd39d1c1">Count</link>&#32;{
00026 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">get</emphasis>&#32;{
00027 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_count;
00028 &#32;&#32;&#32;&#32;&#32;&#32;}
00029 &#32;&#32;&#32;&#32;}
00030 
<anchor xml:id="__min_heap_8cs_source_1l00031"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1a8496d10f15870cb9a6929db24e95622e">00031</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1a8496d10f15870cb9a6929db24e95622e">Clear</link>()&#32;{
00032 &#32;&#32;&#32;&#32;&#32;&#32;Array.Clear(_array,&#32;0,&#32;_count);
00033 &#32;&#32;&#32;&#32;&#32;&#32;_count&#32;=&#32;0;
00034 &#32;&#32;&#32;&#32;}
00035 
<anchor xml:id="__min_heap_8cs_source_1l00036"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1a5be89c0c6f35537ce75c92d6b0d80255">00036</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1a5be89c0c6f35537ce75c92d6b0d80255">Insert</link>(T&#32;element)&#32;{
00037 <emphasis role="preprocessor">#if&#32;VALIDATE</emphasis>
00038 &#32;&#32;&#32;&#32;&#32;&#32;validateHeapInternal(<emphasis role="stringliteral">&quot;Insert&quot;</emphasis>);
00039 <emphasis role="preprocessor">#endif</emphasis>
00040 
00041 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//if&#32;the&#32;array&#32;isn&apos;t&#32;big&#32;enough,&#32;expand&#32;it</emphasis>
00042 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_array.Length&#32;==&#32;_count)&#32;{
00043 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T[]&#32;newArray&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;T[_array.Length&#32;*&#32;2];
00044 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Array.Copy(_array,&#32;newArray,&#32;_array.Length);
00045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_array&#32;=&#32;newArray;
00046 &#32;&#32;&#32;&#32;&#32;&#32;}
00047 
00048 &#32;&#32;&#32;&#32;&#32;&#32;element.heapIndex&#32;=&#32;_count;
00049 &#32;&#32;&#32;&#32;&#32;&#32;_count++;
00050 
00051 &#32;&#32;&#32;&#32;&#32;&#32;bubbleUp(element);
00052 &#32;&#32;&#32;&#32;}
00053 
<anchor xml:id="__min_heap_8cs_source_1l00054"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1ad383b9e47ce6d0324edcc9eda5b089de">00054</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1ad383b9e47ce6d0324edcc9eda5b089de">Remove</link>(T&#32;element)&#32;{
00055 &#32;&#32;&#32;&#32;&#32;&#32;removeAt(element.heapIndex);
00056 &#32;&#32;&#32;&#32;}
00057 
<anchor xml:id="__min_heap_8cs_source_1l00058"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1a5bb42731474ab0432008386e3941ea8a">00058</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;T&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1a5bb42731474ab0432008386e3941ea8a">PeekMin</link>()&#32;{
00059 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_count&#32;==&#32;0)&#32;{
00060 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;<emphasis role="keyword">new</emphasis>&#32;Exception(<emphasis role="stringliteral">&quot;Cannot&#32;peek&#32;when&#32;there&#32;are&#32;zero&#32;elements!&quot;</emphasis>);
00061 &#32;&#32;&#32;&#32;&#32;&#32;}
00062 
00063 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_array[0];
00064 &#32;&#32;&#32;&#32;}
00065 
<anchor xml:id="__min_heap_8cs_source_1l00066"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1a23bfa5babc3a4e4827675b4e935663d7">00066</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;T&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1a23bfa5babc3a4e4827675b4e935663d7">RemoveMin</link>()&#32;{
00067 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_count&#32;==&#32;0)&#32;{
00068 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;<emphasis role="keyword">new</emphasis>&#32;Exception(<emphasis role="stringliteral">&quot;Cannot&#32;Remove&#32;Min&#32;when&#32;there&#32;are&#32;zero&#32;elements!&quot;</emphasis>);
00069 &#32;&#32;&#32;&#32;&#32;&#32;}
00070 
00071 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;removeAt(0);
00072 &#32;&#32;&#32;&#32;}
00073 
00074 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;T&#32;removeAt(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
00075 <emphasis role="preprocessor">#if&#32;VALIDATE</emphasis>
00076 &#32;&#32;&#32;&#32;&#32;&#32;validateHeapInternal(<emphasis role="stringliteral">&quot;Remove&#32;At&quot;</emphasis>);
00077 <emphasis role="preprocessor">#endif</emphasis>
00078 
00079 &#32;&#32;&#32;&#32;&#32;&#32;T&#32;ret&#32;=&#32;_array[index];
00080 &#32;&#32;&#32;&#32;&#32;&#32;_count--;
00081 
00082 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_count&#32;==&#32;0)&#32;{
00083 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;ret;
00084 &#32;&#32;&#32;&#32;&#32;&#32;}
00085 
00086 &#32;&#32;&#32;&#32;&#32;&#32;var&#32;bottom&#32;=&#32;_array[_count];
00087 &#32;&#32;&#32;&#32;&#32;&#32;bottom.heapIndex&#32;=&#32;index;
00088 
00089 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;parentIndex&#32;=&#32;getParentIndex(index);
00090 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isValidIndex(parentIndex)&#32;&amp;&amp;&#32;_array[parentIndex].CompareTo(bottom)&#32;&gt;&#32;0)&#32;{
00091 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bubbleUp(bottom);
00092 &#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
00093 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bubbleDown(bottom);
00094 &#32;&#32;&#32;&#32;&#32;&#32;}
00095 
00096 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;ret;
00097 &#32;&#32;&#32;&#32;}
00098 
00099 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;bubbleUp(T&#32;element)&#32;{
00100 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(<emphasis role="keyword">true</emphasis>)&#32;{
00101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(element.heapIndex&#32;==&#32;0)&#32;{
00102 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
00103 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00104 
00105 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;parentIndex&#32;=&#32;getParentIndex(element.heapIndex);
00106 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;var&#32;parent&#32;=&#32;_array[parentIndex];
00107 
00108 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(parent.CompareTo(element)&#32;&lt;=&#32;0)&#32;{
00109 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
00110 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00111 
00112 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;parent.heapIndex&#32;=&#32;element.heapIndex;
00113 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_array[element.heapIndex]&#32;=&#32;parent;
00114 
00115 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;element.heapIndex&#32;=&#32;parentIndex;
00116 &#32;&#32;&#32;&#32;&#32;&#32;}
00117 
00118 &#32;&#32;&#32;&#32;&#32;&#32;_array[element.heapIndex]&#32;=&#32;element;
00119 
00120 <emphasis role="preprocessor">#if&#32;VALIDATE</emphasis>
00121 &#32;&#32;&#32;&#32;&#32;&#32;validateHeapInternal(<emphasis role="stringliteral">&quot;Bubble&#32;Up&quot;</emphasis>);
00122 <emphasis role="preprocessor">#endif</emphasis>
00123 &#32;&#32;&#32;&#32;}
00124 
<anchor xml:id="__min_heap_8cs_source_1l00125"/><link linkend="_class_leap_1_1_unity_1_1_min_heap_1aab63796b0e8d31cc957fd9e6ccfe6775">00125</link> &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_leap_1_1_unity_1_1_min_heap_1aab63796b0e8d31cc957fd9e6ccfe6775">Validate</link>()&#32;{
00126 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;validateHeapInternal(<emphasis role="stringliteral">&quot;Validation&#32;&quot;</emphasis>);
00127 &#32;&#32;&#32;&#32;}
00128 
00129 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;bubbleDown(T&#32;element)&#32;{
00130 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;elementIndex&#32;=&#32;element.heapIndex;
00131 
00132 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(<emphasis role="keyword">true</emphasis>)&#32;{
00133 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;leftIndex&#32;=&#32;getChildLeftIndex(elementIndex);
00134 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;rightIndex&#32;=&#32;getChildRightIndex(elementIndex);
00135 
00136 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;smallest&#32;=&#32;element;
00137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;smallestIndex&#32;=&#32;elementIndex;
00138 
00139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isValidIndex(leftIndex))&#32;{
00140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;var&#32;leftChild&#32;=&#32;_array[leftIndex];
00141 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(leftChild.CompareTo(smallest)&#32;&lt;&#32;0)&#32;{
00142 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;smallest&#32;=&#32;leftChild;
00143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;smallestIndex&#32;=&#32;leftIndex;
00144 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00145 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
00146 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
00147 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00148 
00149 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isValidIndex(rightIndex))&#32;{
00150 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;var&#32;rightChild&#32;=&#32;_array[rightIndex];
00151 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(rightChild.CompareTo(smallest)&#32;&lt;&#32;0)&#32;{
00152 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;smallest&#32;=&#32;rightChild;
00153 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;smallestIndex&#32;=&#32;rightIndex;
00154 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00155 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00156 
00157 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(smallestIndex&#32;==&#32;elementIndex)&#32;{
00158 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
00159 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00160 
00161 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;smallest.heapIndex&#32;=&#32;elementIndex;
00162 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_array[elementIndex]&#32;=&#32;smallest;
00163 
00164 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;elementIndex&#32;=&#32;smallestIndex;
00165 &#32;&#32;&#32;&#32;&#32;&#32;}
00166 
00167 &#32;&#32;&#32;&#32;&#32;&#32;element.heapIndex&#32;=&#32;elementIndex;
00168 &#32;&#32;&#32;&#32;&#32;&#32;_array[elementIndex]&#32;=&#32;element;
00169 
00170 <emphasis role="preprocessor">#if&#32;VALIDATE</emphasis>
00171 &#32;&#32;&#32;&#32;&#32;&#32;validateHeapInternal(<emphasis role="stringliteral">&quot;Bubble&#32;Down&quot;</emphasis>);
00172 <emphasis role="preprocessor">#endif</emphasis>
00173 &#32;&#32;&#32;&#32;}
00174 
00175 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;validateHeapInternal(<emphasis role="keywordtype">string</emphasis>&#32;operation)&#32;{
00176 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;_count;&#32;i++)&#32;{
00177 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_array[i].heapIndex&#32;!=&#32;i)&#32;{
00178 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Debug.LogError(<emphasis role="stringliteral">&quot;Element&#32;&quot;</emphasis>&#32;+&#32;i&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;had&#32;an&#32;index&#32;of&#32;&quot;</emphasis>&#32;+&#32;_array[i].heapIndex&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;instead,&#32;after&#32;&quot;</emphasis>&#32;+&#32;operation);
00179 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
00180 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00181 
00182 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;!=&#32;0)&#32;{
00183 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;var&#32;parent&#32;=&#32;_array[getParentIndex(i)];
00184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(parent.CompareTo(_array[i])&#32;&gt;&#32;0)&#32;{
00185 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Debug.LogError(<emphasis role="stringliteral">&quot;Element&#32;&quot;</emphasis>&#32;+&#32;i&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;had&#32;an&#32;incorrect&#32;order&#32;after&#32;&quot;</emphasis>&#32;+&#32;operation);
00186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
00187 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00188 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
00189 &#32;&#32;&#32;&#32;&#32;&#32;}
00190 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
00191 &#32;&#32;&#32;&#32;}
00192 
00193 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;getChildLeftIndex(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
00194 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespace_valve_1_1_v_r_1ac40c4bdf0a3dcd6e69cad2d85f287c67a6a992d5529f459a44fee58c733255e86">index</link>&#32;*&#32;2&#32;+&#32;1;
00195 &#32;&#32;&#32;&#32;}
00196 
00197 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;getChildRightIndex(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
00198 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespace_valve_1_1_v_r_1ac40c4bdf0a3dcd6e69cad2d85f287c67a6a992d5529f459a44fee58c733255e86">index</link>&#32;*&#32;2&#32;+&#32;2;
00199 &#32;&#32;&#32;&#32;}
00200 
00201 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;getParentIndex(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
00202 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(index&#32;-&#32;1)&#32;/&#32;2;
00203 &#32;&#32;&#32;&#32;}
00204 
00205 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isValidIndex(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
00206 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;index&#32;&lt;&#32;_count&#32;&amp;&amp;&#32;index&#32;&gt;=&#32;0;
00207 &#32;&#32;&#32;&#32;}
00208 &#32;&#32;}
00209 }
</programlisting></section>
