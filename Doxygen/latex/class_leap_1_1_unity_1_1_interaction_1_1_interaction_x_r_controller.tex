\hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller}{}\section{Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller Class Reference}
\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller}\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
Inheritance diagram for Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.736156cm]{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84947d3cd2c236dab7849e2d805465b6}{Refresh\+Controller\+Connection}} ()
\item 
override Vector3 \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_acf5f67ce22587c6d638890d9af2ecadb}{Get\+Grasp\+Point}} ()
\begin{DoxyCompactList}\small\item\em Returns approximately where the controller is grasping the currently grasped \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_behaviour}{Interaction\+Behaviour}}. This method will print an error if the controller is not currently grasping an object. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a3d2b1845b1041d41e2a157df230ca42b}{On\+Draw\+Runtime\+Gizmos}} (\mbox{\hyperlink{class_leap_1_1_unity_1_1_runtime_gizmos_1_1_runtime_gizmo_drawer}{Runtime\+Gizmos.\+Runtime\+Gizmo\+Drawer}} drawer)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
float \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a870363d8aa13c1d14481b988608b195e}{poll\+Connection\+Interval}} = 2f
\item 
new List$<$ Transform $>$ \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a1b5abc7602f840695df4eae23ead0e37}{primary\+Hover\+Points}}
\item 
Transform \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a45e35489ae52235acd3cece14cf4dbae}{grasp\+Point}}
\item 
float \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_abd2f8566d2d0e95acd51ae7718b8bc98}{max\+Grasp\+Distance}} = 0.\+06F
\item 
string \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a857761fb2f53cdf7e9ffd28f396c4712}{grasp\+Button\+Axis}}
\item 
float \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6fe4112d61321e09eabefbc59af9d13a}{grasp\+Timing\+Slop}} = 0.\+10F
\item 
Func$<$ float $>$ \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a5c3b54bb8249aacff51aa5e898d95021}{grasp\+Axis\+Override}} = null
\begin{DoxyCompactList}\small\item\em By default, Interaction\+V\+R\+Controller uses Input.\+Get\+Axis(grasp\+Button\+Axis) to determine the \char`\"{}depression\char`\"{} state for the grasp button. By setting this value to something other than null, it is possible to modify this behavior to instead retrieve a grasping axis value based on arbitrary code. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a17a8608c8d69b586256fbcb9877394b3}{Reset}} ()
\item 
virtual void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac43db0f1fd87084d1b1468ce95bd58ac}{On\+Validate}} ()
\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac50b109d0cd82bb14cd8a19199850c9e}{Start}} ()
\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa7e13f419009b2f0fd02018cc96f81b4}{fixed\+Update\+Controller}} ()
\begin{DoxyCompactList}\small\item\em Called just before the \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller}{Interaction\+Controller}} proceeds with its usual Fixed\+Update. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ab287ac4fbd0ba8471ef9787a371470ef}{on\+Object\+Unregistered}} (\mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}} int\+Obj)
\begin{DoxyCompactList}\small\item\em Interaction\+V\+R\+Controller doesn\textquotesingle{}t need to do anything when an object is unregistered. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aae371c99d08f9ce6e8850e36109690c5}{unwarp\+Colliders}} (Transform primary\+Hover\+Point, \mbox{\hyperlink{interface_leap_1_1_unity_1_1_space_1_1_i_space_component}{I\+Space\+Component}} warped\+Space\+Element)
\begin{DoxyCompactList}\small\item\em Implementing this method is necessary to support curved spaces as rendered by a \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} Graphic Renderer. See \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} Graphic Renderer.) \end{DoxyCompactList}\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6646ebf671991c5bc47a66b2129538b6}{init\+Contact}} ()
\begin{DoxyCompactList}\small\item\em Called to initialize contact colliders. See remarks for implementation requirements. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6870022c14d8cea42d36502b7a0a299f}{get\+Collider\+Bone\+Target\+Position\+Rotation}} (int contact\+Bone\+Index, out Vector3 target\+Position, out Quaternion target\+Rotation)
\begin{DoxyCompactList}\small\item\em If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contact\+Bones array. (For example, by recording the local position and local rotation of each contact bone in \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6646ebf671991c5bc47a66b2129538b6}{init\+Contact()}}). More complex controllers, such as \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}}, uses this method to set \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_contact_bone}{Contact\+Bone}} target positions and rotations based on the tracked \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} hand. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_abbf181ce05807d75809cac14c0fa8a27}{fixed\+Update\+Grasping\+State}} ()
\begin{DoxyCompactList}\small\item\em Called every fixed frame if grasping is enabled in the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager. \end{DoxyCompactList}\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aad12f5a78dea6345158e44d87e17a5f6}{check\+Should\+Grasp}} (out \mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}} object\+To\+Grasp)
\begin{DoxyCompactList}\small\item\em Returns whether this controller should grasp an object this fixed frame, and if so, sets object\+To\+Grasp to the object the controller should grasp. \end{DoxyCompactList}\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a4756d119b4d5a13574ed990e439e64f3}{check\+Should\+Grasp\+Atemporal}} (\mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}} int\+Obj)
\begin{DoxyCompactList}\small\item\em If the provided object is within range of this VR controller\textquotesingle{}s grasp point and the grasp button is currently held down, this method will manually initiate a grasp and return true. Otherwise, the method returns false. \end{DoxyCompactList}\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a46275014cfc4325621c01097047bb701}{check\+Should\+Release}} (out \mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}} object\+To\+Release)
\begin{DoxyCompactList}\small\item\em Returns whether this controller should release an object this fixed frame, and if so, sets object\+To\+Release to the object the controller should release. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a621446c06cfa8391f7f0d8990d885bf5}{is\+Using\+Custom\+Tracking}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\item 
string \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac3f3ac7b791e70390c8ba9a547162525}{device\+Joystick\+Tokens}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\item 
\mbox{\hyperlink{namespace_leap_1_1_unity_a4d15adcf20ba121b2cd9c07f503b606f}{Chirality}} \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84e32cb318c25dbb329b6766c6f895f8}{chirality}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a96ffe3a41a49ca69c3e15de4badbb98b}{poll\+Connection}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Whether to continuously poll attached joystick data for a joystick that matches the device joystick tokens, using Input.\+Get\+Joystick\+Names(). This call allocates garbage, so be wary of setting a low polling interval. \end{DoxyCompactList}\item 
List$<$ Game\+Object $>$ \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a0cf4a1150ff9575affb5532f1e252b6a}{enable\+Objects\+Only\+When\+Tracked}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em These objects will be made active only while the controller is tracked. For more fine-\/tuned behavior, we recommend implementing your own logic. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac017dcb1298c729f9cc46f24aeeb6a00}{is\+Joystick\+Detected}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Whether the device joystick tokens matched an entry in Input.\+Get\+Joystick\+Names(). If poll\+Connection is set to true, this status is refreshed periodically based on the poll\+Connection\+Interval, but only while the joystick tokens have not been detected from Input.\+Get\+Joystick\+Names(). Call \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84947d3cd2c236dab7849e2d805465b6}{Refresh\+Controller\+Connection()}} to detect if the controller has been disconnected. \end{DoxyCompactList}\item 
\mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_x_r_controller_tracking_provider}{I\+X\+R\+Controller\+Tracking\+Provider}} \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aebc2b694592123f75013dd012e8f357f}{tracking\+Provider}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ab5d50597383ad3e552e3c16d1e91e5a7}{is\+Tracked}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets whether or not the underlying controller is currently tracked and any joystick token filtering has confirmed that this controller has been detected as a connected joystick. \end{DoxyCompactList}\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a362ab5e9ffb5ac5046a869668670b40c}{is\+Being\+Moved}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets whether or not the underlying controller is currently being moved in world space, but relative to the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager\textquotesingle{}s transform. The \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager is usually a sibling of the main camera beneath the camera rig transform, so that if your application is only translating the player rig in space, this method won\textquotesingle{}t incorrectly return true. \end{DoxyCompactList}\item 
V\+R\+Node? \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a11711962768f6818de5fb89cbbaeea65}{xr\+Node}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the X\+R\+Node associated with this XR controller. Note\+: If the tracking mode for this controller is specified as \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction_ab4a739b7f8a6748903e2ccc029df7a50a90589c47f06eb971d548591f23c285af}{Controller\+Tracking\+Mode.\+Custom}}, this value may be ignored. \end{DoxyCompactList}\item 
override bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa97e1a14b291fe8057eed37d09aa586d}{is\+Left}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets whether the controller is a left-\/hand controller. \end{DoxyCompactList}\item 
override Vector3 \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aaaa34551dbab0d0a98f1ab22f85adaa6}{position}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the last-\/tracked position of the controller. \end{DoxyCompactList}\item 
override Quaternion \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac6a09708dffecce4b8ef9e4e88097328}{rotation}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the last-\/tracked rotation of the controller. \end{DoxyCompactList}\item 
override Vector3 \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ae21cfe425c83f331f03044e9132674f7}{velocity}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the current velocity of the controller. \end{DoxyCompactList}\item 
override \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction_a9752eb3e2905e8ebd134fff20c155e6b}{Controller\+Type}} \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aae01e4ff3ef50d766b1a25d02b0e3e26}{controller\+Type}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the type of controller this is. For Interaction\+V\+R\+Controller, the type is always Controller\+Type.\+V\+R\+Controller. \end{DoxyCompactList}\item 
override \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}} \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a482076db355cd75653f6d9efc8015409}{int\+Hand}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em This implementation of Interaction\+Controller\+Base does not represent a \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} hand, so it need not return an \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}} object. \end{DoxyCompactList}\item 
override Vector3? \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a162487d30c42a8d26711bf80e75230c8}{hover\+Point}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the center point used for hover distance checking. \end{DoxyCompactList}\item 
override List$<$ Transform $>$ \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a79aa1c89e60ed3e606957e9c0d92a2b9}{\+\_\+primary\+Hover\+Points}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets the list of points to be used to perform higher-\/fidelity \char`\"{}primary hover\char`\"{} checks. Only one interaction object may be the primary hover of an interaction controller (\mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} hand or otherwise) at a time. Interface objects such as buttons can only be pressed when they are primarily hovered by an interaction controller, so it\textquotesingle{}s best to return points on whatever you expect to be able to use to push buttons with the controller. \end{DoxyCompactList}\item 
override \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_contact_bone}{Contact\+Bone}} \mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a97aebd084ca67cee40ef9f09a362394f}{contact\+Bones}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\item 
override Game\+Object \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a7dc27e56bd7d91b9af6bc5104b8cbd4e}{contact\+Bone\+Parent}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\item 
float \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa003958b17f12b0c1cfe801649e45147}{grasp\+Depressed\+Value}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The value between 0 and 1 past which the grasping axis value will cause an attempt to grasp a graspable interaction object near the grasp point. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aebfaa8d5cd025180c86947dcfb5c5cd8}{grasp\+Released\+Value}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em If the grasping axis value passes the grasp\+Depressed\+Value, it must then drop underneath this value in order to release the grasp attempt (potentially releasing a held object) and allow a new grasp attempt to occur. \end{DoxyCompactList}\item 
override List$<$ Vector3 $>$ \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a521422a5de1b36220698adc1c2b3da18}{grasp\+Manipulator\+Points}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets a list returning this controller\textquotesingle{}s hover\+Point. Because the Interaction\+V\+R\+Controller represents a rigid controller, any two points that rigidly move with the controller position and orientation will provide enough information. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 28 of file Interaction\+X\+R\+Controller.\+cs.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aad12f5a78dea6345158e44d87e17a5f6}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aad12f5a78dea6345158e44d87e17a5f6}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!checkShouldGrasp@{checkShouldGrasp}}
\index{checkShouldGrasp@{checkShouldGrasp}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{checkShouldGrasp()}{checkShouldGrasp()}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+check\+Should\+Grasp (\begin{DoxyParamCaption}\item[{out \mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}}}]{object\+To\+Grasp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Returns whether this controller should grasp an object this fixed frame, and if so, sets object\+To\+Grasp to the object the controller should grasp. 



Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a672d3a9313dbe37a693702024a61657d}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 780 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a4756d119b4d5a13574ed990e439e64f3}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a4756d119b4d5a13574ed990e439e64f3}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!checkShouldGraspAtemporal@{checkShouldGraspAtemporal}}
\index{checkShouldGraspAtemporal@{checkShouldGraspAtemporal}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{checkShouldGraspAtemporal()}{checkShouldGraspAtemporal()}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+check\+Should\+Grasp\+Atemporal (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}}}]{int\+Obj }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



If the provided object is within range of this VR controller\textquotesingle{}s grasp point and the grasp button is currently held down, this method will manually initiate a grasp and return true. Otherwise, the method returns false. 



Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a99f071b469073deb8265da627e90ad0c}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 796 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a46275014cfc4325621c01097047bb701}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a46275014cfc4325621c01097047bb701}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!checkShouldRelease@{checkShouldRelease}}
\index{checkShouldRelease@{checkShouldRelease}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{checkShouldRelease()}{checkShouldRelease()}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+check\+Should\+Release (\begin{DoxyParamCaption}\item[{out \mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}}}]{object\+To\+Release }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Returns whether this controller should release an object this fixed frame, and if so, sets object\+To\+Release to the object the controller should release. 



Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_ac2f99423db66dad0d889723c6acff62f}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 814 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa7e13f419009b2f0fd02018cc96f81b4}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa7e13f419009b2f0fd02018cc96f81b4}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!fixedUpdateController@{fixedUpdateController}}
\index{fixedUpdateController@{fixedUpdateController}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{fixedUpdateController()}{fixedUpdateController()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+fixed\+Update\+Controller (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Called just before the \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller}{Interaction\+Controller}} proceeds with its usual Fixed\+Update. 

It\textquotesingle{}s generally better to override this method instead of having your \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller}{Interaction\+Controller}} implement Fixed\+Update because its execution order relative to the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager is fixed. 

Reimplemented from \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_ad66e5a09bdbe3e9573a504734bbc34f8}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 179 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_abbf181ce05807d75809cac14c0fa8a27}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_abbf181ce05807d75809cac14c0fa8a27}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!fixedUpdateGraspingState@{fixedUpdateGraspingState}}
\index{fixedUpdateGraspingState@{fixedUpdateGraspingState}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{fixedUpdateGraspingState()}{fixedUpdateGraspingState()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+fixed\+Update\+Grasping\+State (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Called every fixed frame if grasping is enabled in the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager. 

grasp\+Activity\+Manager.\+Active\+Objects will contain objects around the hover\+Point within the grasping radius -- in other words, objects eligible to be grasped by the controller. Refer to it to avoid checking grasp eligibility against all graspable objects in your scene. 

Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a5d182056bac8aea2d0ec005e35f768ca}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 703 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6870022c14d8cea42d36502b7a0a299f}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6870022c14d8cea42d36502b7a0a299f}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!getColliderBoneTargetPositionRotation@{getColliderBoneTargetPositionRotation}}
\index{getColliderBoneTargetPositionRotation@{getColliderBoneTargetPositionRotation}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{getColliderBoneTargetPositionRotation()}{getColliderBoneTargetPositionRotation()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+get\+Collider\+Bone\+Target\+Position\+Rotation (\begin{DoxyParamCaption}\item[{int}]{contact\+Bone\+Index,  }\item[{out Vector3}]{target\+Position,  }\item[{out Quaternion}]{target\+Rotation }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contact\+Bones array. (For example, by recording the local position and local rotation of each contact bone in \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6646ebf671991c5bc47a66b2129538b6}{init\+Contact()}}). More complex controllers, such as \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}}, uses this method to set \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_contact_bone}{Contact\+Bone}} target positions and rotations based on the tracked \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} hand. 



Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_ae5ccd0183ff87fd51107a5b082116ce0}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 630 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_acf5f67ce22587c6d638890d9af2ecadb}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_acf5f67ce22587c6d638890d9af2ecadb}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!GetGraspPoint@{GetGraspPoint}}
\index{GetGraspPoint@{GetGraspPoint}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{GetGraspPoint()}{GetGraspPoint()}}
{\footnotesize\ttfamily override Vector3 Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+Get\+Grasp\+Point (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Returns approximately where the controller is grasping the currently grasped \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_behaviour}{Interaction\+Behaviour}}. This method will print an error if the controller is not currently grasping an object. 



Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_aca84a24dd5f2f73a7c8bee6a15cea0a4}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 699 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6646ebf671991c5bc47a66b2129538b6}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6646ebf671991c5bc47a66b2129538b6}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!initContact@{initContact}}
\index{initContact@{initContact}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{initContact()}{initContact()}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+init\+Contact (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Called to initialize contact colliders. See remarks for implementation requirements. 

\mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6646ebf671991c5bc47a66b2129538b6}{init\+Contact()}} should\+:
\begin{DoxyItemize}
\item Return false at any time if initialization cannot be performed.
\item Ensure the \char`\"{}contact\+Bones\char`\"{} property returns all contact colliders.
\begin{DoxyItemize}
\item (Construct contact colliders if they don\textquotesingle{}t already exist.)
\end{DoxyItemize}
\item Ensure the \char`\"{}contact\+Bone\+Parent\char`\"{} property returns the common parent of all contact colliders.
\begin{DoxyItemize}
\item (Construct the contact bone parent if it doesn\textquotesingle{}t already exist.)
\end{DoxyItemize}
\item Return true if initialization was successful.
\end{DoxyItemize}

Contact will only begin updating after initialization succeeds, otherwise it will try to initialize again on the next fixed frame.

After initialization, the contact bone parent\textquotesingle{}s layer will be set to the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager\textquotesingle{}s contact\+Bone\+Layer. 

Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a5d9713dd48f3093aefbd8ebbba3b0251}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 536 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a3d2b1845b1041d41e2a157df230ca42b}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a3d2b1845b1041d41e2a157df230ca42b}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!OnDrawRuntimeGizmos@{OnDrawRuntimeGizmos}}
\index{OnDrawRuntimeGizmos@{OnDrawRuntimeGizmos}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{OnDrawRuntimeGizmos()}{OnDrawRuntimeGizmos()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+On\+Draw\+Runtime\+Gizmos (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_leap_1_1_unity_1_1_runtime_gizmos_1_1_runtime_gizmo_drawer}{Runtime\+Gizmos.\+Runtime\+Gizmo\+Drawer}}}]{drawer }\end{DoxyParamCaption})}



Definition at line 827 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ab287ac4fbd0ba8471ef9787a371470ef}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ab287ac4fbd0ba8471ef9787a371470ef}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!onObjectUnregistered@{onObjectUnregistered}}
\index{onObjectUnregistered@{onObjectUnregistered}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{onObjectUnregistered()}{onObjectUnregistered()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+on\+Object\+Unregistered (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_interaction_behaviour}{I\+Interaction\+Behaviour}}}]{int\+Obj }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Interaction\+V\+R\+Controller doesn\textquotesingle{}t need to do anything when an object is unregistered. 



Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a0798edd8ad92d6b7f6229e3d9ac26d07}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 468 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac43db0f1fd87084d1b1468ce95bd58ac}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac43db0f1fd87084d1b1468ce95bd58ac}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!OnValidate@{OnValidate}}
\index{OnValidate@{OnValidate}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{OnValidate()}{OnValidate()}}
{\footnotesize\ttfamily virtual void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+On\+Validate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Definition at line 169 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84947d3cd2c236dab7849e2d805465b6}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84947d3cd2c236dab7849e2d805465b6}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!RefreshControllerConnection@{RefreshControllerConnection}}
\index{RefreshControllerConnection@{RefreshControllerConnection}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{RefreshControllerConnection()}{RefreshControllerConnection()}}
{\footnotesize\ttfamily void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+Refresh\+Controller\+Connection (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 229 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a17a8608c8d69b586256fbcb9877394b3}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a17a8608c8d69b586256fbcb9877394b3}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!Reset@{Reset}}
\index{Reset@{Reset}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{Reset()}{Reset()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Reimplemented from \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a593d87fbcfe464b2308a56a60b4796d5}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 153 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac50b109d0cd82bb14cd8a19199850c9e}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac50b109d0cd82bb14cd8a19199850c9e}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!Start@{Start}}
\index{Start@{Start}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{Start()}{Start()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+Start (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Reimplemented from \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_a697f206b8e73d177c203b3ca12874cb6}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 173 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aae371c99d08f9ce6e8850e36109690c5}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aae371c99d08f9ce6e8850e36109690c5}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!unwarpColliders@{unwarpColliders}}
\index{unwarpColliders@{unwarpColliders}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{unwarpColliders()}{unwarpColliders()}}
{\footnotesize\ttfamily override void Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+unwarp\+Colliders (\begin{DoxyParamCaption}\item[{Transform}]{primary\+Hover\+Point,  }\item[{\mbox{\hyperlink{interface_leap_1_1_unity_1_1_space_1_1_i_space_component}{I\+Space\+Component}}}]{warped\+Space\+Element }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Implementing this method is necessary to support curved spaces as rendered by a \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} Graphic Renderer. See \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} Graphic Renderer.) 

Warps the collider transforms of this controller by the inverse of the transformation that is applied on the provided warped\+Space\+Element, using the primary\+Hover\+Point as the pivot transform for the transformation.

I\+Transformer.\+World\+Space\+Unwarp is a useful method here. (I\+Space\+Components contain references to their transformers via their anchors.)

I\+Space\+Components denote game objects whose visual positions are warped from rectilinear (non-\/warped) space into a curved space (via, for example, a Leap\+Cylindrical\+Space, which can only be rendered correctly by the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} Graphic Renderer). This method reverses that transformation for the hand, bringing it into the object\textquotesingle{}s rectilinear space, allowing objects curved in this way to correctly collide with the bones in the hand or collider of a held controller.

The provided Transform is the closest primary hover point to any given primary hover candidate, so it is used as the pivot point for unwarping the colliders of this \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller}{Interaction\+Controller}}. 

Implements \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller_aef6aebf580bed0a675b59e1c4a267376}{Leap.\+Unity.\+Interaction.\+Interaction\+Controller}}.



Definition at line 497 of file Interaction\+X\+R\+Controller.\+cs.



\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a5c3b54bb8249aacff51aa5e898d95021}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a5c3b54bb8249aacff51aa5e898d95021}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspAxisOverride@{graspAxisOverride}}
\index{graspAxisOverride@{graspAxisOverride}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspAxisOverride}{graspAxisOverride}}
{\footnotesize\ttfamily Func$<$float$>$ Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Axis\+Override = null}



By default, Interaction\+V\+R\+Controller uses Input.\+Get\+Axis(grasp\+Button\+Axis) to determine the \char`\"{}depression\char`\"{} state for the grasp button. By setting this value to something other than null, it is possible to modify this behavior to instead retrieve a grasping axis value based on arbitrary code. 

A grasp is attempted when the grasp button axis value returned by this method becomes larger than the grasp\+Button\+Depressed\+Value, and a grasp is released when the grasp button axis value returned by this method becomes smaller than the grasp\+Button\+Released\+Value. Both of these values provide public setters. 

Definition at line 652 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a857761fb2f53cdf7e9ffd28f396c4712}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a857761fb2f53cdf7e9ffd28f396c4712}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspButtonAxis@{graspButtonAxis}}
\index{graspButtonAxis@{graspButtonAxis}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspButtonAxis}{graspButtonAxis}}
{\footnotesize\ttfamily string Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Button\+Axis}



Definition at line 118 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a45e35489ae52235acd3cece14cf4dbae}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a45e35489ae52235acd3cece14cf4dbae}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspPoint@{graspPoint}}
\index{graspPoint@{graspPoint}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspPoint}{graspPoint}}
{\footnotesize\ttfamily Transform Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Point}



Definition at line 112 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6fe4112d61321e09eabefbc59af9d13a}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a6fe4112d61321e09eabefbc59af9d13a}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspTimingSlop@{graspTimingSlop}}
\index{graspTimingSlop@{graspTimingSlop}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspTimingSlop}{graspTimingSlop}}
{\footnotesize\ttfamily float Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Timing\+Slop = 0.\+10F}



Definition at line 125 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_abd2f8566d2d0e95acd51ae7718b8bc98}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_abd2f8566d2d0e95acd51ae7718b8bc98}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!maxGraspDistance@{maxGraspDistance}}
\index{maxGraspDistance@{maxGraspDistance}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{maxGraspDistance}{maxGraspDistance}}
{\footnotesize\ttfamily float Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+max\+Grasp\+Distance = 0.\+06F}



Definition at line 114 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a870363d8aa13c1d14481b988608b195e}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a870363d8aa13c1d14481b988608b195e}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!pollConnectionInterval@{pollConnectionInterval}}
\index{pollConnectionInterval@{pollConnectionInterval}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{pollConnectionInterval}{pollConnectionInterval}}
{\footnotesize\ttfamily float Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+poll\+Connection\+Interval = 2f}



Definition at line 83 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a1b5abc7602f840695df4eae23ead0e37}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a1b5abc7602f840695df4eae23ead0e37}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!primaryHoverPoints@{primaryHoverPoints}}
\index{primaryHoverPoints@{primaryHoverPoints}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{primaryHoverPoints}{primaryHoverPoints}}
{\footnotesize\ttfamily new List$<$Transform$>$ Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+primary\+Hover\+Points}



Definition at line 104 of file Interaction\+X\+R\+Controller.\+cs.



\subsection{Property Documentation}
\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a79aa1c89e60ed3e606957e9c0d92a2b9}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a79aa1c89e60ed3e606957e9c0d92a2b9}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!\_primaryHoverPoints@{\_primaryHoverPoints}}
\index{\_primaryHoverPoints@{\_primaryHoverPoints}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{\_primaryHoverPoints}{\_primaryHoverPoints}}
{\footnotesize\ttfamily override List$<$Transform$>$ Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+\_\+primary\+Hover\+Points\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [protected]}}



Gets the list of points to be used to perform higher-\/fidelity \char`\"{}primary hover\char`\"{} checks. Only one interaction object may be the primary hover of an interaction controller (\mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} hand or otherwise) at a time. Interface objects such as buttons can only be pressed when they are primarily hovered by an interaction controller, so it\textquotesingle{}s best to return points on whatever you expect to be able to use to push buttons with the controller. 



Definition at line 489 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84e32cb318c25dbb329b6766c6f895f8}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84e32cb318c25dbb329b6766c6f895f8}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!chirality@{chirality}}
\index{chirality@{chirality}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{chirality}{chirality}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_leap_1_1_unity_a4d15adcf20ba121b2cd9c07f503b606f}{Chirality}} Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+chirality\hspace{0.3cm}{\ttfamily [get]}}



Definition at line 58 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a7dc27e56bd7d91b9af6bc5104b8cbd4e}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a7dc27e56bd7d91b9af6bc5104b8cbd4e}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!contactBoneParent@{contactBoneParent}}
\index{contactBoneParent@{contactBoneParent}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{contactBoneParent}{contactBoneParent}}
{\footnotesize\ttfamily override Game\+Object Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+contact\+Bone\+Parent\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [protected]}}



Definition at line 532 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a97aebd084ca67cee40ef9f09a362394f}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a97aebd084ca67cee40ef9f09a362394f}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!contactBones@{contactBones}}
\index{contactBones@{contactBones}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{contactBones}{contactBones}}
{\footnotesize\ttfamily override \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_contact_bone}{Contact\+Bone}} \mbox{[}$\,$\mbox{]} Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+contact\+Bones\hspace{0.3cm}{\ttfamily [get]}}



Definition at line 527 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aae01e4ff3ef50d766b1a25d02b0e3e26}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aae01e4ff3ef50d766b1a25d02b0e3e26}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!controllerType@{controllerType}}
\index{controllerType@{controllerType}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{controllerType}{controllerType}}
{\footnotesize\ttfamily override \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction_a9752eb3e2905e8ebd134fff20c155e6b}{Controller\+Type}} Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+controller\+Type\hspace{0.3cm}{\ttfamily [get]}}



Gets the type of controller this is. For Interaction\+V\+R\+Controller, the type is always Controller\+Type.\+V\+R\+Controller. 



Definition at line 452 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac3f3ac7b791e70390c8ba9a547162525}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac3f3ac7b791e70390c8ba9a547162525}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!deviceJoystickTokens@{deviceJoystickTokens}}
\index{deviceJoystickTokens@{deviceJoystickTokens}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{deviceJoystickTokens}{deviceJoystickTokens}}
{\footnotesize\ttfamily string Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+device\+Joystick\+Tokens\hspace{0.3cm}{\ttfamily [get]}}



Definition at line 52 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a0cf4a1150ff9575affb5532f1e252b6a}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a0cf4a1150ff9575affb5532f1e252b6a}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!enableObjectsOnlyWhenTracked@{enableObjectsOnlyWhenTracked}}
\index{enableObjectsOnlyWhenTracked@{enableObjectsOnlyWhenTracked}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{enableObjectsOnlyWhenTracked}{enableObjectsOnlyWhenTracked}}
{\footnotesize\ttfamily List$<$Game\+Object$>$ Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+enable\+Objects\+Only\+When\+Tracked\hspace{0.3cm}{\ttfamily [get]}}



These objects will be made active only while the controller is tracked. For more fine-\/tuned behavior, we recommend implementing your own logic. 

controller.\+is\+Joystick\+Detected and controller.\+is\+Tracked are useful for this. 

Definition at line 140 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa003958b17f12b0c1cfe801649e45147}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa003958b17f12b0c1cfe801649e45147}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspDepressedValue@{graspDepressedValue}}
\index{graspDepressedValue@{graspDepressedValue}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspDepressedValue}{graspDepressedValue}}
{\footnotesize\ttfamily float Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Depressed\+Value\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The value between 0 and 1 past which the grasping axis value will cause an attempt to grasp a graspable interaction object near the grasp point. 



Definition at line 659 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a521422a5de1b36220698adc1c2b3da18}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a521422a5de1b36220698adc1c2b3da18}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspManipulatorPoints@{graspManipulatorPoints}}
\index{graspManipulatorPoints@{graspManipulatorPoints}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspManipulatorPoints}{graspManipulatorPoints}}
{\footnotesize\ttfamily override List$<$Vector3$>$ Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Manipulator\+Points\hspace{0.3cm}{\ttfamily [get]}}



Gets a list returning this controller\textquotesingle{}s hover\+Point. Because the Interaction\+V\+R\+Controller represents a rigid controller, any two points that rigidly move with the controller position and orientation will provide enough information. 



Definition at line 682 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aebfaa8d5cd025180c86947dcfb5c5cd8}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aebfaa8d5cd025180c86947dcfb5c5cd8}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!graspReleasedValue@{graspReleasedValue}}
\index{graspReleasedValue@{graspReleasedValue}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{graspReleasedValue}{graspReleasedValue}}
{\footnotesize\ttfamily float Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+grasp\+Released\+Value\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



If the grasping axis value passes the grasp\+Depressed\+Value, it must then drop underneath this value in order to release the grasp attempt (potentially releasing a held object) and allow a new grasp attempt to occur. 



Definition at line 670 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a162487d30c42a8d26711bf80e75230c8}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a162487d30c42a8d26711bf80e75230c8}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!hoverPoint@{hoverPoint}}
\index{hoverPoint@{hoverPoint}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{hoverPoint}{hoverPoint}}
{\footnotesize\ttfamily override Vector3? Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+hover\+Point\hspace{0.3cm}{\ttfamily [get]}}



Gets the center point used for hover distance checking. 



Definition at line 477 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a482076db355cd75653f6d9efc8015409}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a482076db355cd75653f6d9efc8015409}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!intHand@{intHand}}
\index{intHand@{intHand}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{intHand}{intHand}}
{\footnotesize\ttfamily override \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}} Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+int\+Hand\hspace{0.3cm}{\ttfamily [get]}}



This implementation of Interaction\+Controller\+Base does not represent a \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_leap}{Leap}} hand, so it need not return an \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand}{Interaction\+Hand}} object. 



Definition at line 460 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a362ab5e9ffb5ac5046a869668670b40c}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a362ab5e9ffb5ac5046a869668670b40c}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!isBeingMoved@{isBeingMoved}}
\index{isBeingMoved@{isBeingMoved}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{isBeingMoved}{isBeingMoved}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+is\+Being\+Moved\hspace{0.3cm}{\ttfamily [get]}}



Gets whether or not the underlying controller is currently being moved in world space, but relative to the \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager\textquotesingle{}s transform. The \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction}{Interaction}} Manager is usually a sibling of the main camera beneath the camera rig transform, so that if your application is only translating the player rig in space, this method won\textquotesingle{}t incorrectly return true. 



Definition at line 387 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac017dcb1298c729f9cc46f24aeeb6a00}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac017dcb1298c729f9cc46f24aeeb6a00}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!isJoystickDetected@{isJoystickDetected}}
\index{isJoystickDetected@{isJoystickDetected}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{isJoystickDetected}{isJoystickDetected}}
{\footnotesize\ttfamily bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+is\+Joystick\+Detected\hspace{0.3cm}{\ttfamily [get]}}



Whether the device joystick tokens matched an entry in Input.\+Get\+Joystick\+Names(). If poll\+Connection is set to true, this status is refreshed periodically based on the poll\+Connection\+Interval, but only while the joystick tokens have not been detected from Input.\+Get\+Joystick\+Names(). Call \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84947d3cd2c236dab7849e2d805465b6}{Refresh\+Controller\+Connection()}} to detect if the controller has been disconnected. 

Joystick detection is skipped if device\+Joystick\+Tokens is null or empty, causing this check to always return true. 

Definition at line 211 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa97e1a14b291fe8057eed37d09aa586d}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aa97e1a14b291fe8057eed37d09aa586d}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!isLeft@{isLeft}}
\index{isLeft@{isLeft}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{isLeft}{isLeft}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+is\+Left\hspace{0.3cm}{\ttfamily [get]}}



Gets whether the controller is a left-\/hand controller. 



Definition at line 412 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ab5d50597383ad3e552e3c16d1e91e5a7}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ab5d50597383ad3e552e3c16d1e91e5a7}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!isTracked@{isTracked}}
\index{isTracked@{isTracked}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{isTracked}{isTracked}}
{\footnotesize\ttfamily override bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+is\+Tracked\hspace{0.3cm}{\ttfamily [get]}}



Gets whether or not the underlying controller is currently tracked and any joystick token filtering has confirmed that this controller has been detected as a connected joystick. 



Definition at line 374 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a621446c06cfa8391f7f0d8990d885bf5}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a621446c06cfa8391f7f0d8990d885bf5}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!isUsingCustomTracking@{isUsingCustomTracking}}
\index{isUsingCustomTracking@{isUsingCustomTracking}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{isUsingCustomTracking}{isUsingCustomTracking}}
{\footnotesize\ttfamily bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+is\+Using\+Custom\+Tracking\hspace{0.3cm}{\ttfamily [get]}}



Definition at line 43 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a96ffe3a41a49ca69c3e15de4badbb98b}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a96ffe3a41a49ca69c3e15de4badbb98b}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!pollConnection@{pollConnection}}
\index{pollConnection@{pollConnection}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{pollConnection}{pollConnection}}
{\footnotesize\ttfamily bool Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+poll\+Connection\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Whether to continuously poll attached joystick data for a joystick that matches the device joystick tokens, using Input.\+Get\+Joystick\+Names(). This call allocates garbage, so be wary of setting a low polling interval. 

The connection is polled only until a joystick is detected to minimize allocation. Once a joystick has been detected (is\+Joystick\+Detected), you must manually call \mbox{\hyperlink{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a84947d3cd2c236dab7849e2d805465b6}{Refresh\+Controller\+Connection()}} to check if the joystick is no longer detected. 

Definition at line 74 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aaaa34551dbab0d0a98f1ab22f85adaa6}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aaaa34551dbab0d0a98f1ab22f85adaa6}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!position@{position}}
\index{position@{position}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{position}{position}}
{\footnotesize\ttfamily override Vector3 Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+position\hspace{0.3cm}{\ttfamily [get]}}



Gets the last-\/tracked position of the controller. 



Definition at line 419 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac6a09708dffecce4b8ef9e4e88097328}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ac6a09708dffecce4b8ef9e4e88097328}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!rotation@{rotation}}
\index{rotation@{rotation}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{rotation}{rotation}}
{\footnotesize\ttfamily override Quaternion Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+rotation\hspace{0.3cm}{\ttfamily [get]}}



Gets the last-\/tracked rotation of the controller. 



Definition at line 428 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aebc2b694592123f75013dd012e8f357f}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_aebc2b694592123f75013dd012e8f357f}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!trackingProvider@{trackingProvider}}
\index{trackingProvider@{trackingProvider}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{trackingProvider}{trackingProvider}}
{\footnotesize\ttfamily \mbox{\hyperlink{interface_leap_1_1_unity_1_1_interaction_1_1_i_x_r_controller_tracking_provider}{I\+X\+R\+Controller\+Tracking\+Provider}} Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+tracking\+Provider\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Definition at line 254 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ae21cfe425c83f331f03044e9132674f7}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_ae21cfe425c83f331f03044e9132674f7}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!velocity@{velocity}}
\index{velocity@{velocity}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{velocity}{velocity}}
{\footnotesize\ttfamily override Vector3 Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+velocity\hspace{0.3cm}{\ttfamily [get]}}



Gets the current velocity of the controller. 



Definition at line 437 of file Interaction\+X\+R\+Controller.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a11711962768f6818de5fb89cbbaeea65}\label{class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller_a11711962768f6818de5fb89cbbaeea65}} 
\index{Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}!xrNode@{xrNode}}
\index{xrNode@{xrNode}!Leap.Unity.Interaction.InteractionXRController@{Leap.Unity.Interaction.InteractionXRController}}
\subsubsection{\texorpdfstring{xrNode}{xrNode}}
{\footnotesize\ttfamily V\+R\+Node? Leap.\+Unity.\+Interaction.\+Interaction\+X\+R\+Controller.\+xr\+Node\hspace{0.3cm}{\ttfamily [get]}}



Gets the X\+R\+Node associated with this XR controller. Note\+: If the tracking mode for this controller is specified as \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_interaction_ab4a739b7f8a6748903e2ccc029df7a50a90589c47f06eb971d548591f23c285af}{Controller\+Tracking\+Mode.\+Custom}}, this value may be ignored. 



Definition at line 404 of file Interaction\+X\+R\+Controller.\+cs.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
O\+:/\+Git\+H\+U\+B\+M\+I\+N\+I\+P\+Roject/\+Assets/\+Leap\+Motion/\+Modules/\+Interaction\+Engine/\+Scripts/\mbox{\hyperlink{_interaction_x_r_controller_8cs}{Interaction\+X\+R\+Controller.\+cs}}\end{DoxyCompactItemize}
