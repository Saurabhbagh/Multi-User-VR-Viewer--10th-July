\hypertarget{interface_leap_1_1_unity_1_1_i_indexable_struct}{}\section{Leap.\+Unity.\+I\+Indexable\+Struct$<$ T, This\+Indexable\+Type $>$ Interface Template Reference}
\label{interface_leap_1_1_unity_1_1_i_indexable_struct}\index{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$@{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$}}


This is a definition-\/friendly interface that new \char`\"{}indexable\char`\"{} struct definitions can implement to make it a little easier to implement foreach and Query() operations for their struct. (You can use the \mbox{\hyperlink{struct_leap_1_1_unity_1_1_indexable_struct_enumerator}{Indexable\+Struct\+Enumerator}} for this purpose, you just have to pass it type arguments that correspond to your struct type.)  


\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
T \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct_ad7283ee0dd67d3a6c03fd76050ec220b}{this\mbox{[}int idx\mbox{]}}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\item 
int \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct_ad6584007443da506772ba213121443d5}{Count}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This is a definition-\/friendly interface that new \char`\"{}indexable\char`\"{} struct definitions can implement to make it a little easier to implement foreach and Query() operations for their struct. (You can use the \mbox{\hyperlink{struct_leap_1_1_unity_1_1_indexable_struct_enumerator}{Indexable\+Struct\+Enumerator}} for this purpose, you just have to pass it type arguments that correspond to your struct type.) 

Unlike \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable}{I\+Indexable}}, \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct}{I\+Indexable\+Struct}} cannot utilize extension methods to automatically give consumers of the interface access to foreach and \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_query}{Query}} operations because consumption of a struct via an interface parameter forces the struct to be boxed, which causes allocation. As such, \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct}{I\+Indexable\+Struct}} does not directly implement \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable}{I\+Indexable}}.

(This all may change in C\# 8 when we get traits, but \mbox{\hyperlink{namespace_leap_1_1_unity}{Unity}} is still in the C\# 4 stone age.) \begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em This\+Indexable\+Type} : {\em struct}]\item[{\em This\+Indexable\+Type} : {\em \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct}{I\+Indexable\+Struct}}}]\item[{\em This\+Indexable\+Type} : {\em T}]\item[{\em This\+Indexable\+Type} : {\em This\+Indexable\+Type}]\end{description}
\end{Desc}


Definition at line 30 of file I\+Indexable\+Struct.\+cs.



\subsection{Property Documentation}
\mbox{\Hypertarget{interface_leap_1_1_unity_1_1_i_indexable_struct_ad6584007443da506772ba213121443d5}\label{interface_leap_1_1_unity_1_1_i_indexable_struct_ad6584007443da506772ba213121443d5}} 
\index{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$@{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$}!Count@{Count}}
\index{Count@{Count}!Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$@{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$}}
\subsubsection{\texorpdfstring{Count}{Count}}
{\footnotesize\ttfamily int \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct}{Leap.\+Unity.\+I\+Indexable\+Struct}}$<$ T, This\+Indexable\+Type $>$.Count\hspace{0.3cm}{\ttfamily [get]}}



Definition at line 36 of file I\+Indexable\+Struct.\+cs.

\mbox{\Hypertarget{interface_leap_1_1_unity_1_1_i_indexable_struct_ad7283ee0dd67d3a6c03fd76050ec220b}\label{interface_leap_1_1_unity_1_1_i_indexable_struct_ad7283ee0dd67d3a6c03fd76050ec220b}} 
\index{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$@{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$}!this\mbox{[}int idx\mbox{]}@{this[int idx]}}
\index{this\mbox{[}int idx\mbox{]}@{this[int idx]}!Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$@{Leap.Unity.IIndexableStruct$<$ T, ThisIndexableType $>$}}
\subsubsection{\texorpdfstring{this[int idx]}{this[int idx]}}
{\footnotesize\ttfamily T \mbox{\hyperlink{interface_leap_1_1_unity_1_1_i_indexable_struct}{Leap.\+Unity.\+I\+Indexable\+Struct}}$<$ T, This\+Indexable\+Type $>$.this\mbox{[}int idx\mbox{]}\hspace{0.3cm}{\ttfamily [get]}}



Definition at line 34 of file I\+Indexable\+Struct.\+cs.



The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
O\+:/\+Git\+H\+U\+B\+M\+I\+N\+I\+P\+Roject/\+Assets/\+Leap\+Motion/\+Core/\+Scripts/\+Data\+Structures/\mbox{\hyperlink{_i_indexable_struct_8cs}{I\+Indexable\+Struct.\+cs}}\end{DoxyCompactItemize}
