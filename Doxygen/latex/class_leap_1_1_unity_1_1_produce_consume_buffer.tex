\hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer}{}\section{Leap.\+Unity.\+Produce\+Consume\+Buffer$<$ T $>$ Class Template Reference}
\label{class_leap_1_1_unity_1_1_produce_consume_buffer}\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_abb2dd45e9fdf9542e1392a16b5a19a9e}{Produce\+Consume\+Buffer}} (int min\+Capacity)
\begin{DoxyCompactList}\small\item\em Constructs a new produce consumer buffer of at least a certain capacity. Once the buffer is created, the capacity cannot be modified. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_a2c3eaa1d8aafc68cf6d8d020ae47e4de}{Try\+Enqueue}} (ref T t)
\begin{DoxyCompactList}\small\item\em Tries to enqueue a value into the buffer. If the buffer is already full, this method will perform no action and return false. This method is only safe to be called from a single producer thread. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_ae80a5be8a8e07eb8b922fdfca764f1da}{Try\+Enqueue}} (T t)
\begin{DoxyCompactList}\small\item\em Tries to enqueue a value into the buffer. If the buffer is already full, this method will perform no action and return false. This method is only safe to be called from a single producer thread. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_a4884c0e9c693c92439a2bc7fe99275e9}{Try\+Peek}} (out T t)
\begin{DoxyCompactList}\small\item\em Tries to get the next element that would be dequeued from this buffer. If there is no element yet, this method will return false. If there is an element ready to be dequeued, it will be copied to the out param and this method will return true. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_a8974fa947fcc940620300c54d3de6f1b}{Try\+Dequeue}} (out T t)
\begin{DoxyCompactList}\small\item\em Tries to dequeue a value off of the buffer. If the buffer is empty this method will perform no action and return false. This method is only safe to be called from a single consumer thread. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_a0a756b193a73f2ab9dd21a89dce33b65}{Try\+Dequeue}} ()
\begin{DoxyCompactList}\small\item\em Tries to dequeue a value off of the buffer. If the buffer is empty this method will perform no action and return false. This method is only safe to be called from a single consumer thread. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_a72a0d4ce3f8ec48ed46fa80f5944f988}{Try\+Dequeue\+All}} (out T most\+Recent)
\begin{DoxyCompactList}\small\item\em Tries to dequeue all values off of the buffer, returning the most recently added element. If there was an element found, this method will return true, else it will return false. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_a04753532a728b38e5cc0226c797fbef1}{Capacity}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the maximum number of elements that the buffer can hold. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer_ab7a378bf347d928035288ae0e790b938}{Count}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the current number of elements that are held inside the buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 15 of file Produce\+Consume\+Buffer.\+cs.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_abb2dd45e9fdf9542e1392a16b5a19a9e}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_abb2dd45e9fdf9542e1392a16b5a19a9e}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!ProduceConsumeBuffer@{ProduceConsumeBuffer}}
\index{ProduceConsumeBuffer@{ProduceConsumeBuffer}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{ProduceConsumeBuffer()}{ProduceConsumeBuffer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.\mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Produce\+Consume\+Buffer}} (\begin{DoxyParamCaption}\item[{int}]{min\+Capacity }\end{DoxyParamCaption})}



Constructs a new produce consumer buffer of at least a certain capacity. Once the buffer is created, the capacity cannot be modified. 

If the minimum capacity is a power of two, it will be used as the actual capacity. If the minimum capacity is not a power of two, the next highest power of two will be used as the capacity. This behavior is an optimization, Internally this class uses a bitwise A\+ND operation instead of a slower modulus operation for indexing, which only is possible if the array length is a power of two. 

Definition at line 30 of file Produce\+Consume\+Buffer.\+cs.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_a8974fa947fcc940620300c54d3de6f1b}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_a8974fa947fcc940620300c54d3de6f1b}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!TryDequeue@{TryDequeue}}
\index{TryDequeue@{TryDequeue}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{TryDequeue()}{TryDequeue()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Try\+Dequeue (\begin{DoxyParamCaption}\item[{out T}]{t }\end{DoxyParamCaption})}



Tries to dequeue a value off of the buffer. If the buffer is empty this method will perform no action and return false. This method is only safe to be called from a single consumer thread. 



Definition at line 127 of file Produce\+Consume\+Buffer.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_a0a756b193a73f2ab9dd21a89dce33b65}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_a0a756b193a73f2ab9dd21a89dce33b65}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!TryDequeue@{TryDequeue}}
\index{TryDequeue@{TryDequeue}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{TryDequeue()}{TryDequeue()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Try\+Dequeue (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Tries to dequeue a value off of the buffer. If the buffer is empty this method will perform no action and return false. This method is only safe to be called from a single consumer thread. 



Definition at line 143 of file Produce\+Consume\+Buffer.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_a72a0d4ce3f8ec48ed46fa80f5944f988}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_a72a0d4ce3f8ec48ed46fa80f5944f988}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!TryDequeueAll@{TryDequeueAll}}
\index{TryDequeueAll@{TryDequeueAll}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{TryDequeueAll()}{TryDequeueAll()}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Try\+Dequeue\+All (\begin{DoxyParamCaption}\item[{out T}]{most\+Recent }\end{DoxyParamCaption})}



Tries to dequeue all values off of the buffer, returning the most recently added element. If there was an element found, this method will return true, else it will return false. 



Definition at line 157 of file Produce\+Consume\+Buffer.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_a2c3eaa1d8aafc68cf6d8d020ae47e4de}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_a2c3eaa1d8aafc68cf6d8d020ae47e4de}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!TryEnqueue@{TryEnqueue}}
\index{TryEnqueue@{TryEnqueue}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{TryEnqueue()}{TryEnqueue()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Try\+Enqueue (\begin{DoxyParamCaption}\item[{ref T}]{t }\end{DoxyParamCaption})}



Tries to enqueue a value into the buffer. If the buffer is already full, this method will perform no action and return false. This method is only safe to be called from a single producer thread. 



Definition at line 83 of file Produce\+Consume\+Buffer.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_ae80a5be8a8e07eb8b922fdfca764f1da}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_ae80a5be8a8e07eb8b922fdfca764f1da}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!TryEnqueue@{TryEnqueue}}
\index{TryEnqueue@{TryEnqueue}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{TryEnqueue()}{TryEnqueue()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Try\+Enqueue (\begin{DoxyParamCaption}\item[{T}]{t }\end{DoxyParamCaption})}



Tries to enqueue a value into the buffer. If the buffer is already full, this method will perform no action and return false. This method is only safe to be called from a single producer thread. 



Definition at line 97 of file Produce\+Consume\+Buffer.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_a4884c0e9c693c92439a2bc7fe99275e9}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_a4884c0e9c693c92439a2bc7fe99275e9}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!TryPeek@{TryPeek}}
\index{TryPeek@{TryPeek}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{TryPeek()}{TryPeek()}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Try\+Peek (\begin{DoxyParamCaption}\item[{out T}]{t }\end{DoxyParamCaption})}



Tries to get the next element that would be dequeued from this buffer. If there is no element yet, this method will return false. If there is an element ready to be dequeued, it will be copied to the out param and this method will return true. 

This method is only safe to be called from a single consumer thread. 

Definition at line 109 of file Produce\+Consume\+Buffer.\+cs.



\subsection{Property Documentation}
\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_a04753532a728b38e5cc0226c797fbef1}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_a04753532a728b38e5cc0226c797fbef1}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!Capacity@{Capacity}}
\index{Capacity@{Capacity}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Capacity}{Capacity}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Capacity\hspace{0.3cm}{\ttfamily [get]}}



Returns the maximum number of elements that the buffer can hold. 



Definition at line 56 of file Produce\+Consume\+Buffer.\+cs.

\mbox{\Hypertarget{class_leap_1_1_unity_1_1_produce_consume_buffer_ab7a378bf347d928035288ae0e790b938}\label{class_leap_1_1_unity_1_1_produce_consume_buffer_ab7a378bf347d928035288ae0e790b938}} 
\index{Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}!Count@{Count}}
\index{Count@{Count}!Leap.Unity.ProduceConsumeBuffer$<$ T $>$@{Leap.Unity.ProduceConsumeBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Count}{Count}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_leap_1_1_unity_1_1_produce_consume_buffer}{Leap.\+Unity.\+Produce\+Consume\+Buffer}}$<$ T $>$.Count\hspace{0.3cm}{\ttfamily [get]}}



Returns the current number of elements that are held inside the buffer. 



Definition at line 65 of file Produce\+Consume\+Buffer.\+cs.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
O\+:/\+Git\+H\+U\+B\+M\+I\+N\+I\+P\+Roject/\+Assets/\+Leap\+Motion/\+Core/\+Scripts/\+Data\+Structures/\mbox{\hyperlink{_produce_consume_buffer_8cs}{Produce\+Consume\+Buffer.\+cs}}\end{DoxyCompactItemize}
