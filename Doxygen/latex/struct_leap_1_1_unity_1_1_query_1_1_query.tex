\hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query}{}\section{Leap.\+Unity.\+Query.\+Query$<$ T $>$ Struct Template Reference}
\label{struct_leap_1_1_unity_1_1_query_1_1_query}\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}


A \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} object is a type of immutable ordered collection of elements that can be used to perform useful queries. These queries are very similar to L\+I\+NQ style queries, providing useful methods such as Where, Select, Concat, etc....  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_enumerator}{Enumerator}}
\item 
struct \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_query_slice}{Query\+Slice}}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a045e15022385ac33bf7ea2448de59f93}{Query}} (T\mbox{[}$\,$\mbox{]} array, int count)
\begin{DoxyCompactList}\small\item\em Constructs a new query given a source array and a count. The query assumes ownership of the array, so you should not use it or store it after the query is constructed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a38ad1df9355f871cde35fe9ca7c72da0}{Query}} (I\+Collection$<$ T $>$ collection)
\begin{DoxyCompactList}\small\item\em Constructs a new query of the given collection. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a023addd104eccd2f92b37e67eb84208f}{Query}} (\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}}$<$ T $>$ other)
\begin{DoxyCompactList}\small\item\em Constructs a query that is an exact copy of another query. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}}$<$ K $>$ \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a88411752d9806dc0364de025ac9b53b9}{Of\+Type$<$ K $>$}} ()
\begin{DoxyCompactList}\small\item\em Returns a new \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} representing only the items of the current \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} that are of a specific type. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}}$<$ K $>$ \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a907b194ea3d1901191343fa409ca6c42}{Cast$<$ K $>$}} ()
\begin{DoxyCompactList}\small\item\em Returns a new \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} representing the current query sequence where each element is cast to a new type. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a4c333e8a0bb14c3237fa65d2ad308c5a}{Dispose}} ()
\begin{DoxyCompactList}\small\item\em Disposes of the resources that this query holds. The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} cannot be used after this method is called. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a411e47e60b7ae4d9df1d64f280feb617}{Deconstruct}} (out T\mbox{[}$\,$\mbox{]} array, out int count)
\begin{DoxyCompactList}\small\item\em Deconstructs this \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} into its base elements, the array and the count. The caller assumes ownership of the array and is responsible for managing its lifecycle. The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} cannot be used after this method is called. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_query_slice}{Query\+Slice}} \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a945832fdab8203804442a9d043ea55cf}{Deconstruct}} ()
\begin{DoxyCompactList}\small\item\em Deconstructs this \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} into a simple \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_query_slice}{Query\+Slice}} construct. This is simply a utility overload of the regular Deconstruct method. The user is still responsible for managing the memory lifecycle of the returned slice. The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} cannot be used after this method is called. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_enumerator}{Enumerator}} \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a754dd1572406e8be39111c186daa1b74}{Get\+Enumerator}} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} object is a type of immutable ordered collection of elements that can be used to perform useful queries. These queries are very similar to L\+I\+NQ style queries, providing useful methods such as Where, Select, Concat, etc.... 

The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} struct and its interfaces use a pooling strategy backed by Array\+Pool to incur an amortized cost of zero GC allocations.

A \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} struct is immutable, and so cannot be modified once it has been created. You can use a query in few ways\+:
\begin{DoxyItemize}
\item The simplest way is to call an operator method such as Where or Select. These methods C\+O\+N\+S\+U\+ME the query to produce a new query. Trying to use the original query after it has been consumed will cause a runtime error.
\item The next way is to call a collapsing operator, which will consume the query and produce a non-\/query value or other side-\/effect. \mbox{\hyperlink{namespace_leap_1_1_unity_1_1_examples}{Examples}} of collapsing operators are First, Last, or Element\+At.
\item The last way to use a query is to Deconstruct it, by calling a Deconstruct method to destroy the query and get access to its underlying data. You will be responsible for cleaning up or disposing the data you get. 
\end{DoxyItemize}

Definition at line 91 of file Query.\+cs.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a045e15022385ac33bf7ea2448de59f93}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a045e15022385ac33bf7ea2448de59f93}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Query@{Query}}
\index{Query@{Query}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Query()}{Query()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{int}]{count }\end{DoxyParamCaption})}



Constructs a new query given a source array and a count. The query assumes ownership of the array, so you should not use it or store it after the query is constructed. 



Definition at line 102 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a38ad1df9355f871cde35fe9ca7c72da0}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a38ad1df9355f871cde35fe9ca7c72da0}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Query@{Query}}
\index{Query@{Query}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Query()}{Query()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} (\begin{DoxyParamCaption}\item[{I\+Collection$<$ T $>$}]{collection }\end{DoxyParamCaption})}



Constructs a new query of the given collection. 



Definition at line 123 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a023addd104eccd2f92b37e67eb84208f}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a023addd104eccd2f92b37e67eb84208f}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Query@{Query}}
\index{Query@{Query}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Query()}{Query()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}}$<$ T $>$}]{other }\end{DoxyParamCaption})}



Constructs a query that is an exact copy of another query. 



Definition at line 134 of file Query.\+cs.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a907b194ea3d1901191343fa409ca6c42}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a907b194ea3d1901191343fa409ca6c42}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Cast$<$ K $>$@{Cast$<$ K $>$}}
\index{Cast$<$ K $>$@{Cast$<$ K $>$}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Cast$<$ K $>$()}{Cast< K >()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}}$<$K$>$ \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.Cast$<$ K $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns a new \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} representing the current query sequence where each element is cast to a new type. 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em K} : {\em class}]\end{description}
\end{Desc}


Definition at line 178 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a411e47e60b7ae4d9df1d64f280feb617}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a411e47e60b7ae4d9df1d64f280feb617}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Deconstruct@{Deconstruct}}
\index{Deconstruct@{Deconstruct}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Deconstruct()}{Deconstruct()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.Deconstruct (\begin{DoxyParamCaption}\item[{out T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{out int}]{count }\end{DoxyParamCaption})}



Deconstructs this \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} into its base elements, the array and the count. The caller assumes ownership of the array and is responsible for managing its lifecycle. The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} cannot be used after this method is called. 



Definition at line 203 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a945832fdab8203804442a9d043ea55cf}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a945832fdab8203804442a9d043ea55cf}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Deconstruct@{Deconstruct}}
\index{Deconstruct@{Deconstruct}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Deconstruct()}{Deconstruct()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_query_slice}{Query\+Slice}} \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.Deconstruct (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Deconstructs this \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} into a simple \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_query_slice}{Query\+Slice}} construct. This is simply a utility overload of the regular Deconstruct method. The user is still responsible for managing the memory lifecycle of the returned slice. The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} cannot be used after this method is called. 



Definition at line 220 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a4c333e8a0bb14c3237fa65d2ad308c5a}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a4c333e8a0bb14c3237fa65d2ad308c5a}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!Dispose@{Dispose}}
\index{Dispose@{Dispose}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{Dispose()}{Dispose()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.Dispose (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Disposes of the resources that this query holds. The \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} cannot be used after this method is called. 



Definition at line 188 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a754dd1572406e8be39111c186daa1b74}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a754dd1572406e8be39111c186daa1b74}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!GetEnumerator@{GetEnumerator}}
\index{GetEnumerator@{GetEnumerator}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{GetEnumerator()}{GetEnumerator()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_1_1_enumerator}{Enumerator}} \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.Get\+Enumerator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 228 of file Query.\+cs.

\mbox{\Hypertarget{struct_leap_1_1_unity_1_1_query_1_1_query_a88411752d9806dc0364de025ac9b53b9}\label{struct_leap_1_1_unity_1_1_query_1_1_query_a88411752d9806dc0364de025ac9b53b9}} 
\index{Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}!OfType$<$ K $>$@{OfType$<$ K $>$}}
\index{OfType$<$ K $>$@{OfType$<$ K $>$}!Leap.Unity.Query.Query$<$ T $>$@{Leap.Unity.Query.Query$<$ T $>$}}
\subsubsection{\texorpdfstring{OfType$<$ K $>$()}{OfType< K >()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}}$<$K$>$ \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Leap.\+Unity.\+Query.\+Query}}$<$ T $>$.Of\+Type$<$ K $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns a new \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} representing only the items of the current \mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query}{Query}} that are of a specific type. 

For example (\char`\"{}\+A\char`\"{}, 1, null, 5.\+0f, 900, \char`\"{}hello\char`\"{}).\mbox{\hyperlink{struct_leap_1_1_unity_1_1_query_1_1_query_a045e15022385ac33bf7ea2448de59f93}{Query()}}.Of\+Type$<$string$>$() would result in (\char`\"{}\+A\char`\"{}, \char`\"{}hello\char`\"{}) \begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em K} : {\em T}]\end{description}
\end{Desc}


Definition at line 158 of file Query.\+cs.



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
O\+:/\+Git\+H\+U\+B\+M\+I\+N\+I\+P\+Roject/\+Assets/\+Leap\+Motion/\+Core/\+Scripts/\+Query/\mbox{\hyperlink{_query_8cs}{Query.\+cs}}\end{DoxyCompactItemize}
