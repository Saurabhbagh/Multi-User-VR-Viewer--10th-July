.TH "Leap.Unity.Pose" 3 "Sat Jul 20 2019" "Version https://github.com/Saurabhbagh/Multi-User-VR-Viewer--10th-July/" "Multi User Vr Viewer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Leap.Unity.Pose \- A position and rotation\&. You can multiply two poses; this acts like Matrix4x4 multiplication, but Poses always have unit scale\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits IEquatable< Pose >\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPose\fP (Vector3 \fBposition\fP)"
.br
.ti -1c
.RI "\fBPose\fP (Quaternion \fBrotation\fP)"
.br
.ti -1c
.RI "\fBPose\fP (Vector3 \fBposition\fP, Quaternion \fBrotation\fP)"
.br
.ti -1c
.RI "bool \fBApproxEquals\fP (\fBPose\fP other)"
.br
.ti -1c
.RI "override string \fBToString\fP ()"
.br
.ti -1c
.RI "string \fBToString\fP (string format)"
.br
.ti -1c
.RI "override bool \fBEquals\fP (object obj)"
.br
.ti -1c
.RI "bool \fBEquals\fP (\fBPose\fP other)"
.br
.ti -1c
.RI "override int \fBGetHashCode\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBPose\fP \fBoperator *\fP (\fBPose\fP A, \fBPose\fP B)"
.br
.RI "Returns \fBPose\fP B transformed by \fBPose\fP A, like a transform hierarchy with A as the parent of B\&. "
.ti -1c
.RI "static \fBPose\fP \fBoperator+\fP (\fBPose\fP A, \fBPose\fP B)"
.br
.RI "Returns the accumulation of the two poses: The positions summed, and with rotation A\&.rotation * B\&.rotation\&. Note that this accumulates the poses without interpreting either pose as a parent space of the other; but also beware that rotations are noncommutative, so this operation is also noncommutative\&. "
.ti -1c
.RI "static \fBPose\fP \fBoperator *\fP (\fBPose\fP pose, Vector3 localPosition)"
.br
.RI "Transforms the right-hand-side Vector3 as a local-space position into world space as if this \fBPose\fP were its reference frame\&. "
.ti -1c
.RI "static \fBPose\fP \fBLerp\fP (\fBPose\fP a, \fBPose\fP b, float t)"
.br
.RI "Returns a pose interpolated (Lerp for position, Slerp, NOT Lerp for rotation) between a and b by t from 0 to 1\&. This method clamps t between 0 and 1; if extrapolation is desired, see Extrapolate\&. "
.ti -1c
.RI "static \fBPose\fP \fBLerpUnclamped\fP (\fBPose\fP a, \fBPose\fP b, float t)"
.br
.RI "As Lerp, but doesn't clamp t between 0 and 1\&. Values above one extrapolate forwards beyond b, while values less than zero extrapolate backwards past a\&. "
.ti -1c
.RI "static \fBPose\fP \fBLerpUnclampedTimed\fP (\fBPose\fP a, float aTime, \fBPose\fP b, float bTime, float extrapolateTime)"
.br
.RI "As LerpUnclamped, but extrapolates using time values for a and b, and a target time at which to determine the extrapolated pose\&. "
.ti -1c
.RI "static bool \fBoperator==\fP (\fBPose\fP a, \fBPose\fP b)"
.br
.ti -1c
.RI "static bool \fBoperator !=\fP (\fBPose\fP a, \fBPose\fP b)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "Vector3 \fBposition\fP"
.br
.ti -1c
.RI "Quaternion \fBrotation\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static readonly \fBPose\fP \fBidentity\fP = new \fBPose\fP(Vector3\&.zero, Quaternion\&.identity)"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "\fBPose\fP \fBinverse\fP\fC [get]\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A position and rotation\&. You can multiply two poses; this acts like Matrix4x4 multiplication, but Poses always have unit scale\&. 


.PP
Definition at line 20 of file Pose\&.cs\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Leap\&.Unity\&.Pose\&.Pose (Vector3 position)"

.PP
Definition at line 25 of file Pose\&.cs\&.
.SS "Leap\&.Unity\&.Pose\&.Pose (Quaternion rotation)"

.PP
Definition at line 27 of file Pose\&.cs\&.
.SS "Leap\&.Unity\&.Pose\&.Pose (Vector3 position, Quaternion rotation)"

.PP
Definition at line 29 of file Pose\&.cs\&.
.SH "Member Function Documentation"
.PP 
.SS "bool Leap\&.Unity\&.Pose\&.ApproxEquals (\fBPose\fP other)"

.PP
Definition at line 72 of file Pose\&.cs\&.
.SS "override bool Leap\&.Unity\&.Pose\&.Equals (object obj)"

.PP
Definition at line 117 of file Pose\&.cs\&.
.SS "bool Leap\&.Unity\&.Pose\&.Equals (\fBPose\fP other)"

.PP
Definition at line 121 of file Pose\&.cs\&.
.SS "override int Leap\&.Unity\&.Pose\&.GetHashCode ()"

.PP
Definition at line 125 of file Pose\&.cs\&.
.SS "static \fBPose\fP Leap\&.Unity\&.Pose\&.Lerp (\fBPose\fP a, \fBPose\fP b, float t)\fC [static]\fP"

.PP
Returns a pose interpolated (Lerp for position, Slerp, NOT Lerp for rotation) between a and b by t from 0 to 1\&. This method clamps t between 0 and 1; if extrapolation is desired, see Extrapolate\&. 
.PP
Definition at line 81 of file Pose\&.cs\&.
.SS "static \fBPose\fP Leap\&.Unity\&.Pose\&.LerpUnclamped (\fBPose\fP a, \fBPose\fP b, float t)\fC [static]\fP"

.PP
As Lerp, but doesn't clamp t between 0 and 1\&. Values above one extrapolate forwards beyond b, while values less than zero extrapolate backwards past a\&. 
.PP
Definition at line 92 of file Pose\&.cs\&.
.SS "static \fBPose\fP Leap\&.Unity\&.Pose\&.LerpUnclampedTimed (\fBPose\fP a, float aTime, \fBPose\fP b, float bTime, float extrapolateTime)\fC [static]\fP"

.PP
As LerpUnclamped, but extrapolates using time values for a and b, and a target time at which to determine the extrapolated pose\&. 
.PP
Definition at line 101 of file Pose\&.cs\&.
.SS "static bool Leap\&.Unity\&.Pose\&.operator != (\fBPose\fP a, \fBPose\fP b)\fC [static]\fP"

.PP
Definition at line 136 of file Pose\&.cs\&.
.SS "static \fBPose\fP Leap\&.Unity\&.Pose\&.operator * (\fBPose\fP A, \fBPose\fP B)\fC [static]\fP"

.PP
Returns \fBPose\fP B transformed by \fBPose\fP A, like a transform hierarchy with A as the parent of B\&. 
.PP
Definition at line 47 of file Pose\&.cs\&.
.SS "static \fBPose\fP Leap\&.Unity\&.Pose\&.operator * (\fBPose\fP pose, Vector3 localPosition)\fC [static]\fP"

.PP
Transforms the right-hand-side Vector3 as a local-space position into world space as if this \fBPose\fP were its reference frame\&. 
.PP
Definition at line 67 of file Pose\&.cs\&.
.SS "static \fBPose\fP Leap\&.Unity\&.Pose\&.operator+ (\fBPose\fP A, \fBPose\fP B)\fC [static]\fP"

.PP
Returns the accumulation of the two poses: The positions summed, and with rotation A\&.rotation * B\&.rotation\&. Note that this accumulates the poses without interpreting either pose as a parent space of the other; but also beware that rotations are noncommutative, so this operation is also noncommutative\&. 
.PP
Definition at line 58 of file Pose\&.cs\&.
.SS "static bool Leap\&.Unity\&.Pose\&.operator== (\fBPose\fP a, \fBPose\fP b)\fC [static]\fP"

.PP
Definition at line 132 of file Pose\&.cs\&.
.SS "override string Leap\&.Unity\&.Pose\&.ToString ()"

.PP
Definition at line 107 of file Pose\&.cs\&.
.SS "string Leap\&.Unity\&.Pose\&.ToString (string format)"

.PP
Definition at line 112 of file Pose\&.cs\&.
.SH "Member Data Documentation"
.PP 
.SS "readonly \fBPose\fP Leap\&.Unity\&.Pose\&.identity = new \fBPose\fP(Vector3\&.zero, Quaternion\&.identity)\fC [static]\fP"

.PP
Definition at line 34 of file Pose\&.cs\&.
.SS "Vector3 Leap\&.Unity\&.Pose\&.position"

.PP
Definition at line 22 of file Pose\&.cs\&.
.SS "Quaternion Leap\&.Unity\&.Pose\&.rotation"

.PP
Definition at line 23 of file Pose\&.cs\&.
.SH "Property Documentation"
.PP 
.SS "\fBPose\fP Leap\&.Unity\&.Pose\&.inverse\fC [get]\fP"

.PP
Definition at line 36 of file Pose\&.cs\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Multi User Vr Viewer from the source code\&.
