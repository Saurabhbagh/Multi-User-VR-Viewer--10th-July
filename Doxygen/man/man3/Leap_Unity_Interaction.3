.TH "Leap.Unity.Interaction" 3 "Sat Jul 20 2019" "Version https://github.com/Saurabhbagh/Multi-User-VR-Viewer--10th-July/" "Multi User Vr Viewer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Leap.Unity.Interaction
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBExamples\fP"
.br
.ti -1c
.RI "namespace \fBInternal\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBActivityManager\fP"
.br
.RI "\fBActivityManager\fP is a wrapper around PhysX sphere queries for arbitrary \fBUnity\fP objects\&. 'Active' objects are objects found in the latest query\&. It's also possible to get the sets of objects that just began or stopped being active since the last query; this requires enabling the trackStateChanges setting\&. "
.ti -1c
.RI "class \fBAnchor\fP"
.br
.ti -1c
.RI "class \fBAnchorableBehaviour\fP"
.br
.RI "AnchorableBehaviours mix well with InteractionBehaviours you'd like to be able to pick up and place in specific locations, specified by other GameObjects with an \fBAnchor\fP component\&. "
.ti -1c
.RI "class \fBAnchorableBehaviourEditor\fP"
.br
.ti -1c
.RI "class \fBAnchorEditor\fP"
.br
.ti -1c
.RI "class \fBAnchorGroup\fP"
.br
.ti -1c
.RI "class \fBAnchorScoreTest\fP"
.br
.ti -1c
.RI "class \fBAnchorSet\fP"
.br
.ti -1c
.RI "class \fBContactBone\fP"
.br
.RI "Contact Bones store data for the colliders and rigidbodies in each bone of the contact-related representation of an \fBInteractionController\fP\&. They also notify the \fBInteractionController\fP of collisions for further processing\&. "
.ti -1c
.RI "class \fBContactBoneParent\fP"
.br
.ti -1c
.RI "class \fBContactBoneParentEditor\fP"
.br
.ti -1c
.RI "class \fBDefaultXRNodeTrackingProvider\fP"
.br
.RI "Implements IVRControllerTrackingProvider using Unity\&.XR\&.InputTracking for XRNodes\&. This tracking should support all native XR controller integrations in \fBUnity\fP, including Oculus Touch and HTC Vive\&. "
.ti -1c
.RI "class \fBExtensions\fP"
.br
.ti -1c
.RI "class \fBFromMatrixExtension\fP"
.br
.ti -1c
.RI "class \fBIgnoreColliderForInteractionEditor\fP"
.br
.ti -1c
.RI "interface \fBIGraspedMovementHandler\fP"
.br
.RI "An \fBIGraspedMovementHandler\fP takes in a target position and rotation (a 'pose', usually provided by an \fBIGraspedPoseHandler\fP) and is responsible for attempting to move an interaction object to that target pose\&. "
.ti -1c
.RI "interface \fBIGraspedPoseHandler\fP"
.br
.RI "An \fBIGraspedPoseHandler\fP specifies where an object grasped by a \fBLeap\fP hand or controller (or multiple hands/controllers) should move as the grasping controllers(s) move\&. The default implementation provided by the \fBInteraction\fP Engine is the \fBKabschGraspedPose\fP, which produces a physically-intuitive following motion for the object no matter how a grasping hand moves\&. "
.ti -1c
.RI "interface \fBIInteractionBehaviour\fP"
.br
.RI "\fBIInteractionBehaviour\fP is the interface that defines all \fBInteraction\fP objects, specifying the minimum set of functionality required to make objects interactable\&. "
.ti -1c
.RI "class \fBIInteractionBehaviourExtensions\fP"
.br
.ti -1c
.RI "interface \fBIInternalInteractionController\fP"
.br
.ti -1c
.RI "interface \fBIInternalInteractionManager\fP"
.br
.ti -1c
.RI "class \fBIInternalInteractionManagerExtensions\fP"
.br
.ti -1c
.RI "class \fBInteractionBehaviour\fP"
.br
.RI "InteractionBehaviours are components that enable GameObjects to interact with interaction controllers (InteractionControllerBase) in a physically intuitive way\&. "
.ti -1c
.RI "class \fBInteractionBehaviourEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionButton\fP"
.br
.RI "A physics-enabled button\&. Activated by physically pressing the button, with events for press and unpress\&. /summary> "
.ti -1c
.RI "class \fBInteractionButtonEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionController\fP"
.br
.ti -1c
.RI "class \fBInteractionControllerEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionControllerSet\fP"
.br
.ti -1c
.RI "class \fBInteractionHand\fP"
.br
.ti -1c
.RI "class \fBInteractionHandEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionManager\fP"
.br
.ti -1c
.RI "class \fBInteractionManagerEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionSlider\fP"
.br
.RI "A physics-enabled slider\&. Sliding is triggered by physically pushing the slider to its compressed position\&. Increasing the horizontal and vertical slide limits allows it to act as either a 1D or 2D slider\&. /summary> "
.ti -1c
.RI "class \fBInteractionSliderEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionToggle\fP"
.br
.RI "A physics-enabled toggle\&. Toggling is triggered by physically pushing the toggle to its compressed position\&. "
.ti -1c
.RI "class \fBInteractionVRControllerEditor\fP"
.br
.ti -1c
.RI "class \fBInteractionXRController\fP"
.br
.ti -1c
.RI "interface \fBIThrowHandler\fP"
.br
.RI "\fBInteraction\fP objects feed their throw handlers callbacks when they are held (for data collection) and then fire OnThrow when they are released from all grasping hands or controllers so that the throw handler can manipulate the interaction object's trajectory to better match the user's intention\&. "
.ti -1c
.RI "interface \fBIXRControllerTrackingProvider\fP"
.br
.RI "The interface for providing tracking data to an InteractionVRController\&. "
.ti -1c
.RI "class \fBKabschGraspedPose\fP"
.br
.RI "This pose handler is the default implementation of \fBIGraspedPoseHandler\fP provided by the \fBInteraction\fP Engine and is most likely the only implementation you will need\&. It uses a Kabsch solve from frame to frame based on the points at which any grasping controller are grasping the interaction object to determine where the object should move and rotate in the grasp\&. Note that IGraspedPoseHandlers only determine the target position and rotation of a held object; actually moving the object is the domain of an \fBIGraspedMovementHandler\fP\&. "
.ti -1c
.RI "class \fBKabschSolver\fP"
.br
.ti -1c
.RI "class \fBKinematicGraspedMovement\fP"
.br
.RI "This implementation of \fBIGraspedMovementHandler\fP moves its interaction object to a target position and rotation by setting its rigidbody position and rotation directly to that target position and rotation\&. This is required when working with kinematic rigidbodies, which do not move based on their velocity and angular velocity\&. "
.ti -1c
.RI "class \fBNonKinematicGraspedMovement\fP"
.br
.RI "This implementation of \fBIGraspedMovementHandler\fP moves an interaction object to its target position and rotation by setting its rigidbody's velocity and angular velocity such that it will reach the target position and rotation on the next physics update\&. "
.ti -1c
.RI "class \fBPhysicsCallbacks\fP"
.br
.ti -1c
.RI "class \fBSlidingWindowThrow\fP"
.br
.RI "The sliding window throw handler implements a simple heuristic that provides a reasonably accurate measure of the user's intended 'throw direction' for a physical object\&. It is used as the default implementation of an \fBInteraction\fP Behaviour's throw handler\&. "
.ti -1c
.RI "class \fBVector3Extensions\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBContactForceMode\fP { \fBContactForceMode\&.Object\fP, \fBContactForceMode\&.UI\fP }"
.br
.ti -1c
.RI "enum \fBIgnoreHoverMode\fP { \fBIgnoreHoverMode\&.None\fP, \fBIgnoreHoverMode\&.Left\fP, \fBIgnoreHoverMode\&.Right\fP, \fBIgnoreHoverMode\&.Both\fP }"
.br
.RI "Specified on a per-object basis to allow Interaction objects to ignore hover for the left hand, right hand, or both hands\&. "
.ti -1c
.RI "enum \fBControllerType\fP { \fBControllerType\&.Hand\fP, \fBControllerType\&.XRController\fP }"
.br
.RI "The Interaction Engine can be controlled by hands tracked by the \fBLeap\fP Motion Controller, or by remote-style held controllers such as the Oculus Touch or Vive controller\&. "
.ti -1c
.RI "enum \fBHandDataMode\fP { \fBHandDataMode\&.PlayerLeft\fP, \fBHandDataMode\&.PlayerRight\fP, \fBHandDataMode\&.Custom\fP }"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBLeap\&.Unity\&.Interaction\&.ContactForceMode\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIObject \fP\fP
.TP
\fB\fIUI \fP\fP
.PP
Definition at line 21 of file InteractionBehaviour\&.cs\&.
.SS "enum \fBLeap\&.Unity\&.Interaction\&.ControllerType\fP\fC [strong]\fP"

.PP
The \fBInteraction\fP Engine can be controlled by hands tracked by the \fBLeap\fP Motion \fBController\fP, or by remote-style held controllers such as the Oculus Touch or Vive controller\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIHand \fP\fP
.TP
\fB\fIXRController \fP\fP
.PP
Definition at line 36 of file InteractionController\&.cs\&.
.SS "enum \fBLeap\&.Unity\&.Interaction\&.HandDataMode\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPlayerLeft \fP\fP
.TP
\fB\fIPlayerRight \fP\fP
.TP
\fB\fICustom \fP\fP
.PP
Definition at line 23 of file InteractionHand\&.cs\&.
.SS "enum \fBLeap\&.Unity\&.Interaction\&.IgnoreHoverMode\fP\fC [strong]\fP"

.PP
Specified on a per-object basis to allow \fBInteraction\fP objects to ignore hover for the left hand, right hand, or both hands\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINone \fP\fP
.TP
\fB\fILeft \fP\fP
.TP
\fB\fIRight \fP\fP
.TP
\fB\fIBoth \fP\fP
.PP
Definition at line 29 of file InteractionController\&.cs\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Multi User Vr Viewer from the source code\&.
