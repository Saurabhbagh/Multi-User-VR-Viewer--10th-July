.TH "Leap.Controller" 3 "Sat Jul 20 2019" "Version https://github.com/Saurabhbagh/Multi-User-VR-Viewer--10th-July/" "Multi User Vr Viewer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Leap.Controller \- The \fBController\fP class is your main interface to the \fBLeap\fP Motion \fBController\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBLeap\&.IController\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBPolicyFlag\fP { \fBPolicyFlag\&.POLICY_DEFAULT\fP = 0, \fBPolicyFlag\&.POLICY_BACKGROUND_FRAMES\fP = (1 << 0), \fBPolicyFlag\&.POLICY_IMAGES\fP = (1 << 1), \fBPolicyFlag\&.POLICY_OPTIMIZE_HMD\fP = (1 << 2), \fBPolicyFlag\&.POLICY_ALLOW_PAUSE_RESUME\fP = (1 << 3), \fBPolicyFlag\&.POLICY_MAP_POINTS\fP = (1 << 7) }"
.br
.RI "The supported controller policies\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBDispose\fP ()"
.br
.ti -1c
.RI "\fBController\fP ()"
.br
.RI "Constructs a \fBController\fP object\&. "
.ti -1c
.RI "\fBController\fP (int connectionKey)"
.br
.RI "Constructs a \fBController\fP object using the specified connection key\&. "
.ti -1c
.RI "void \fBStartConnection\fP ()"
.br
.RI "Starts the connection\&. "
.ti -1c
.RI "void \fBStopConnection\fP ()"
.br
.RI "Stops the connection\&. "
.ti -1c
.RI "void \fBSetPolicy\fP (\fBPolicyFlag\fP policy)"
.br
.RI "Requests setting a policy\&. "
.ti -1c
.RI "void \fBClearPolicy\fP (\fBPolicyFlag\fP policy)"
.br
.RI "Requests clearing a policy\&. "
.ti -1c
.RI "bool \fBIsPolicySet\fP (\fBPolicyFlag\fP policy)"
.br
.RI "Gets the active setting for a specific policy\&. "
.ti -1c
.RI "\fBFrame\fP \fBFrame\fP (int history=0)"
.br
.RI "In most cases you should get \fBFrame\fP objects using the \fBLeapProvider\&.CurrentFrame\fP property\&. The data in \fBFrame\fP objects taken directly from a \fBLeap\&.Controller\fP instance is still in the \fBLeap\fP Motion frame of reference and will not match the hands displayed in a \fBUnity\fP scene\&. "
.ti -1c
.RI "void \fBFrame\fP (\fBFrame\fP toFill, int history=0)"
.br
.RI "Identical to Frame(history) but instead of constructing a new frame and returning it, the user provides a frame object to be filled with data instead\&. "
.ti -1c
.RI "long \fBFrameTimestamp\fP (int history=0)"
.br
.RI "Returns the timestamp of a recent tracking frame\&. Use the optional history parameter to specify how many frames in the past to retrieve the timestamp\&. Leave the history parameter as it's default value to return the timestamp of the most recent tracked frame\&. "
.ti -1c
.RI "\fBFrame\fP \fBGetTransformedFrame\fP (\fBLeapTransform\fP trs, int history=0)"
.br
.RI "Returns the frame object with all hands transformed by the specified transform matrix\&. "
.ti -1c
.RI "\fBFrame\fP \fBGetInterpolatedFrame\fP (Int64 time)"
.br
.RI "Returns the \fBFrame\fP at the specified time, interpolating the data between existing frames, if necessary\&. "
.ti -1c
.RI "void \fBGetInterpolatedFrame\fP (\fBFrame\fP toFill, Int64 time)"
.br
.RI "Fills the \fBFrame\fP with data taken at the specified time, interpolating the data between existing frames, if necessary\&. "
.ti -1c
.RI "\fBLEAP_HEAD_POSE_EVENT\fP \fBGetInterpolatedHeadPose\fP (Int64 time)"
.br
.RI "Returns the Head pose at the specified time, interpolating the data between existing frames, if necessary\&. "
.ti -1c
.RI "void \fBGetInterpolatedHeadPose\fP (ref \fBLEAP_HEAD_POSE_EVENT\fP toFill, Int64 time)"
.br
.ti -1c
.RI "void \fBTelemetryProfiling\fP (ref \fBLEAP_TELEMETRY_DATA\fP telemetryData)"
.br
.ti -1c
.RI "UInt64 \fBTelemetryGetNow\fP ()"
.br
.ti -1c
.RI "void \fBGetPointMapping\fP (ref \fBPointMapping\fP pointMapping)"
.br
.ti -1c
.RI "void \fBGetInterpolatedLeftRightTransform\fP (Int64 time, Int64 sourceTime, int leftId, int rightId, out \fBLeapTransform\fP leftTransform, out \fBLeapTransform\fP rightTransform)"
.br
.RI "This is a special variant of GetInterpolatedFrameFromTime, for use with special features that only require the position and orientation of the palm positions, and do not care about pose data or any other data\&. "
.ti -1c
.RI "void \fBGetInterpolatedFrameFromTime\fP (\fBFrame\fP toFill, Int64 time, Int64 sourceTime)"
.br
.ti -1c
.RI "long \fBNow\fP ()"
.br
.RI "Returns a timestamp value as close as possible to the current time\&. Values are in microseconds, as with all the other timestamp values\&. "
.ti -1c
.RI "\fBFailedDeviceList\fP \fBFailedDevices\fP ()"
.br
.RI "A list of any \fBLeap\fP Motion hardware devices that are physically connected to the client computer, but are not functioning correctly\&. The list contains \fBFailedDevice\fP objects containing the pnpID and the reason for failure\&. No other device information is available\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBDispose\fP (bool disposing)"
.br
.ti -1c
.RI "virtual void \fBOnInit\fP (object sender, \fBLeapEventArgs\fP eventArgs)"
.br
.ti -1c
.RI "virtual void \fBOnConnect\fP (object sender, \fBConnectionEventArgs\fP eventArgs)"
.br
.ti -1c
.RI "virtual void \fBOnDisconnect\fP (object sender, \fBConnectionLostEventArgs\fP eventArgs)"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "SynchronizationContext \fBEventContext\fP\fC [get, set]\fP"
.br
.RI "The SynchronizationContext used for dispatching events\&. "
.ti -1c
.RI "EventHandler< \fBLeapEventArgs\fP > \fBInit\fP"
.br
.RI "Dispatched when the connection is initialized (but not necessarily connected)\&. "
.ti -1c
.RI "EventHandler< \fBConnectionEventArgs\fP > \fBConnect\fP"
.br
.RI "Dispatched when the connection to the service is established\&. "
.ti -1c
.RI "EventHandler< \fBConnectionLostEventArgs\fP > \fBDisconnect\fP"
.br
.RI "Dispatched if the connection to the service is lost\&. "
.ti -1c
.RI "EventHandler< \fBFrameEventArgs\fP > \fBFrameReady\fP"
.br
.RI "Dispatched when a tracking frame is ready\&. "
.ti -1c
.RI "EventHandler< \fBInternalFrameEventArgs\fP > \fBInternalFrameReady\fP"
.br
.RI "Dispatched when an internal tracking frame is ready\&. "
.ti -1c
.RI "EventHandler< \fBDeviceEventArgs\fP > \fBDevice\fP"
.br
.RI "Dispatched when a \fBLeap\fP Motion device is connected\&. "
.ti -1c
.RI "EventHandler< \fBDeviceEventArgs\fP > \fBDeviceLost\fP"
.br
.RI "Dispatched when a \fBLeap\fP Motion device is disconnected\&. "
.ti -1c
.RI "EventHandler< \fBDeviceFailureEventArgs\fP > \fBDeviceFailure\fP"
.br
.RI "Dispatched when a \fBLeap\fP device fails to initialize\&. "
.ti -1c
.RI "EventHandler< \fBLogEventArgs\fP > \fBLogMessage\fP"
.br
.RI "Dispatched when the system generates a loggable event\&. "
.ti -1c
.RI "EventHandler< \fBPolicyEventArgs\fP > \fBPolicyChange\fP"
.br
.RI "Dispatched when a policy changes\&. "
.ti -1c
.RI "EventHandler< \fBConfigChangeEventArgs\fP > \fBConfigChange\fP"
.br
.RI "Dispatched when a configuration setting changes\&. "
.ti -1c
.RI "EventHandler< \fBDistortionEventArgs\fP > \fBDistortionChange\fP"
.br
.RI "Dispatched when the image distortion map changes\&. The distortion map can change when the \fBLeap\fP device switches orientation, or a new device becomes active\&. "
.ti -1c
.RI "EventHandler< \fBDroppedFrameEventArgs\fP > \fBDroppedFrame\fP"
.br
.RI "Dispatched when the service drops a tracking frame\&. "
.ti -1c
.RI "EventHandler< \fBImageEventArgs\fP > \fBImageReady\fP"
.br
.RI "Dispatched when an unrequested image is ready\&. "
.ti -1c
.RI "Action< \fBBeginProfilingForThreadArgs\fP > \fBBeginProfilingForThread\fP"
.br
.RI "Dispatched whenever a thread wants to start profiling for a custom thread\&. The event is always dispatched from the thread itself\&. "
.ti -1c
.RI "Action< \fBEndProfilingForThreadArgs\fP > \fBEndProfilingForThread\fP"
.br
.RI "Dispatched whenever a thread is finished profiling\&. The event is always dispatched from the thread itself\&. "
.ti -1c
.RI "Action< \fBBeginProfilingBlockArgs\fP > \fBBeginProfilingBlock\fP"
.br
.RI "Dispatched whenever a thread enters a profiling block\&. The event is always dispatched from the thread itself\&. "
.ti -1c
.RI "Action< \fBEndProfilingBlockArgs\fP > \fBEndProfilingBlock\fP"
.br
.RI "Dispatched whenever a thread ends a profiling block\&. The event is always dispatched from the thread itself\&. "
.ti -1c
.RI "EventHandler< \fBPointMappingChangeEventArgs\fP > \fBPointMappingChange\fP"
.br
.RI "Dispatched when point mapping change events are generated by the service\&. "
.ti -1c
.RI "EventHandler< \fBHeadPoseEventArgs\fP > \fBHeadPoseChange\fP"
.br
.RI "Dispatched when a new HeadPose is available\&. "
.ti -1c
.RI "bool \fBIsServiceConnected\fP\fC [get]\fP"
.br
.RI "Reports whether your application has a connection to the \fBLeap\fP Motion daemon/service\&. Can be true even if the \fBLeap\fP Motion hardware is not available\&. "
.ti -1c
.RI "bool \fBIsConnected\fP\fC [get]\fP"
.br
.RI "Reports whether this \fBController\fP is connected to the \fBLeap\fP Motion service and the \fBLeap\fP Motion hardware is plugged in\&. "
.ti -1c
.RI "\fBConfig\fP \fBConfig\fP\fC [get]\fP"
.br
.RI "Returns a \fBConfig\fP object, which you can use to query the \fBLeap\fP Motion system for configuration information\&. "
.ti -1c
.RI "\fBDeviceList\fP \fBDevices\fP\fC [get]\fP"
.br
.RI "The list of currently attached and recognized \fBLeap\fP Motion controller devices\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBController\fP class is your main interface to the \fBLeap\fP Motion \fBController\fP\&. 

Create an instance of this \fBController\fP class to access frames of tracking data and configuration information\&.Frame data can be polled at any time using the \fBController\&.Frame()\fP function\&.Call frame() or frame(0) to get the most recent frame\&.Set the history parameter to a positive integer to access previous frames\&.A controller stores up to 60 frames in its frame history\&.
.PP
Polling is an appropriate strategy for applications which already have an intrinsic update loop, such as a game\&. You can also subscribe to the FrameReady event to get tracking frames through an event delegate\&.
.PP
If the current thread implements a SynchronizationContext that contains a message loop, events are posted to that threads message loop\&. Otherwise, events are called on an independent thread and applications must perform any needed synchronization or marshalling of data between threads\&. Note that Unity3D does not create an appropriate SynchronizationContext object\&. Typically, event handlers cannot access any \fBUnity\fP objects\&.
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
Definition at line 39 of file Controller\&.cs\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBLeap\&.Controller\&.PolicyFlag\fP\fC [strong]\fP"

.PP
The supported controller policies\&. The supported policy flags are:
.PP
\fBPOLICY_BACKGROUND_FRAMES\fP -- requests that your application receives frames when it is not the foreground application for user input\&.
.PP
The background frames policy determines whether an application receives frames of tracking data while in the background\&. By default, the \fBLeap\fP Motion software only sends tracking data to the foreground application\&. Only applications that need this ability should request the background frames policy\&. The 'Allow Background Apps' checkbox must be enabled in the \fBLeap\fP Motion Control Panel or this policy will be denied\&.
.PP
\fBPOLICY_OPTIMIZE_HMD\fP -- request that the tracking be optimized for head-mounted tracking\&.
.PP
The optimize HMD policy improves tracking in situations where the \fBLeap\fP Motion hardware is attached to a head-mounted display\&. This policy is not granted for devices that cannot be mounted to an HMD, such as \fBLeap\fP Motion controllers embedded in a laptop or keyboard\&.
.PP
Some policies can be denied if the user has disabled the feature on their \fBLeap\fP Motion control panel\&.
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPOLICY_DEFAULT \fP\fP
The default policy\&. 
.TP
\fB\fIPOLICY_BACKGROUND_FRAMES \fP\fP
Receive background frames\&. 
.TP
\fB\fIPOLICY_IMAGES \fP\fP
Allow streaming images\&. 
.TP
\fB\fIPOLICY_OPTIMIZE_HMD \fP\fP
Optimize the tracking for head-mounted device\&. 
.TP
\fB\fIPOLICY_ALLOW_PAUSE_RESUME \fP\fP
Allow pausing and unpausing of the \fBLeap\fP Motion service\&. 
.TP
\fB\fIPOLICY_MAP_POINTS \fP\fP
Allow streaming map point 
.PP
Definition at line 690 of file Controller\&.cs\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Leap\&.Controller\&.Controller ()"

.PP
Constructs a \fBController\fP object\&. The default constructor uses a connection key of 0\&.
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
Definition at line 364 of file Controller\&.cs\&.
.SS "Leap\&.Controller\&.Controller (int connectionKey)"

.PP
Constructs a \fBController\fP object using the specified connection key\&. All controller instances using the same key will use the same connection to the service\&. In general, an application should not use more than one connection for all its controllers\&. Each connection keeps its own cache of frames and images\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnectionKey\fP An identifier specifying the connection to use\&. If a connection with the specified key already exists, that connection is used\&. Otherwise, a new connection is created\&. 
.RE
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 378 of file Controller\&.cs\&.
.SH "Member Function Documentation"
.PP 
.SS "void Leap\&.Controller\&.ClearPolicy (\fBPolicyFlag\fP policy)"

.PP
Requests clearing a policy\&. Policy changes are completed asynchronously and, because they are subject to user approval or system compatibility checks, may not complete successfully\&. Call \fBController\&.IsPolicySet()\fP after a suitable interval to test whether the change was accepted\&. 
.PP
\fBSince:\fP
.RS 4
2\&.1\&.6 
.RE
.PP

.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 450 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.Dispose ()"

.PP
Definition at line 343 of file Controller\&.cs\&.
.SS "virtual void Leap\&.Controller\&.Dispose (bool disposing)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 349 of file Controller\&.cs\&.
.SS "\fBFailedDeviceList\fP Leap\&.Controller\&.FailedDevices ()"

.PP
A list of any \fBLeap\fP Motion hardware devices that are physically connected to the client computer, but are not functioning correctly\&. The list contains \fBFailedDevice\fP objects containing the pnpID and the reason for failure\&. No other device information is available\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 658 of file Controller\&.cs\&.
.SS "\fBFrame\fP Leap\&.Controller\&.Frame (int history = \fC0\fP)"

.PP
In most cases you should get \fBFrame\fP objects using the \fBLeapProvider\&.CurrentFrame\fP property\&. The data in \fBFrame\fP objects taken directly from a \fBLeap\&.Controller\fP instance is still in the \fBLeap\fP Motion frame of reference and will not match the hands displayed in a \fBUnity\fP scene\&. Returns a frame of tracking data from the \fBLeap\fP Motion software\&. Use the optional history parameter to specify which frame to retrieve\&. Call frame() or frame(0) to access the most recent frame; call frame(1) to access the previous frame, and so on\&. If you use a history value greater than the number of stored frames, then the controller returns an empty frame\&.
.PP
\fBParameters:\fP
.RS 4
\fIhistory\fP The age of the frame to return, counting backwards from the most recent frame (0) into the past and up to the maximum age (59)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The specified frame; or, if no history parameter is specified, the newest frame\&. If a frame is not available at the specified history position, an invalid \fBFrame\fP is returned\&. 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 491 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.Frame (\fBFrame\fP toFill, int history = \fC0\fP)"

.PP
Identical to Frame(history) but instead of constructing a new frame and returning it, the user provides a frame object to be filled with data instead\&. 
.PP
Definition at line 501 of file Controller\&.cs\&.
.SS "long Leap\&.Controller\&.FrameTimestamp (int history = \fC0\fP)"

.PP
Returns the timestamp of a recent tracking frame\&. Use the optional history parameter to specify how many frames in the past to retrieve the timestamp\&. Leave the history parameter as it's default value to return the timestamp of the most recent tracked frame\&. 
.PP
Definition at line 514 of file Controller\&.cs\&.
.SS "\fBFrame\fP Leap\&.Controller\&.GetInterpolatedFrame (Int64 time)"

.PP
Returns the \fBFrame\fP at the specified time, interpolating the data between existing frames, if necessary\&. 
.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 531 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.GetInterpolatedFrame (\fBFrame\fP toFill, Int64 time)"

.PP
Fills the \fBFrame\fP with data taken at the specified time, interpolating the data between existing frames, if necessary\&. 
.PP
Definition at line 538 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.GetInterpolatedFrameFromTime (\fBFrame\fP toFill, Int64 time, Int64 sourceTime)"

.PP
Definition at line 583 of file Controller\&.cs\&.
.SS "\fBLEAP_HEAD_POSE_EVENT\fP Leap\&.Controller\&.GetInterpolatedHeadPose (Int64 time)"

.PP
Returns the Head pose at the specified time, interpolating the data between existing frames, if necessary\&. 
.PP
Definition at line 545 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.GetInterpolatedHeadPose (ref \fBLEAP_HEAD_POSE_EVENT\fP toFill, Int64 time)"

.PP
Definition at line 549 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.GetInterpolatedLeftRightTransform (Int64 time, Int64 sourceTime, int leftId, int rightId, out \fBLeapTransform\fP leftTransform, out \fBLeapTransform\fP rightTransform)"

.PP
This is a special variant of GetInterpolatedFrameFromTime, for use with special features that only require the position and orientation of the palm positions, and do not care about pose data or any other data\&. You must specify the id of the hand that you wish to get a transform for\&. If you specify an id that is not present in the interpolated frame, the output transform will be the identity transform\&. 
.PP
Definition at line 574 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.GetPointMapping (ref \fBPointMapping\fP pointMapping)"

.PP
Definition at line 561 of file Controller\&.cs\&.
.SS "\fBFrame\fP Leap\&.Controller\&.GetTransformedFrame (\fBLeapTransform\fP trs, int history = \fC0\fP)"

.PP
Returns the frame object with all hands transformed by the specified transform matrix\&. 
.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 524 of file Controller\&.cs\&.
.SS "bool Leap\&.Controller\&.IsPolicySet (\fBPolicyFlag\fP policy)"

.PP
Gets the active setting for a specific policy\&. Keep in mind that setting a policy flag is asynchronous, so changes are not effective immediately after calling setPolicyFlag()\&. In addition, a policy request can be declined by the user\&. You should always set the policy flags required by your application at startup and check that the policy change request was successful after an appropriate interval\&.
.PP
If the controller object is not connected to the \fBLeap\fP Motion software, then the default state for the selected policy is returned\&.
.PP
\fBSince:\fP
.RS 4
2\&.1\&.6 
.RE
.PP

.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 468 of file Controller\&.cs\&.
.SS "long Leap\&.Controller\&.Now ()"

.PP
Returns a timestamp value as close as possible to the current time\&. Values are in microseconds, as with all the other timestamp values\&. 
.PP
\fBSince:\fP
.RS 4
2\&.2\&.7 
.RE
.PP

.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 593 of file Controller\&.cs\&.
.SS "virtual void Leap\&.Controller\&.OnConnect (object sender, \fBConnectionEventArgs\fP eventArgs)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 721 of file Controller\&.cs\&.
.SS "virtual void Leap\&.Controller\&.OnDisconnect (object sender, \fBConnectionLostEventArgs\fP eventArgs)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 725 of file Controller\&.cs\&.
.SS "virtual void Leap\&.Controller\&.OnInit (object sender, \fBLeapEventArgs\fP eventArgs)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 717 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.SetPolicy (\fBPolicyFlag\fP policy)"

.PP
Requests setting a policy\&. A request to change a policy is subject to user approval and a policy can be changed by the user at any time (using the \fBLeap\fP Motion settings dialog)\&. The desired policy flags must be set every time an application runs\&.
.PP
Policy changes are completed asynchronously and, because they are subject to user approval or system compatibility checks, may not complete successfully\&. Call \fBController\&.IsPolicySet()\fP after a suitable interval to test whether the change was accepted\&. 
.PP
\fBSince:\fP
.RS 4
2\&.1\&.6 
.RE
.PP

.PP
Implements \fBLeap\&.IController\fP\&.
.PP
Definition at line 437 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.StartConnection ()"

.PP
Starts the connection\&. A connection starts automatically when created, but you can use this function to restart the connection after stopping it\&.
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 397 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.StopConnection ()"

.PP
Stops the connection\&. No more frames or other events are received from a stopped connection\&. You can restart with \fBStartConnection()\fP\&.
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 409 of file Controller\&.cs\&.
.SS "UInt64 Leap\&.Controller\&.TelemetryGetNow ()"

.PP
Definition at line 557 of file Controller\&.cs\&.
.SS "void Leap\&.Controller\&.TelemetryProfiling (ref \fBLEAP_TELEMETRY_DATA\fP telemetryData)"

.PP
Definition at line 553 of file Controller\&.cs\&.
.SH "Property Documentation"
.PP 
.SS "Action<\fBBeginProfilingBlockArgs\fP> Leap\&.Controller\&.BeginProfilingBlock\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched whenever a thread enters a profiling block\&. The event is always dispatched from the thread itself\&. The event data will contain the name of the profiling block\&.
.PP
\fBSince:\fP
.RS 4
4\&.0 
.RE
.PP

.PP
Definition at line 292 of file Controller\&.cs\&.
.SS "Action<\fBBeginProfilingForThreadArgs\fP> Leap\&.Controller\&.BeginProfilingForThread\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched whenever a thread wants to start profiling for a custom thread\&. The event is always dispatched from the thread itself\&. The event data will contain the name of the thread, as well as an array of all possible profiling blocks that could be entered on that thread\&.
.PP
\fBSince:\fP
.RS 4
4\&.0 
.RE
.PP

.PP
Definition at line 260 of file Controller\&.cs\&.
.SS "\fBConfig\fP Leap\&.Controller\&.Config\fC [get]\fP"

.PP
Returns a \fBConfig\fP object, which you can use to query the \fBLeap\fP Motion system for configuration information\&. 
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
Definition at line 624 of file Controller\&.cs\&.
.SS "EventHandler<\fBConfigChangeEventArgs\fP> Leap\&.Controller\&.ConfigChange\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a configuration setting changes\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 202 of file Controller\&.cs\&.
.SS "EventHandler<\fBConnectionEventArgs\fP> Leap\&.Controller\&.Connect\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when the connection to the service is established\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 82 of file Controller\&.cs\&.
.SS "EventHandler<\fBDeviceEventArgs\fP> Leap\&.Controller\&.Device\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a \fBLeap\fP Motion device is connected\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 137 of file Controller\&.cs\&.
.SS "EventHandler<\fBDeviceFailureEventArgs\fP> Leap\&.Controller\&.DeviceFailure\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a \fBLeap\fP device fails to initialize\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 163 of file Controller\&.cs\&.
.SS "EventHandler<\fBDeviceEventArgs\fP> Leap\&.Controller\&.DeviceLost\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a \fBLeap\fP Motion device is disconnected\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 150 of file Controller\&.cs\&.
.SS "\fBDeviceList\fP Leap\&.Controller\&.Devices\fC [get]\fP"

.PP
The list of currently attached and recognized \fBLeap\fP Motion controller devices\&. The \fBDevice\fP objects in the list describe information such as the range and tracking volume\&.
.PP
Currently, the \fBLeap\fP Motion \fBController\fP only allows a single active device at a time, however there may be multiple devices physically attached and listed here\&. Any active device(s) are guaranteed to be listed first, however order is not determined beyond that\&.
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
Definition at line 644 of file Controller\&.cs\&.
.SS "EventHandler<\fBConnectionLostEventArgs\fP> Leap\&.Controller\&.Disconnect\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched if the connection to the service is lost\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 98 of file Controller\&.cs\&.
.SS "EventHandler<\fBDistortionEventArgs\fP> Leap\&.Controller\&.DistortionChange\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when the image distortion map changes\&. The distortion map can change when the \fBLeap\fP device switches orientation, or a new device becomes active\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 217 of file Controller\&.cs\&.
.SS "EventHandler<\fBDroppedFrameEventArgs\fP> Leap\&.Controller\&.DroppedFrame\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when the service drops a tracking frame\&. 
.PP
Definition at line 229 of file Controller\&.cs\&.
.SS "Action<\fBEndProfilingBlockArgs\fP> Leap\&.Controller\&.EndProfilingBlock\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched whenever a thread ends a profiling block\&. The event is always dispatched from the thread itself\&. The event data will contain the name of the profiling block\&.
.PP
\fBSince:\fP
.RS 4
4\&.0 
.RE
.PP

.PP
Definition at line 309 of file Controller\&.cs\&.
.SS "Action<\fBEndProfilingForThreadArgs\fP> Leap\&.Controller\&.EndProfilingForThread\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched whenever a thread is finished profiling\&. The event is always dispatched from the thread itself\&. 
.PP
\fBSince:\fP
.RS 4
4\&.0 
.RE
.PP

.PP
Definition at line 275 of file Controller\&.cs\&.
.SS "SynchronizationContext Leap\&.Controller\&.EventContext\fC [get]\fP, \fC [set]\fP"

.PP
The SynchronizationContext used for dispatching events\&. By default the synchronization context of the thread creating the controller instance is used\&. You can change the context if desired\&. 
.PP
Definition at line 51 of file Controller\&.cs\&.
.SS "EventHandler<\fBFrameEventArgs\fP> Leap\&.Controller\&.FrameReady\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a tracking frame is ready\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 111 of file Controller\&.cs\&.
.SS "EventHandler<\fBHeadPoseEventArgs\fP> Leap\&.Controller\&.HeadPoseChange\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a new HeadPose is available\&. 
.PP
Definition at line 334 of file Controller\&.cs\&.
.SS "EventHandler<\fBImageEventArgs\fP> Leap\&.Controller\&.ImageReady\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when an unrequested image is ready\&. 
.PP
\fBSince:\fP
.RS 4
4\&.0 
.RE
.PP

.PP
Definition at line 242 of file Controller\&.cs\&.
.SS "EventHandler<\fBLeapEventArgs\fP> Leap\&.Controller\&.Init\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when the connection is initialized (but not necessarily connected)\&. Can be dispatched more than once, if connection is restarted\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 66 of file Controller\&.cs\&.
.SS "EventHandler<\fBInternalFrameEventArgs\fP> Leap\&.Controller\&.InternalFrameReady\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when an internal tracking frame is ready\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 124 of file Controller\&.cs\&.
.SS "bool Leap\&.Controller\&.IsConnected\fC [get]\fP"

.PP
Reports whether this \fBController\fP is connected to the \fBLeap\fP Motion service and the \fBLeap\fP Motion hardware is plugged in\&. When you first create a \fBController\fP object, isConnected() returns false\&. After the controller finishes initializing and connects to the \fBLeap\fP Motion software and if the \fBLeap\fP Motion hardware is plugged in, isConnected() returns true\&.
.PP
You can either handle the onConnect event using a Listener instance or poll the isConnected() function if you need to wait for your application to be connected to the \fBLeap\fP Motion software before performing some other operation\&.
.PP
\fBSince:\fP
.RS 4
1\&.0 
.RE
.PP

.PP
Definition at line 612 of file Controller\&.cs\&.
.SS "bool Leap\&.Controller\&.IsServiceConnected\fC [get]\fP"

.PP
Reports whether your application has a connection to the \fBLeap\fP Motion daemon/service\&. Can be true even if the \fBLeap\fP Motion hardware is not available\&. 
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.PP
Definition at line 418 of file Controller\&.cs\&.
.SS "EventHandler<\fBLogEventArgs\fP> Leap\&.Controller\&.LogMessage\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when the system generates a loggable event\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 176 of file Controller\&.cs\&.
.SS "EventHandler<\fBPointMappingChangeEventArgs\fP> Leap\&.Controller\&.PointMappingChange\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when point mapping change events are generated by the service\&. 
.PP
\fBSince:\fP
.RS 4
4\&.0 
.RE
.PP

.PP
Definition at line 322 of file Controller\&.cs\&.
.SS "EventHandler<\fBPolicyEventArgs\fP> Leap\&.Controller\&.PolicyChange\fC [add]\fP, \fC [remove]\fP"

.PP
Dispatched when a policy changes\&. 
.PP
\fBSince:\fP
.RS 4
3\&.0 
.RE
.PP

.PP
Definition at line 189 of file Controller\&.cs\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Multi User Vr Viewer from the source code\&.
