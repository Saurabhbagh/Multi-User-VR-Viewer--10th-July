.TH "Leap.Unity.Interaction.InteractionXRController" 3 "Sat Jul 20 2019" "Version https://github.com/Saurabhbagh/Multi-User-VR-Viewer--10th-July/" "Multi User Vr Viewer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Leap.Unity.Interaction.InteractionXRController
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBRefreshControllerConnection\fP ()"
.br
.ti -1c
.RI "override Vector3 \fBGetGraspPoint\fP ()"
.br
.RI "Returns approximately where the controller is grasping the currently grasped \fBInteractionBehaviour\fP\&. This method will print an error if the controller is not currently grasping an object\&. "
.ti -1c
.RI "override void \fBOnDrawRuntimeGizmos\fP (\fBRuntimeGizmos\&.RuntimeGizmoDrawer\fP drawer)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "float \fBpollConnectionInterval\fP = 2f"
.br
.ti -1c
.RI "new List< Transform > \fBprimaryHoverPoints\fP"
.br
.ti -1c
.RI "Transform \fBgraspPoint\fP"
.br
.ti -1c
.RI "float \fBmaxGraspDistance\fP = 0\&.06F"
.br
.ti -1c
.RI "string \fBgraspButtonAxis\fP"
.br
.ti -1c
.RI "float \fBgraspTimingSlop\fP = 0\&.10F"
.br
.ti -1c
.RI "Func< float > \fBgraspAxisOverride\fP = null"
.br
.RI "By default, InteractionVRController uses Input\&.GetAxis(graspButtonAxis) to determine the 'depression' state for the grasp button\&. By setting this value to something other than null, it is possible to modify this behavior to instead retrieve a grasping axis value based on arbitrary code\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "override void \fBReset\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnValidate\fP ()"
.br
.ti -1c
.RI "override void \fBStart\fP ()"
.br
.ti -1c
.RI "override void \fBfixedUpdateController\fP ()"
.br
.RI "Called just before the \fBInteractionController\fP proceeds with its usual FixedUpdate\&. "
.ti -1c
.RI "override void \fBonObjectUnregistered\fP (\fBIInteractionBehaviour\fP intObj)"
.br
.RI "InteractionVRController doesn't need to do anything when an object is unregistered\&. "
.ti -1c
.RI "override void \fBunwarpColliders\fP (Transform primaryHoverPoint, \fBISpaceComponent\fP warpedSpaceElement)"
.br
.RI "Implementing this method is necessary to support curved spaces as rendered by a \fBLeap\fP Graphic Renderer\&. See \fBInteractionHand\fP for an example implementation\&. (Implementing this method is optional if you are not using a curved space as rendered by a \fBLeap\fP Graphic Renderer\&.) "
.ti -1c
.RI "override bool \fBinitContact\fP ()"
.br
.RI "Called to initialize contact colliders\&. See remarks for implementation requirements\&. "
.ti -1c
.RI "override void \fBgetColliderBoneTargetPositionRotation\fP (int contactBoneIndex, out Vector3 targetPosition, out Quaternion targetRotation)"
.br
.RI "If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array\&. (For example, by recording the local position and local rotation of each contact bone in \fBinitContact()\fP)\&. More complex controllers, such as \fBInteractionHand\fP, uses this method to set \fBContactBone\fP target positions and rotations based on the tracked \fBLeap\fP hand\&. "
.ti -1c
.RI "override void \fBfixedUpdateGraspingState\fP ()"
.br
.RI "Called every fixed frame if grasping is enabled in the \fBInteraction\fP Manager\&. "
.ti -1c
.RI "override bool \fBcheckShouldGrasp\fP (out \fBIInteractionBehaviour\fP objectToGrasp)"
.br
.RI "Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp\&. "
.ti -1c
.RI "override bool \fBcheckShouldGraspAtemporal\fP (\fBIInteractionBehaviour\fP intObj)"
.br
.RI "If the provided object is within range of this VR controller's grasp point and the grasp button is currently held down, this method will manually initiate a grasp and return true\&. Otherwise, the method returns false\&. "
.ti -1c
.RI "override bool \fBcheckShouldRelease\fP (out \fBIInteractionBehaviour\fP objectToRelease)"
.br
.RI "Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release\&. "
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "bool \fBisUsingCustomTracking\fP\fC [get]\fP"
.br
.ti -1c
.RI "string \fBdeviceJoystickTokens\fP\fC [get]\fP"
.br
.ti -1c
.RI "\fBChirality\fP \fBchirality\fP\fC [get]\fP"
.br
.ti -1c
.RI "bool \fBpollConnection\fP\fC [get, set]\fP"
.br
.RI "Whether to continuously poll attached joystick data for a joystick that matches the device joystick tokens, using Input\&.GetJoystickNames()\&. This call allocates garbage, so be wary of setting a low polling interval\&. "
.ti -1c
.RI "List< GameObject > \fBenableObjectsOnlyWhenTracked\fP\fC [get]\fP"
.br
.RI "These objects will be made active only while the controller is tracked\&. For more fine-tuned behavior, we recommend implementing your own logic\&. "
.ti -1c
.RI "bool \fBisJoystickDetected\fP\fC [get]\fP"
.br
.RI "Whether the device joystick tokens matched an entry in Input\&.GetJoystickNames()\&. If pollConnection is set to true, this status is refreshed periodically based on the pollConnectionInterval, but only while the joystick tokens have not been detected from Input\&.GetJoystickNames()\&. Call \fBRefreshControllerConnection()\fP to detect if the controller has been disconnected\&. "
.ti -1c
.RI "\fBIXRControllerTrackingProvider\fP \fBtrackingProvider\fP\fC [get, set]\fP"
.br
.ti -1c
.RI "override bool \fBisTracked\fP\fC [get]\fP"
.br
.RI "Gets whether or not the underlying controller is currently tracked and any joystick token filtering has confirmed that this controller has been detected as a connected joystick\&. "
.ti -1c
.RI "override bool \fBisBeingMoved\fP\fC [get]\fP"
.br
.RI "Gets whether or not the underlying controller is currently being moved in world space, but relative to the \fBInteraction\fP Manager's transform\&. The \fBInteraction\fP Manager is usually a sibling of the main camera beneath the camera rig transform, so that if your application is only translating the player rig in space, this method won't incorrectly return true\&. "
.ti -1c
.RI "VRNode? \fBxrNode\fP\fC [get]\fP"
.br
.RI "Gets the XRNode associated with this XR controller\&. Note: If the tracking mode for this controller is specified as \fBControllerTrackingMode\&.Custom\fP, this value may be ignored\&. "
.ti -1c
.RI "override bool \fBisLeft\fP\fC [get]\fP"
.br
.RI "Gets whether the controller is a left-hand controller\&. "
.ti -1c
.RI "override Vector3 \fBposition\fP\fC [get]\fP"
.br
.RI "Gets the last-tracked position of the controller\&. "
.ti -1c
.RI "override Quaternion \fBrotation\fP\fC [get]\fP"
.br
.RI "Gets the last-tracked rotation of the controller\&. "
.ti -1c
.RI "override Vector3 \fBvelocity\fP\fC [get]\fP"
.br
.RI "Gets the current velocity of the controller\&. "
.ti -1c
.RI "override \fBControllerType\fP \fBcontrollerType\fP\fC [get]\fP"
.br
.RI "Gets the type of controller this is\&. For InteractionVRController, the type is always ControllerType\&.VRController\&. "
.ti -1c
.RI "override \fBInteractionHand\fP \fBintHand\fP\fC [get]\fP"
.br
.RI "This implementation of InteractionControllerBase does not represent a \fBLeap\fP hand, so it need not return an \fBInteractionHand\fP object\&. "
.ti -1c
.RI "override Vector3? \fBhoverPoint\fP\fC [get]\fP"
.br
.RI "Gets the center point used for hover distance checking\&. "
.ti -1c
.RI "override List< Transform > \fB_primaryHoverPoints\fP\fC [get]\fP"
.br
.RI "Gets the list of points to be used to perform higher-fidelity 'primary hover' checks\&. Only one interaction object may be the primary hover of an interaction controller (\fBLeap\fP hand or otherwise) at a time\&. Interface objects such as buttons can only be pressed when they are primarily hovered by an interaction controller, so it's best to return points on whatever you expect to be able to use to push buttons with the controller\&. "
.ti -1c
.RI "override \fBContactBone\fP [] \fBcontactBones\fP\fC [get]\fP"
.br
.ti -1c
.RI "override GameObject \fBcontactBoneParent\fP\fC [get]\fP"
.br
.ti -1c
.RI "float \fBgraspDepressedValue\fP\fC [get, set]\fP"
.br
.RI "The value between 0 and 1 past which the grasping axis value will cause an attempt to grasp a graspable interaction object near the grasp point\&. "
.ti -1c
.RI "float \fBgraspReleasedValue\fP\fC [get, set]\fP"
.br
.RI "If the grasping axis value passes the graspDepressedValue, it must then drop underneath this value in order to release the grasp attempt (potentially releasing a held object) and allow a new grasp attempt to occur\&. "
.ti -1c
.RI "override List< Vector3 > \fBgraspManipulatorPoints\fP\fC [get]\fP"
.br
.RI "Gets a list returning this controller's hoverPoint\&. Because the InteractionVRController represents a rigid controller, any two points that rigidly move with the controller position and orientation will provide enough information\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 28 of file InteractionXRController\&.cs\&.
.SH "Member Function Documentation"
.PP 
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.checkShouldGrasp (out \fBIInteractionBehaviour\fP objectToGrasp)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 780 of file InteractionXRController\&.cs\&.
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.checkShouldGraspAtemporal (\fBIInteractionBehaviour\fP intObj)\fC [protected]\fP, \fC [virtual]\fP"

.PP
If the provided object is within range of this VR controller's grasp point and the grasp button is currently held down, this method will manually initiate a grasp and return true\&. Otherwise, the method returns false\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 796 of file InteractionXRController\&.cs\&.
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.checkShouldRelease (out \fBIInteractionBehaviour\fP objectToRelease)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 814 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.fixedUpdateController ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called just before the \fBInteractionController\fP proceeds with its usual FixedUpdate\&. It's generally better to override this method instead of having your \fBInteractionController\fP implement FixedUpdate because its execution order relative to the \fBInteraction\fP Manager is fixed\&. 
.PP
Reimplemented from \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 179 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.fixedUpdateGraspingState ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called every fixed frame if grasping is enabled in the \fBInteraction\fP Manager\&. graspActivityManager\&.ActiveObjects will contain objects around the hoverPoint within the grasping radius -- in other words, objects eligible to be grasped by the controller\&. Refer to it to avoid checking grasp eligibility against all graspable objects in your scene\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 703 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.getColliderBoneTargetPositionRotation (int contactBoneIndex, out Vector3 targetPosition, out Quaternion targetRotation)\fC [protected]\fP, \fC [virtual]\fP"

.PP
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array\&. (For example, by recording the local position and local rotation of each contact bone in \fBinitContact()\fP)\&. More complex controllers, such as \fBInteractionHand\fP, uses this method to set \fBContactBone\fP target positions and rotations based on the tracked \fBLeap\fP hand\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 630 of file InteractionXRController\&.cs\&.
.SS "override Vector3 Leap\&.Unity\&.Interaction\&.InteractionXRController\&.GetGraspPoint ()\fC [virtual]\fP"

.PP
Returns approximately where the controller is grasping the currently grasped \fBInteractionBehaviour\fP\&. This method will print an error if the controller is not currently grasping an object\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 699 of file InteractionXRController\&.cs\&.
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.initContact ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called to initialize contact colliders\&. See remarks for implementation requirements\&. \fBinitContact()\fP should:
.IP "\(bu" 2
Return false at any time if initialization cannot be performed\&.
.IP "\(bu" 2
Ensure the 'contactBones' property returns all contact colliders\&.
.IP "  \(bu" 4
(Construct contact colliders if they don't already exist\&.)
.PP

.IP "\(bu" 2
Ensure the 'contactBoneParent' property returns the common parent of all contact colliders\&.
.IP "  \(bu" 4
(Construct the contact bone parent if it doesn't already exist\&.)
.PP

.IP "\(bu" 2
Return true if initialization was successful\&.
.PP
.PP
Contact will only begin updating after initialization succeeds, otherwise it will try to initialize again on the next fixed frame\&.
.PP
After initialization, the contact bone parent's layer will be set to the \fBInteraction\fP Manager's contactBoneLayer\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 536 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.OnDrawRuntimeGizmos (\fBRuntimeGizmos\&.RuntimeGizmoDrawer\fP drawer)"

.PP
Definition at line 827 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.onObjectUnregistered (\fBIInteractionBehaviour\fP intObj)\fC [protected]\fP, \fC [virtual]\fP"

.PP
InteractionVRController doesn't need to do anything when an object is unregistered\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 468 of file InteractionXRController\&.cs\&.
.SS "virtual void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.OnValidate ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 169 of file InteractionXRController\&.cs\&.
.SS "void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.RefreshControllerConnection ()"

.PP
Definition at line 229 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.Reset ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 153 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.Start ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 173 of file InteractionXRController\&.cs\&.
.SS "override void Leap\&.Unity\&.Interaction\&.InteractionXRController\&.unwarpColliders (Transform primaryHoverPoint, \fBISpaceComponent\fP warpedSpaceElement)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementing this method is necessary to support curved spaces as rendered by a \fBLeap\fP Graphic Renderer\&. See \fBInteractionHand\fP for an example implementation\&. (Implementing this method is optional if you are not using a curved space as rendered by a \fBLeap\fP Graphic Renderer\&.) Warps the collider transforms of this controller by the inverse of the transformation that is applied on the provided warpedSpaceElement, using the primaryHoverPoint as the pivot transform for the transformation\&.
.PP
ITransformer\&.WorldSpaceUnwarp is a useful method here\&. (ISpaceComponents contain references to their transformers via their anchors\&.)
.PP
ISpaceComponents denote game objects whose visual positions are warped from rectilinear (non-warped) space into a curved space (via, for example, a LeapCylindricalSpace, which can only be rendered correctly by the \fBLeap\fP Graphic Renderer)\&. This method reverses that transformation for the hand, bringing it into the object's rectilinear space, allowing objects curved in this way to correctly collide with the bones in the hand or collider of a held controller\&.
.PP
The provided Transform is the closest primary hover point to any given primary hover candidate, so it is used as the pivot point for unwarping the colliders of this \fBInteractionController\fP\&. 
.PP
Implements \fBLeap\&.Unity\&.Interaction\&.InteractionController\fP\&.
.PP
Definition at line 497 of file InteractionXRController\&.cs\&.
.SH "Member Data Documentation"
.PP 
.SS "Func<float> Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspAxisOverride = null"

.PP
By default, InteractionVRController uses Input\&.GetAxis(graspButtonAxis) to determine the 'depression' state for the grasp button\&. By setting this value to something other than null, it is possible to modify this behavior to instead retrieve a grasping axis value based on arbitrary code\&. A grasp is attempted when the grasp button axis value returned by this method becomes larger than the graspButtonDepressedValue, and a grasp is released when the grasp button axis value returned by this method becomes smaller than the graspButtonReleasedValue\&. Both of these values provide public setters\&. 
.PP
Definition at line 652 of file InteractionXRController\&.cs\&.
.SS "string Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspButtonAxis"

.PP
Definition at line 118 of file InteractionXRController\&.cs\&.
.SS "Transform Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspPoint"

.PP
Definition at line 112 of file InteractionXRController\&.cs\&.
.SS "float Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspTimingSlop = 0\&.10F"

.PP
Definition at line 125 of file InteractionXRController\&.cs\&.
.SS "float Leap\&.Unity\&.Interaction\&.InteractionXRController\&.maxGraspDistance = 0\&.06F"

.PP
Definition at line 114 of file InteractionXRController\&.cs\&.
.SS "float Leap\&.Unity\&.Interaction\&.InteractionXRController\&.pollConnectionInterval = 2f"

.PP
Definition at line 83 of file InteractionXRController\&.cs\&.
.SS "new List<Transform> Leap\&.Unity\&.Interaction\&.InteractionXRController\&.primaryHoverPoints"

.PP
Definition at line 104 of file InteractionXRController\&.cs\&.
.SH "Property Documentation"
.PP 
.SS "override List<Transform> Leap\&.Unity\&.Interaction\&.InteractionXRController\&._primaryHoverPoints\fC [get]\fP, \fC [protected]\fP"

.PP
Gets the list of points to be used to perform higher-fidelity 'primary hover' checks\&. Only one interaction object may be the primary hover of an interaction controller (\fBLeap\fP hand or otherwise) at a time\&. Interface objects such as buttons can only be pressed when they are primarily hovered by an interaction controller, so it's best to return points on whatever you expect to be able to use to push buttons with the controller\&. 
.PP
Definition at line 489 of file InteractionXRController\&.cs\&.
.SS "\fBChirality\fP Leap\&.Unity\&.Interaction\&.InteractionXRController\&.chirality\fC [get]\fP"

.PP
Definition at line 58 of file InteractionXRController\&.cs\&.
.SS "override GameObject Leap\&.Unity\&.Interaction\&.InteractionXRController\&.contactBoneParent\fC [get]\fP, \fC [protected]\fP"

.PP
Definition at line 532 of file InteractionXRController\&.cs\&.
.SS "override \fBContactBone\fP [] Leap\&.Unity\&.Interaction\&.InteractionXRController\&.contactBones\fC [get]\fP"

.PP
Definition at line 527 of file InteractionXRController\&.cs\&.
.SS "override \fBControllerType\fP Leap\&.Unity\&.Interaction\&.InteractionXRController\&.controllerType\fC [get]\fP"

.PP
Gets the type of controller this is\&. For InteractionVRController, the type is always ControllerType\&.VRController\&. 
.PP
Definition at line 452 of file InteractionXRController\&.cs\&.
.SS "string Leap\&.Unity\&.Interaction\&.InteractionXRController\&.deviceJoystickTokens\fC [get]\fP"

.PP
Definition at line 52 of file InteractionXRController\&.cs\&.
.SS "List<GameObject> Leap\&.Unity\&.Interaction\&.InteractionXRController\&.enableObjectsOnlyWhenTracked\fC [get]\fP"

.PP
These objects will be made active only while the controller is tracked\&. For more fine-tuned behavior, we recommend implementing your own logic\&. controller\&.isJoystickDetected and controller\&.isTracked are useful for this\&. 
.PP
Definition at line 140 of file InteractionXRController\&.cs\&.
.SS "float Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspDepressedValue\fC [get]\fP, \fC [set]\fP"

.PP
The value between 0 and 1 past which the grasping axis value will cause an attempt to grasp a graspable interaction object near the grasp point\&. 
.PP
Definition at line 659 of file InteractionXRController\&.cs\&.
.SS "override List<Vector3> Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspManipulatorPoints\fC [get]\fP"

.PP
Gets a list returning this controller's hoverPoint\&. Because the InteractionVRController represents a rigid controller, any two points that rigidly move with the controller position and orientation will provide enough information\&. 
.PP
Definition at line 682 of file InteractionXRController\&.cs\&.
.SS "float Leap\&.Unity\&.Interaction\&.InteractionXRController\&.graspReleasedValue\fC [get]\fP, \fC [set]\fP"

.PP
If the grasping axis value passes the graspDepressedValue, it must then drop underneath this value in order to release the grasp attempt (potentially releasing a held object) and allow a new grasp attempt to occur\&. 
.PP
Definition at line 670 of file InteractionXRController\&.cs\&.
.SS "override Vector3? Leap\&.Unity\&.Interaction\&.InteractionXRController\&.hoverPoint\fC [get]\fP"

.PP
Gets the center point used for hover distance checking\&. 
.PP
Definition at line 477 of file InteractionXRController\&.cs\&.
.SS "override \fBInteractionHand\fP Leap\&.Unity\&.Interaction\&.InteractionXRController\&.intHand\fC [get]\fP"

.PP
This implementation of InteractionControllerBase does not represent a \fBLeap\fP hand, so it need not return an \fBInteractionHand\fP object\&. 
.PP
Definition at line 460 of file InteractionXRController\&.cs\&.
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.isBeingMoved\fC [get]\fP"

.PP
Gets whether or not the underlying controller is currently being moved in world space, but relative to the \fBInteraction\fP Manager's transform\&. The \fBInteraction\fP Manager is usually a sibling of the main camera beneath the camera rig transform, so that if your application is only translating the player rig in space, this method won't incorrectly return true\&. 
.PP
Definition at line 387 of file InteractionXRController\&.cs\&.
.SS "bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.isJoystickDetected\fC [get]\fP"

.PP
Whether the device joystick tokens matched an entry in Input\&.GetJoystickNames()\&. If pollConnection is set to true, this status is refreshed periodically based on the pollConnectionInterval, but only while the joystick tokens have not been detected from Input\&.GetJoystickNames()\&. Call \fBRefreshControllerConnection()\fP to detect if the controller has been disconnected\&. Joystick detection is skipped if deviceJoystickTokens is null or empty, causing this check to always return true\&. 
.PP
Definition at line 211 of file InteractionXRController\&.cs\&.
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.isLeft\fC [get]\fP"

.PP
Gets whether the controller is a left-hand controller\&. 
.PP
Definition at line 412 of file InteractionXRController\&.cs\&.
.SS "override bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.isTracked\fC [get]\fP"

.PP
Gets whether or not the underlying controller is currently tracked and any joystick token filtering has confirmed that this controller has been detected as a connected joystick\&. 
.PP
Definition at line 374 of file InteractionXRController\&.cs\&.
.SS "bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.isUsingCustomTracking\fC [get]\fP"

.PP
Definition at line 43 of file InteractionXRController\&.cs\&.
.SS "bool Leap\&.Unity\&.Interaction\&.InteractionXRController\&.pollConnection\fC [get]\fP, \fC [set]\fP"

.PP
Whether to continuously poll attached joystick data for a joystick that matches the device joystick tokens, using Input\&.GetJoystickNames()\&. This call allocates garbage, so be wary of setting a low polling interval\&. The connection is polled only until a joystick is detected to minimize allocation\&. Once a joystick has been detected (isJoystickDetected), you must manually call \fBRefreshControllerConnection()\fP to check if the joystick is no longer detected\&. 
.PP
Definition at line 74 of file InteractionXRController\&.cs\&.
.SS "override Vector3 Leap\&.Unity\&.Interaction\&.InteractionXRController\&.position\fC [get]\fP"

.PP
Gets the last-tracked position of the controller\&. 
.PP
Definition at line 419 of file InteractionXRController\&.cs\&.
.SS "override Quaternion Leap\&.Unity\&.Interaction\&.InteractionXRController\&.rotation\fC [get]\fP"

.PP
Gets the last-tracked rotation of the controller\&. 
.PP
Definition at line 428 of file InteractionXRController\&.cs\&.
.SS "\fBIXRControllerTrackingProvider\fP Leap\&.Unity\&.Interaction\&.InteractionXRController\&.trackingProvider\fC [get]\fP, \fC [set]\fP"

.PP
Definition at line 254 of file InteractionXRController\&.cs\&.
.SS "override Vector3 Leap\&.Unity\&.Interaction\&.InteractionXRController\&.velocity\fC [get]\fP"

.PP
Gets the current velocity of the controller\&. 
.PP
Definition at line 437 of file InteractionXRController\&.cs\&.
.SS "VRNode? Leap\&.Unity\&.Interaction\&.InteractionXRController\&.xrNode\fC [get]\fP"

.PP
Gets the XRNode associated with this XR controller\&. Note: If the tracking mode for this controller is specified as \fBControllerTrackingMode\&.Custom\fP, this value may be ignored\&. 
.PP
Definition at line 404 of file InteractionXRController\&.cs\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Multi User Vr Viewer from the source code\&.
