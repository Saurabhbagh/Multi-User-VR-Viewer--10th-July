{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Leap.Unity.Interaction.InteractionHand Class Reference\par \pard\plain 
{\tc\tcl2 \v Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand}
{\bkmkstart AAAAAAAFJM}
{\bkmkend AAAAAAAFJM}
Inheritance diagram for Leap.Unity.Interaction.InteractionHand:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_leap_1_1_unity_1_1_interaction_1_1_interaction_hand.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillBones} ({\b Hand} inHand)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A utility function that sets a {\b Hand} object's bones based on this {\b InteractionHand}. Can be used to display a graphical hand that matches the physical one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3 {\b GetGraspPoint} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns approximately where the controller is grasping the currently-grasped {\b InteractionBehaviour}. Specifically, returns the average position of all grasping fingertips of the {\b InteractionHand}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b SwapGrasp} ({\b IInteractionBehaviour} replacement)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seamlessly swap the currently grasped object for a replacement object. It will behave like the hand released the current object, and then grasped the new object. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool [] {\b enabledPrimaryHoverFingertips} = new bool[5] \{ true, true, true, false, false \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set slots to true to consider the corresponding finger's fingertip for primary hover checks. 0 is the thumb, 1 is the index finger, etc. Generally speaking, enable the fingertips you'd like users to be able to use to choose and push a button, but keep in mind you pay distance check costs for each fingertip enabled! }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Start} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b onObjectUnregistered} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called by the {\b InteractionController} when it is notified by the {\b InteractionManager} that an {\b InteractionBehaviour} has been unregistered from the {\b Interaction} Engine. If your controller has any state that remembers or tracks interaction objects, this method should clear that state, because unregistered objects won't receive state updates or callbacks from this controller's {\b Interaction} Manager anymore. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b fixedUpdateController} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called just before the {\b InteractionController} proceeds with its usual FixedUpdate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b unwarpColliders} (Transform primaryHoverPoint, {\b ISpaceComponent} warpedSpaceElement)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementing this method is necessary to support curved spaces as rendered by a {\b Leap} Graphic Renderer. See {\b InteractionHand} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a {\b Leap} Graphic Renderer.) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b getColliderBoneTargetPositionRotation} (int contactBoneIndex, out Vector3 targetPosition, out Quaternion targetRotation)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array. (For example, by recording the local position and local rotation of each contact bone in {\b initContact()}). More complex controllers, such as {\b InteractionHand}, uses this method to set {\b ContactBone} target positions and rotations based on the tracked {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b initContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called to initialize contact colliders. See remarks for implementation requirements. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b onPreEnableSoftContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before soft contact is enabled for this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b onPostDisableSoftContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just after soft contact is disabled for this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b checkShouldGraspAtemporal} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to manually initiate a grasp on the argument interaction object. A grasp will only begin if a finger and thumb are both in contact with the interaction object. If this method successfully initiates a grasp, it will return true, otherwise it will return false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b fixedUpdateGraspingState} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed frame if grasping is enabled in the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b onGraspedObjectForciblyReleased} ({\b IInteractionBehaviour} objectToBeReleased)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before a grasped object is released because it is no longer eligible to be grasped by this controller or {\b ReleaseGrasp()} was manually called on the controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b checkShouldRelease} (out {\b IInteractionBehaviour} objectToRelease)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b checkShouldGrasp} (out {\b IInteractionBehaviour} objectToGrasp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HandDataMode} {\b handDataMode}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LeapProvider} {\b leapProvider}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the hand data mode for this {\b InteractionHand} is set to Custom, you must also manually specify the provider from which to retrieve {\b Leap} frames containing hand data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Func< {\b Leap.Frame}, {\b Leap.Hand} > {\b handAccessorFunc}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the hand data mode for this {\b InteractionHand} is set to Custom, you must manually specify how this {\b InteractionHand} should retrieve a specific {\b Hand} data object from a {\b Leap} frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b isTracked}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying {\b Leap} hand is currently tracked. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b isBeingMoved}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying {\b Leap} hand is currently being moved in worldspace. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hand} {\b leapHand}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last tracked state of the {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b isLeft}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying tracked {\b Leap} hand is a left hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3 {\b position}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked position of the underlying {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Quaternion {\b rotation}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked rotation of the underlying {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3? {\b velocity}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the velocity of the underlying tracked {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override {\b ControllerType} {\b controllerType}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the controller type of this InteractionControllerBase. InteractionHands are {\b Interaction} Engine controllers implemented over {\b Leap} hands. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override {\b InteractionHand} {\b intHand}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this {\b InteractionHand} object. This property will be null if the InteractionControllerBase is not {\b ControllerType.Hand}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3 {\b hoverPoint}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override List< Transform > {\b _primaryHoverPoints}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override {\b ContactBone} [] {\b contactBones}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override GameObject {\b contactBoneParent}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override List< Vector3 > {\b graspManipulatorPoints}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HeuristicGrabClassifier} {\b grabClassifier}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handles logic determining whether a hand has grabbed or released an interaction object. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 26 of file InteractionHand.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v checkShouldGrasp\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:checkShouldGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.checkShouldGrasp (out {\b IInteractionBehaviour}  {\i objectToGrasp}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFA}
{\bkmkend AAAAAAAFFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFEY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 735 of file InteractionHand.cs.}\par
}
{\xe \v checkShouldGraspAtemporal\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:checkShouldGraspAtemporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.checkShouldGraspAtemporal ({\b IInteractionBehaviour}  {\i intObj}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFD}
{\bkmkend AAAAAAAFFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to manually initiate a grasp on the argument interaction object. A grasp will only begin if a finger and thumb are both in contact with the interaction object. If this method successfully initiates a grasp, it will return true, otherwise it will return false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 698 of file InteractionHand.cs.}\par
}
{\xe \v checkShouldRelease\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:checkShouldRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.checkShouldRelease (out {\b IInteractionBehaviour}  {\i objectToRelease}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFG}
{\bkmkend AAAAAAAFFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 731 of file InteractionHand.cs.}\par
}
{\xe \v FillBones\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:FillBones}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionHand.FillBones ({\b Hand}  {\i inHand})}}
\par
{\bkmkstart AAAAAAAFJN}
{\bkmkend AAAAAAAFJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A utility function that sets a {\b Hand} object's bones based on this {\b InteractionHand}. Can be used to display a graphical hand that matches the physical one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 595 of file InteractionHand.cs.}\par
}
{\xe \v fixedUpdateController\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:fixedUpdateController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.fixedUpdateController (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFR}
{\bkmkend AAAAAAAFFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called just before the {\b InteractionController} proceeds with its usual FixedUpdate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's generally better to override this method instead of having your {\b InteractionController} implement FixedUpdate because its execution order relative to the {\b Interaction} Manager is fixed. \par
}{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 285 of file InteractionHand.cs.}\par
}
{\xe \v fixedUpdateGraspingState\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:fixedUpdateGraspingState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.fixedUpdateGraspingState (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFU}
{\bkmkend AAAAAAAFFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed frame if grasping is enabled in the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
graspActivityManager.ActiveObjects will contain objects around the hoverPoint within the grasping radius \'96 in other words, objects eligible to be grasped by the controller. Refer to it to avoid checking grasp eligibility against all graspable objects in your scene. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 723 of file InteractionHand.cs.}\par
}
{\xe \v getColliderBoneTargetPositionRotation\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:getColliderBoneTargetPositionRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.getColliderBoneTargetPositionRotation (int  {\i contactBoneIndex}, out Vector3  {\i targetPosition}, out Quaternion  {\i targetRotation}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFY}
{\bkmkend AAAAAAAFFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array. (For example, by recording the local position and local rotation of each contact bone in {\b initContact()}). More complex controllers, such as {\b InteractionHand}, uses this method to set {\b ContactBone} target positions and rotations based on the tracked {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 390 of file InteractionHand.cs.}\par
}
{\xe \v GetGraspPoint\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:GetGraspPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3 Leap.Unity.Interaction.InteractionHand.GetGraspPoint (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGB}
{\bkmkend AAAAAAAFGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns approximately where the controller is grasping the currently-grasped {\b InteractionBehaviour}. Specifically, returns the average position of all grasping fingertips of the {\b InteractionHand}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method will print an error if the hand is not currently grasping an object. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 671 of file InteractionHand.cs.}\par
}
{\xe \v initContact\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:initContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.initContact (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGF}
{\bkmkend AAAAAAAFGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called to initialize contact colliders. See remarks for implementation requirements. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b initContact()} should:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Return false at any time if initialization cannot be performed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ensure the "contactBones" property returns all contact colliders.{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
(Construct contact colliders if they don't already exist.)\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ensure the "contactBoneParent" property returns the common parent of all contact colliders.{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
(Construct the contact bone parent if it doesn't already exist.)\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Return true if initialization was successful.\par}
Contact will only begin updating after initialization succeeds, otherwise it will try to initialize again on the next fixed frame.\par
After initialization, the contact bone parent's layer will be set to the {\b Interaction} Manager's contactBoneLayer. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 400 of file InteractionHand.cs.}\par
}
{\xe \v onGraspedObjectForciblyReleased\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:onGraspedObjectForciblyReleased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.onGraspedObjectForciblyReleased ({\b IInteractionBehaviour}  {\i objectToBeReleased}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGR}
{\bkmkend AAAAAAAFGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before a grasped object is released because it is no longer eligible to be grasped by this controller or {\b ReleaseGrasp()} was manually called on the controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 727 of file InteractionHand.cs.}\par
}
{\xe \v onObjectUnregistered\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:onObjectUnregistered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.onObjectUnregistered ({\b IInteractionBehaviour}  {\i intObj}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGU}
{\bkmkend AAAAAAAFGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called by the {\b InteractionController} when it is notified by the {\b InteractionManager} that an {\b InteractionBehaviour} has been unregistered from the {\b Interaction} Engine. If your controller has any state that remembers or tracks interaction objects, this method should clear that state, because unregistered objects won't receive state updates or callbacks from this controller's {\b Interaction} Manager anymore. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 281 of file InteractionHand.cs.}\par
}
{\xe \v onPostDisableSoftContact\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:onPostDisableSoftContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.onPostDisableSoftContact (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGW}
{\bkmkend AAAAAAAFGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just after soft contact is disabled for this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InteractionHand} implementation takes the opportunity to reset its contact bone's joints, which my have initialized slightly out of alignment on initial construction. \par
}{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 413 of file InteractionHand.cs.}\par
}
{\xe \v onPreEnableSoftContact\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:onPreEnableSoftContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.onPreEnableSoftContact (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGY}
{\bkmkend AAAAAAAFGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before soft contact is enabled for this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InteractionHand} implementation takes the opportunity to reset its contact bone's joints, which may have initialized slightly out of alignment on initial construction. \par
}{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 409 of file InteractionHand.cs.}\par
}
{\xe \v Reset\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.Reset (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHF}
{\bkmkend AAAAAAAFHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 112 of file InteractionHand.cs.}\par
}
{\xe \v Start\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:Start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.Start (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHI}
{\bkmkend AAAAAAAFHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 118 of file InteractionHand.cs.}\par
}
{\xe \v SwapGrasp\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:SwapGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.SwapGrasp ({\b IInteractionBehaviour}  {\i replacement}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHK}
{\bkmkend AAAAAAAFHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seamlessly swap the currently grasped object for a replacement object. It will behave like the hand released the current object, and then grasped the new object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method will not teleport the replacement object or move it in any way, it will just cause it to be grasped. That means that you will be responsible for moving the replacement object into a reasonable position for it to be grasped. \par
}{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 715 of file InteractionHand.cs.}\par
}
{\xe \v unwarpColliders\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:unwarpColliders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionHand.unwarpColliders (Transform  {\i primaryHoverPoint}, {\b ISpaceComponent}  {\i warpedSpaceElement}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHP}
{\bkmkend AAAAAAAFHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementing this method is necessary to support curved spaces as rendered by a {\b Leap} Graphic Renderer. See {\b InteractionHand} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a {\b Leap} Graphic Renderer.) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Warps the collider transforms of this controller by the inverse of the transformation that is applied on the provided warpedSpaceElement, using the primaryHoverPoint as the pivot transform for the transformation.\par
ITransformer.WorldSpaceUnwarp is a useful method here. (ISpaceComponents contain references to their transformers via their anchors.)\par
ISpaceComponents denote game objects whose visual positions are warped from rectilinear (non-warped) space into a curved space (via, for example, a LeapCylindricalSpace, which can only be rendered correctly by the {\b Leap} Graphic Renderer). This method reverses that transformation for the hand, bringing it into the object's rectilinear space, allowing objects curved in this way to correctly collide with the bones in the hand or collider of a held controller.\par
The provided Transform is the closest primary hover point to any given primary hover candidate, so it is used as the pivot point for unwarping the colliders of this {\b InteractionController}. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 348 of file InteractionHand.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v enabledPrimaryHoverFingertips\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:enabledPrimaryHoverFingertips}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool [] Leap.Unity.Interaction.InteractionHand.enabledPrimaryHoverFingertips = new bool[5] \{ true, true, true, false, false \}}}
\par
{\bkmkstart AAAAAAAFJO}
{\bkmkend AAAAAAAFJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set slots to true to consider the corresponding finger's fingertip for primary hover checks. 0 is the thumb, 1 is the index finger, etc. Generally speaking, enable the fingertips you'd like users to be able to use to choose and push a button, but keep in mind you pay distance check costs for each fingertip enabled! }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 55 of file InteractionHand.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v _primaryHoverPoints\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:_primaryHoverPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override List<Transform> Leap.Unity.Interaction.InteractionHand._primaryHoverPoints{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFJP}
{\bkmkend AAAAAAAFJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 316 of file InteractionHand.cs.}\par
}
{\xe \v contactBoneParent\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:contactBoneParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override GameObject Leap.Unity.Interaction.InteractionHand.contactBoneParent{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFJQ}
{\bkmkend AAAAAAAFJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 382 of file InteractionHand.cs.}\par
}
{\xe \v contactBones\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:contactBones}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override {\b ContactBone} [] Leap.Unity.Interaction.InteractionHand.contactBones{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJR}
{\bkmkend AAAAAAAFJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 377 of file InteractionHand.cs.}\par
}
{\xe \v controllerType\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:controllerType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override {\b ControllerType} Leap.Unity.Interaction.InteractionHand.controllerType{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJS}
{\bkmkend AAAAAAAFJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the controller type of this InteractionControllerBase. InteractionHands are {\b Interaction} Engine controllers implemented over {\b Leap} hands. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 269 of file InteractionHand.cs.}\par
}
{\xe \v grabClassifier\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:grabClassifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HeuristicGrabClassifier} Leap.Unity.Interaction.InteractionHand.grabClassifier{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJT}
{\bkmkend AAAAAAAFJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handles logic determining whether a hand has grabbed or released an interaction object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 656 of file InteractionHand.cs.}\par
}
{\xe \v graspManipulatorPoints\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:graspManipulatorPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override List<Vector3> Leap.Unity.Interaction.InteractionHand.graspManipulatorPoints{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJU}
{\bkmkend AAAAAAAFJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 626 of file InteractionHand.cs.}\par
}
{\xe \v handAccessorFunc\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:handAccessorFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Func<{\b Leap.Frame}, {\b Leap.Hand}> Leap.Unity.Interaction.InteractionHand.handAccessorFunc{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFJV}
{\bkmkend AAAAAAAFJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the hand data mode for this {\b InteractionHand} is set to Custom, you must manually specify how this {\b InteractionHand} should retrieve a specific {\b Hand} data object from a {\b Leap} frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 86 of file InteractionHand.cs.}\par
}
{\xe \v handDataMode\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:handDataMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HandDataMode} Leap.Unity.Interaction.InteractionHand.handDataMode{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFJW}
{\bkmkend AAAAAAAFJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file InteractionHand.cs.}\par
}
{\xe \v hoverPoint\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:hoverPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3 Leap.Unity.Interaction.InteractionHand.hoverPoint{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJX}
{\bkmkend AAAAAAAFJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 303 of file InteractionHand.cs.}\par
}
{\xe \v intHand\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:intHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override {\b InteractionHand} Leap.Unity.Interaction.InteractionHand.intHand{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJY}
{\bkmkend AAAAAAAFJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns this {\b InteractionHand} object. This property will be null if the InteractionControllerBase is not {\b ControllerType.Hand}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 277 of file InteractionHand.cs.}\par
}
{\xe \v isBeingMoved\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:isBeingMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.isBeingMoved{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJZ}
{\bkmkend AAAAAAAFJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying {\b Leap} hand is currently being moved in worldspace. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 214 of file InteractionHand.cs.}\par
}
{\xe \v isLeft\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:isLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.isLeft{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFKA}
{\bkmkend AAAAAAAFKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying tracked {\b Leap} hand is a left hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 231 of file InteractionHand.cs.}\par
}
{\xe \v isTracked\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:isTracked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionHand.isTracked{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFKB}
{\bkmkend AAAAAAAFKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying {\b Leap} hand is currently tracked. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 209 of file InteractionHand.cs.}\par
}
{\xe \v leapHand\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:leapHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hand} Leap.Unity.Interaction.InteractionHand.leapHand{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFKC}
{\bkmkend AAAAAAAFKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last tracked state of the {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note for those using the {\b Leap} Graphical Renderer: If the hand required warping due to the nearby presence of an object in warped (curved) space, this will return the hand as warped from that object's curved space into the rectilinear space containing its colliders. This is only relevant if you are using the {\b Leap} Graphical Renderer to render curved, interactive objects. \par
}{
Definition at line 225 of file InteractionHand.cs.}\par
}
{\xe \v leapProvider\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:leapProvider}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LeapProvider} Leap.Unity.Interaction.InteractionHand.leapProvider{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFKD}
{\bkmkend AAAAAAAFKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the hand data mode for this {\b InteractionHand} is set to Custom, you must also manually specify the provider from which to retrieve {\b Leap} frames containing hand data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 65 of file InteractionHand.cs.}\par
}
{\xe \v position\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3 Leap.Unity.Interaction.InteractionHand.position{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFKE}
{\bkmkend AAAAAAAFKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked position of the underlying {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 247 of file InteractionHand.cs.}\par
}
{\xe \v rotation\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:rotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Quaternion Leap.Unity.Interaction.InteractionHand.rotation{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFKF}
{\bkmkend AAAAAAAFKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked rotation of the underlying {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 254 of file InteractionHand.cs.}\par
}
{\xe \v velocity\:Leap.Unity.Interaction.InteractionHand}
{\xe \v Leap.Unity.Interaction.InteractionHand\:velocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3? Leap.Unity.Interaction.InteractionHand.velocity{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFKG}
{\bkmkend AAAAAAAFKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the velocity of the underlying tracked {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 261 of file InteractionHand.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
O:/GitHUBMINIPRoject/Assets/LeapMotion/Modules/InteractionEngine/Scripts/{\b InteractionHand.cs}\par
}}