{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Leap.Controller Class Reference\par \pard\plain 
{\tc\tcl2 \v Leap.Controller}
{\xe \v Leap.Controller}
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Controller} class is your main interface to the {\b Leap} Motion {\b Controller}. }}\par
Inheritance diagram for Leap.Controller:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_leap_1_1_controller.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PolicyFlag} \{ {\b PolicyFlag.POLICY_DEFAULT} = 0, 
{\b PolicyFlag.POLICY_BACKGROUND_FRAMES} = (1 << 0), 
{\b PolicyFlag.POLICY_IMAGES} = (1 << 1), 
{\b PolicyFlag.POLICY_OPTIMIZE_HMD} = (1 << 2), 
{\b PolicyFlag.POLICY_ALLOW_PAUSE_RESUME} = (1 << 3), 
{\b PolicyFlag.POLICY_MAP_POINTS} = (1 << 7)
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The supported controller policies. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Dispose} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Controller} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b Controller} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Controller} (int connectionKey)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b Controller} object using the specified connection key. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StartConnection} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Starts the connection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StopConnection} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stops the connection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetPolicy} ({\b PolicyFlag} policy)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Requests setting a policy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearPolicy} ({\b PolicyFlag} policy)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Requests clearing a policy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsPolicySet} ({\b PolicyFlag} policy)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the active setting for a specific policy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Frame} {\b Frame} (int history=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In most cases you should get {\b Frame} objects using the {\b LeapProvider.CurrentFrame} property. The data in {\b Frame} objects taken directly from a {\b Leap.Controller} instance is still in the {\b Leap} Motion frame of reference and will not match the hands displayed in a {\b Unity} scene. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Frame} ({\b Frame} toFill, int history=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identical to Frame(history) but instead of constructing a new frame and returning it, the user provides a frame object to be filled with data instead. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b FrameTimestamp} (int history=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the timestamp of a recent tracking frame. Use the optional history parameter to specify how many frames in the past to retrieve the timestamp. Leave the history parameter as it's default value to return the timestamp of the most recent tracked frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Frame} {\b GetTransformedFrame} ({\b LeapTransform} trs, int history=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the frame object with all hands transformed by the specified transform matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Frame} {\b GetInterpolatedFrame} (Int64 time)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b Frame} at the specified time, interpolating the data between existing frames, if necessary. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetInterpolatedFrame} ({\b Frame} toFill, Int64 time)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the {\b Frame} with data taken at the specified time, interpolating the data between existing frames, if necessary. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LEAP_HEAD_POSE_EVENT} {\b GetInterpolatedHeadPose} (Int64 time)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Head pose at the specified time, interpolating the data between existing frames, if necessary. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetInterpolatedHeadPose} (ref {\b LEAP_HEAD_POSE_EVENT} toFill, Int64 time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b TelemetryProfiling} (ref {\b LEAP_TELEMETRY_DATA} telemetryData)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
UInt64 {\b TelemetryGetNow} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetPointMapping} (ref {\b PointMapping} pointMapping)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetInterpolatedLeftRightTransform} (Int64 time, Int64 sourceTime, int leftId, int rightId, out {\b LeapTransform} leftTransform, out {\b LeapTransform} rightTransform)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a special variant of GetInterpolatedFrameFromTime, for use with special features that only require the position and orientation of the palm positions, and do not care about pose data or any other data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetInterpolatedFrameFromTime} ({\b Frame} toFill, Int64 time, Int64 sourceTime)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b Now} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a timestamp value as close as possible to the current time. Values are in microseconds, as with all the other timestamp values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FailedDeviceList} {\b FailedDevices} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A list of any {\b Leap} Motion hardware devices that are physically connected to the client computer, but are not functioning correctly. The list contains {\b FailedDevice} objects containing the pnpID and the reason for failure. No other device information is available. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dispose} (bool disposing)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnInit} (object sender, {\b LeapEventArgs} eventArgs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnConnect} (object sender, {\b ConnectionEventArgs} eventArgs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnDisconnect} (object sender, {\b ConnectionLostEventArgs} eventArgs)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SynchronizationContext {\b EventContext}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The SynchronizationContext used for dispatching events. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b LeapEventArgs} > {\b Init}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the connection is initialized (but not necessarily connected). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b ConnectionEventArgs} > {\b Connect}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the connection to the service is established. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b ConnectionLostEventArgs} > {\b Disconnect}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched if the connection to the service is lost. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b FrameEventArgs} > {\b FrameReady}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a tracking frame is ready. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b InternalFrameEventArgs} > {\b InternalFrameReady}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when an internal tracking frame is ready. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b DeviceEventArgs} > {\b Device}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a {\b Leap} Motion device is connected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b DeviceEventArgs} > {\b DeviceLost}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a {\b Leap} Motion device is disconnected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b DeviceFailureEventArgs} > {\b DeviceFailure}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a {\b Leap} device fails to initialize. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b LogEventArgs} > {\b LogMessage}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the system generates a loggable event. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b PolicyEventArgs} > {\b PolicyChange}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a policy changes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b ConfigChangeEventArgs} > {\b ConfigChange}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a configuration setting changes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b DistortionEventArgs} > {\b DistortionChange}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the image distortion map changes. The distortion map can change when the {\b Leap} device switches orientation, or a new device becomes active. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b DroppedFrameEventArgs} > {\b DroppedFrame}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the service drops a tracking frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b ImageEventArgs} > {\b ImageReady}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when an unrequested image is ready. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b BeginProfilingForThreadArgs} > {\b BeginProfilingForThread}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread wants to start profiling for a custom thread. The event is always dispatched from the thread itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b EndProfilingForThreadArgs} > {\b EndProfilingForThread}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread is finished profiling. The event is always dispatched from the thread itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b BeginProfilingBlockArgs} > {\b BeginProfilingBlock}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread enters a profiling block. The event is always dispatched from the thread itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b EndProfilingBlockArgs} > {\b EndProfilingBlock}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread ends a profiling block. The event is always dispatched from the thread itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b PointMappingChangeEventArgs} > {\b PointMappingChange}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when point mapping change events are generated by the service. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EventHandler< {\b HeadPoseEventArgs} > {\b HeadPoseChange}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a new HeadPose is available. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsServiceConnected}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reports whether your application has a connection to the {\b Leap} Motion daemon/service. Can be true even if the {\b Leap} Motion hardware is not available. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsConnected}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reports whether this {\b Controller} is connected to the {\b Leap} Motion service and the {\b Leap} Motion hardware is plugged in. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} {\b Config}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b Config} object, which you can use to query the {\b Leap} Motion system for configuration information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DeviceList} {\b Devices}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The list of currently attached and recognized {\b Leap} Motion controller devices. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Controller} class is your main interface to the {\b Leap} Motion {\b Controller}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an instance of this {\b Controller} class to access frames of tracking data and configuration information.Frame data can be polled at any time using the {\b Controller.Frame()} function.Call frame() or frame(0) to get the most recent frame.Set the history parameter to a positive integer to access previous frames.A controller stores up to 60 frames in its frame history.\par
Polling is an appropriate strategy for applications which already have an intrinsic update loop, such as a game. You can also subscribe to the FrameReady event to get tracking frames through an event delegate.\par
If the current thread implements a SynchronizationContext that contains a message loop, events are posted to that threads message loop. Otherwise, events are called on an independent thread and applications must perform any needed synchronization or marshalling of data between threads. Note that Unity3D does not create an appropriate SynchronizationContext object. Typically, event handlers cannot access any {\b Unity} objects.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{
Definition at line 39 of file Controller.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v PolicyFlag\:Leap.Controller}
{\xe \v Leap.Controller\:PolicyFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Leap.Controller.PolicyFlag}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The supported controller policies. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The supported policy flags are:\par
{\b POLICY_BACKGROUND_FRAMES}  \'96 requests that your application receives frames when it is not the foreground application for user input.\par
The background frames policy determines whether an application receives frames of tracking data while in the background. By default, the {\b Leap} Motion software only sends tracking data to the foreground application. Only applications that need this ability should request the background frames policy. The "Allow Background Apps" checkbox must be enabled in the {\b Leap} Motion Control Panel or this policy will be denied.\par
{\b POLICY_OPTIMIZE_HMD}  \'96 request that the tracking be optimized for head-mounted tracking.\par
The optimize HMD policy improves tracking in situations where the {\b Leap} Motion hardware is attached to a head-mounted display. This policy is not granted for devices that cannot be mounted to an HMD, such as {\b Leap} Motion controllers embedded in a laptop or keyboard.\par
Some policies can be denied if the user has disabled the feature on their {\b Leap} Motion control panel.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v POLICY_DEFAULT\:Leap.Controller}
{\xe \v Leap.Controller\:POLICY_DEFAULT}
{\qr POLICY_DEFAULT{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default policy. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\cell }{\row }
{\xe \v POLICY_BACKGROUND_FRAMES\:Leap.Controller}
{\xe \v Leap.Controller\:POLICY_BACKGROUND_FRAMES}
{\qr POLICY_BACKGROUND_FRAMES{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receive background frames. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\cell }{\row }
{\xe \v POLICY_IMAGES\:Leap.Controller}
{\xe \v Leap.Controller\:POLICY_IMAGES}
{\qr POLICY_IMAGES{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow streaming images. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\cell }{\row }
{\xe \v POLICY_OPTIMIZE_HMD\:Leap.Controller}
{\xe \v Leap.Controller\:POLICY_OPTIMIZE_HMD}
{\qr POLICY_OPTIMIZE_HMD{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optimize the tracking for head-mounted device. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\cell }{\row }
{\xe \v POLICY_ALLOW_PAUSE_RESUME\:Leap.Controller}
{\xe \v Leap.Controller\:POLICY_ALLOW_PAUSE_RESUME}
{\qr POLICY_ALLOW_PAUSE_RESUME{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow pausing and unpausing of the {\b Leap} Motion service. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\cell }{\row }
{\xe \v POLICY_MAP_POINTS\:Leap.Controller}
{\xe \v Leap.Controller\:POLICY_MAP_POINTS}
{\qr POLICY_MAP_POINTS{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allow streaming map point \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\cell }{\row }
}
{
Definition at line 690 of file Controller.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Controller\:Leap.Controller}
{\xe \v Leap.Controller\:Controller}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Leap.Controller.Controller ()}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b Controller} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default constructor uses a connection key of 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{
Definition at line 364 of file Controller.cs.}\par
}
{\xe \v Controller\:Leap.Controller}
{\xe \v Leap.Controller\:Controller}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Leap.Controller.Controller (int  {\i connectionKey})}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b Controller} object using the specified connection key. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All controller instances using the same key will use the same connection to the service. In general, an application should not use more than one connection for all its controllers. Each connection keeps its own cache of frames and images.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i connectionKey} \cell }{An identifier specifying the connection to use. If a connection with the specified key already exists, that connection is used. Otherwise, a new connection is created. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 378 of file Controller.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ClearPolicy\:Leap.Controller}
{\xe \v Leap.Controller\:ClearPolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.ClearPolicy ({\b PolicyFlag}  {\i policy})}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Requests clearing a policy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Policy changes are completed asynchronously and, because they are subject to user approval or system compatibility checks, may not complete successfully. Call {\b Controller.IsPolicySet()} after a suitable interval to test whether the change was accepted. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 2.1.6 \par
}}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 450 of file Controller.cs.}\par
}
{\xe \v Dispose\:Leap.Controller}
{\xe \v Leap.Controller\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.Dispose ()}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 343 of file Controller.cs.}\par
}
{\xe \v Dispose\:Leap.Controller}
{\xe \v Leap.Controller\:Dispose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Controller.Dispose (bool  {\i disposing}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 349 of file Controller.cs.}\par
}
{\xe \v FailedDevices\:Leap.Controller}
{\xe \v Leap.Controller\:FailedDevices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FailedDeviceList} Leap.Controller.FailedDevices ()}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A list of any {\b Leap} Motion hardware devices that are physically connected to the client computer, but are not functioning correctly. The list contains {\b FailedDevice} objects containing the pnpID and the reason for failure. No other device information is available. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 658 of file Controller.cs.}\par
}
{\xe \v Frame\:Leap.Controller}
{\xe \v Leap.Controller\:Frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Frame} Leap.Controller.Frame (int  {\i history} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In most cases you should get {\b Frame} objects using the {\b LeapProvider.CurrentFrame} property. The data in {\b Frame} objects taken directly from a {\b Leap.Controller} instance is still in the {\b Leap} Motion frame of reference and will not match the hands displayed in a {\b Unity} scene. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a frame of tracking data from the {\b Leap} Motion software. Use the optional history parameter to specify which frame to retrieve. Call frame() or frame(0) to access the most recent frame; call frame(1) to access the previous frame, and so on. If you use a history value greater than the number of stored frames, then the controller returns an empty frame.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i history} \cell }{The age of the frame to return, counting backwards from the most recent frame (0) into the past and up to the maximum age (59). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid The specified frame; or, if no history parameter is specified, the newest frame. If a frame is not available at the specified history position, an invalid {\b Frame} is returned. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 491 of file Controller.cs.}\par
}
{\xe \v Frame\:Leap.Controller}
{\xe \v Leap.Controller\:Frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.Frame ({\b Frame}  {\i toFill}, int  {\i history} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identical to Frame(history) but instead of constructing a new frame and returning it, the user provides a frame object to be filled with data instead. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 501 of file Controller.cs.}\par
}
{\xe \v FrameTimestamp\:Leap.Controller}
{\xe \v Leap.Controller\:FrameTimestamp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long Leap.Controller.FrameTimestamp (int  {\i history} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the timestamp of a recent tracking frame. Use the optional history parameter to specify how many frames in the past to retrieve the timestamp. Leave the history parameter as it's default value to return the timestamp of the most recent tracked frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 514 of file Controller.cs.}\par
}
{\xe \v GetInterpolatedFrame\:Leap.Controller}
{\xe \v Leap.Controller\:GetInterpolatedFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Frame} Leap.Controller.GetInterpolatedFrame (Int64  {\i time})}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b Frame} at the specified time, interpolating the data between existing frames, if necessary. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 531 of file Controller.cs.}\par
}
{\xe \v GetInterpolatedFrame\:Leap.Controller}
{\xe \v Leap.Controller\:GetInterpolatedFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.GetInterpolatedFrame ({\b Frame}  {\i toFill}, Int64  {\i time})}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the {\b Frame} with data taken at the specified time, interpolating the data between existing frames, if necessary. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 538 of file Controller.cs.}\par
}
{\xe \v GetInterpolatedFrameFromTime\:Leap.Controller}
{\xe \v Leap.Controller\:GetInterpolatedFrameFromTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.GetInterpolatedFrameFromTime ({\b Frame}  {\i toFill}, Int64  {\i time}, Int64  {\i sourceTime})}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 583 of file Controller.cs.}\par
}
{\xe \v GetInterpolatedHeadPose\:Leap.Controller}
{\xe \v Leap.Controller\:GetInterpolatedHeadPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LEAP_HEAD_POSE_EVENT} Leap.Controller.GetInterpolatedHeadPose (Int64  {\i time})}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Head pose at the specified time, interpolating the data between existing frames, if necessary. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 545 of file Controller.cs.}\par
}
{\xe \v GetInterpolatedHeadPose\:Leap.Controller}
{\xe \v Leap.Controller\:GetInterpolatedHeadPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.GetInterpolatedHeadPose (ref {\b LEAP_HEAD_POSE_EVENT}  {\i toFill}, Int64  {\i time})}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 549 of file Controller.cs.}\par
}
{\xe \v GetInterpolatedLeftRightTransform\:Leap.Controller}
{\xe \v Leap.Controller\:GetInterpolatedLeftRightTransform}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.GetInterpolatedLeftRightTransform (Int64  {\i time}, Int64  {\i sourceTime}, int  {\i leftId}, int  {\i rightId}, out {\b LeapTransform}  {\i leftTransform}, out {\b LeapTransform}  {\i rightTransform})}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a special variant of GetInterpolatedFrameFromTime, for use with special features that only require the position and orientation of the palm positions, and do not care about pose data or any other data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You must specify the id of the hand that you wish to get a transform for. If you specify an id that is not present in the interpolated frame, the output transform will be the identity transform. \par
}{
Definition at line 574 of file Controller.cs.}\par
}
{\xe \v GetPointMapping\:Leap.Controller}
{\xe \v Leap.Controller\:GetPointMapping}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.GetPointMapping (ref {\b PointMapping}  {\i pointMapping})}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 561 of file Controller.cs.}\par
}
{\xe \v GetTransformedFrame\:Leap.Controller}
{\xe \v Leap.Controller\:GetTransformedFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Frame} Leap.Controller.GetTransformedFrame ({\b LeapTransform}  {\i trs}, int  {\i history} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the frame object with all hands transformed by the specified transform matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 524 of file Controller.cs.}\par
}
{\xe \v IsPolicySet\:Leap.Controller}
{\xe \v Leap.Controller\:IsPolicySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Controller.IsPolicySet ({\b PolicyFlag}  {\i policy})}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the active setting for a specific policy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Keep in mind that setting a policy flag is asynchronous, so changes are not effective immediately after calling setPolicyFlag(). In addition, a policy request can be declined by the user. You should always set the policy flags required by your application at startup and check that the policy change request was successful after an appropriate interval.\par
If the controller object is not connected to the {\b Leap} Motion software, then the default state for the selected policy is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 2.1.6 \par
}}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 468 of file Controller.cs.}\par
}
{\xe \v Now\:Leap.Controller}
{\xe \v Leap.Controller\:Now}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long Leap.Controller.Now ()}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a timestamp value as close as possible to the current time. Values are in microseconds, as with all the other timestamp values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 2.2.7 \par
}}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABQX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 593 of file Controller.cs.}\par
}
{\xe \v OnConnect\:Leap.Controller}
{\xe \v Leap.Controller\:OnConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Controller.OnConnect (object  {\i sender}, {\b ConnectionEventArgs}  {\i eventArgs}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 721 of file Controller.cs.}\par
}
{\xe \v OnDisconnect\:Leap.Controller}
{\xe \v Leap.Controller\:OnDisconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Controller.OnDisconnect (object  {\i sender}, {\b ConnectionLostEventArgs}  {\i eventArgs}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 725 of file Controller.cs.}\par
}
{\xe \v OnInit\:Leap.Controller}
{\xe \v Leap.Controller\:OnInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Controller.OnInit (object  {\i sender}, {\b LeapEventArgs}  {\i eventArgs}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 717 of file Controller.cs.}\par
}
{\xe \v SetPolicy\:Leap.Controller}
{\xe \v Leap.Controller\:SetPolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.SetPolicy ({\b PolicyFlag}  {\i policy})}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Requests setting a policy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A request to change a policy is subject to user approval and a policy can be changed by the user at any time (using the {\b Leap} Motion settings dialog). The desired policy flags must be set every time an application runs.\par
Policy changes are completed asynchronously and, because they are subject to user approval or system compatibility checks, may not complete successfully. Call {\b Controller.IsPolicySet()} after a suitable interval to test whether the change was accepted. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 2.1.6 \par
}}{
Implements {\b Leap.IController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABRC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 437 of file Controller.cs.}\par
}
{\xe \v StartConnection\:Leap.Controller}
{\xe \v Leap.Controller\:StartConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.StartConnection ()}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Starts the connection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A connection starts automatically when created, but you can use this function to restart the connection after stopping it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 397 of file Controller.cs.}\par
}
{\xe \v StopConnection\:Leap.Controller}
{\xe \v Leap.Controller\:StopConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.StopConnection ()}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stops the connection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No more frames or other events are received from a stopped connection. You can restart with {\b StartConnection()}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 409 of file Controller.cs.}\par
}
{\xe \v TelemetryGetNow\:Leap.Controller}
{\xe \v Leap.Controller\:TelemetryGetNow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
UInt64 Leap.Controller.TelemetryGetNow ()}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 557 of file Controller.cs.}\par
}
{\xe \v TelemetryProfiling\:Leap.Controller}
{\xe \v Leap.Controller\:TelemetryProfiling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Controller.TelemetryProfiling (ref {\b LEAP_TELEMETRY_DATA}  {\i telemetryData})}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 553 of file Controller.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v BeginProfilingBlock\:Leap.Controller}
{\xe \v Leap.Controller\:BeginProfilingBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b BeginProfilingBlockArgs}> Leap.Controller.BeginProfilingBlock{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread enters a profiling block. The event is always dispatched from the thread itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The event data will contain the name of the profiling block.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 4.0 \par
}}{
Definition at line 292 of file Controller.cs.}\par
}
{\xe \v BeginProfilingForThread\:Leap.Controller}
{\xe \v Leap.Controller\:BeginProfilingForThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b BeginProfilingForThreadArgs}> Leap.Controller.BeginProfilingForThread{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread wants to start profiling for a custom thread. The event is always dispatched from the thread itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The event data will contain the name of the thread, as well as an array of all possible profiling blocks that could be entered on that thread.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 4.0 \par
}}{
Definition at line 260 of file Controller.cs.}\par
}
{\xe \v Config\:Leap.Controller}
{\xe \v Leap.Controller\:Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Config} Leap.Controller.Config{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b Config} object, which you can use to query the {\b Leap} Motion system for configuration information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{
Definition at line 624 of file Controller.cs.}\par
}
{\xe \v ConfigChange\:Leap.Controller}
{\xe \v Leap.Controller\:ConfigChange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b ConfigChangeEventArgs}> Leap.Controller.ConfigChange{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a configuration setting changes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 202 of file Controller.cs.}\par
}
{\xe \v Connect\:Leap.Controller}
{\xe \v Leap.Controller\:Connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b ConnectionEventArgs}> Leap.Controller.Connect{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the connection to the service is established. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 82 of file Controller.cs.}\par
}
{\xe \v Device\:Leap.Controller}
{\xe \v Leap.Controller\:Device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b DeviceEventArgs}> Leap.Controller.Device{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a {\b Leap} Motion device is connected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 137 of file Controller.cs.}\par
}
{\xe \v DeviceFailure\:Leap.Controller}
{\xe \v Leap.Controller\:DeviceFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b DeviceFailureEventArgs}> Leap.Controller.DeviceFailure{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a {\b Leap} device fails to initialize. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 163 of file Controller.cs.}\par
}
{\xe \v DeviceLost\:Leap.Controller}
{\xe \v Leap.Controller\:DeviceLost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b DeviceEventArgs}> Leap.Controller.DeviceLost{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a {\b Leap} Motion device is disconnected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 150 of file Controller.cs.}\par
}
{\xe \v Devices\:Leap.Controller}
{\xe \v Leap.Controller\:Devices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DeviceList} Leap.Controller.Devices{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The list of currently attached and recognized {\b Leap} Motion controller devices. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Device} objects in the list describe information such as the range and tracking volume.\par
Currently, the {\b Leap} Motion {\b Controller} only allows a single active device at a time, however there may be multiple devices physically attached and listed here. Any active device(s) are guaranteed to be listed first, however order is not determined beyond that.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{
Definition at line 644 of file Controller.cs.}\par
}
{\xe \v Disconnect\:Leap.Controller}
{\xe \v Leap.Controller\:Disconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b ConnectionLostEventArgs}> Leap.Controller.Disconnect{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched if the connection to the service is lost. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 98 of file Controller.cs.}\par
}
{\xe \v DistortionChange\:Leap.Controller}
{\xe \v Leap.Controller\:DistortionChange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b DistortionEventArgs}> Leap.Controller.DistortionChange{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the image distortion map changes. The distortion map can change when the {\b Leap} device switches orientation, or a new device becomes active. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 217 of file Controller.cs.}\par
}
{\xe \v DroppedFrame\:Leap.Controller}
{\xe \v Leap.Controller\:DroppedFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b DroppedFrameEventArgs}> Leap.Controller.DroppedFrame{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the service drops a tracking frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 229 of file Controller.cs.}\par
}
{\xe \v EndProfilingBlock\:Leap.Controller}
{\xe \v Leap.Controller\:EndProfilingBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b EndProfilingBlockArgs}> Leap.Controller.EndProfilingBlock{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread ends a profiling block. The event is always dispatched from the thread itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The event data will contain the name of the profiling block.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 4.0 \par
}}{
Definition at line 309 of file Controller.cs.}\par
}
{\xe \v EndProfilingForThread\:Leap.Controller}
{\xe \v Leap.Controller\:EndProfilingForThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b EndProfilingForThreadArgs}> Leap.Controller.EndProfilingForThread{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched whenever a thread is finished profiling. The event is always dispatched from the thread itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 4.0 \par
}}{
Definition at line 275 of file Controller.cs.}\par
}
{\xe \v EventContext\:Leap.Controller}
{\xe \v Leap.Controller\:EventContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SynchronizationContext Leap.Controller.EventContext{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The SynchronizationContext used for dispatching events. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default the synchronization context of the thread creating the controller instance is used. You can change the context if desired. \par
}{
Definition at line 51 of file Controller.cs.}\par
}
{\xe \v FrameReady\:Leap.Controller}
{\xe \v Leap.Controller\:FrameReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b FrameEventArgs}> Leap.Controller.FrameReady{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a tracking frame is ready. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 111 of file Controller.cs.}\par
}
{\xe \v HeadPoseChange\:Leap.Controller}
{\xe \v Leap.Controller\:HeadPoseChange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b HeadPoseEventArgs}> Leap.Controller.HeadPoseChange{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a new HeadPose is available. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 334 of file Controller.cs.}\par
}
{\xe \v ImageReady\:Leap.Controller}
{\xe \v Leap.Controller\:ImageReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b ImageEventArgs}> Leap.Controller.ImageReady{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when an unrequested image is ready. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 4.0 \par
}}{
Definition at line 242 of file Controller.cs.}\par
}
{\xe \v Init\:Leap.Controller}
{\xe \v Leap.Controller\:Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b LeapEventArgs}> Leap.Controller.Init{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the connection is initialized (but not necessarily connected). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can be dispatched more than once, if connection is restarted. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 66 of file Controller.cs.}\par
}
{\xe \v InternalFrameReady\:Leap.Controller}
{\xe \v Leap.Controller\:InternalFrameReady}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b InternalFrameEventArgs}> Leap.Controller.InternalFrameReady{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when an internal tracking frame is ready. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 124 of file Controller.cs.}\par
}
{\xe \v IsConnected\:Leap.Controller}
{\xe \v Leap.Controller\:IsConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Controller.IsConnected{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reports whether this {\b Controller} is connected to the {\b Leap} Motion service and the {\b Leap} Motion hardware is plugged in. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When you first create a {\b Controller} object, isConnected() returns false. After the controller finishes initializing and connects to the {\b Leap} Motion software and if the {\b Leap} Motion hardware is plugged in, isConnected() returns true.\par
You can either handle the onConnect event using a Listener instance or poll the isConnected() function if you need to wait for your application to be connected to the {\b Leap} Motion software before performing some other operation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.0 \par
}}{
Definition at line 612 of file Controller.cs.}\par
}
{\xe \v IsServiceConnected\:Leap.Controller}
{\xe \v Leap.Controller\:IsServiceConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Controller.IsServiceConnected{\f2 [get]}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reports whether your application has a connection to the {\b Leap} Motion daemon/service. Can be true even if the {\b Leap} Motion hardware is not available. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 1.2 \par
}}{
Definition at line 418 of file Controller.cs.}\par
}
{\xe \v LogMessage\:Leap.Controller}
{\xe \v Leap.Controller\:LogMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b LogEventArgs}> Leap.Controller.LogMessage{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when the system generates a loggable event. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 176 of file Controller.cs.}\par
}
{\xe \v PointMappingChange\:Leap.Controller}
{\xe \v Leap.Controller\:PointMappingChange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b PointMappingChangeEventArgs}> Leap.Controller.PointMappingChange{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when point mapping change events are generated by the service. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 4.0 \par
}}{
Definition at line 322 of file Controller.cs.}\par
}
{\xe \v PolicyChange\:Leap.Controller}
{\xe \v Leap.Controller\:PolicyChange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EventHandler<{\b PolicyEventArgs}> Leap.Controller.PolicyChange{\f2 [add]}, {\f2 [remove]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dispatched when a policy changes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid 3.0 \par
}}{
Definition at line 189 of file Controller.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
O:/GitHUBMINIPRoject/Assets/LeapMotion/Core/Plugins/LeapCSharp/{\b Controller.cs}\par
}}