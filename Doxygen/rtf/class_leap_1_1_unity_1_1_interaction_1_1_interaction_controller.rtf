{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Leap.Unity.Interaction.InteractionController Class Reference\par \pard\plain 
{\tc\tcl2 \v Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController}
{\bkmkstart AAAAAAAFEX}
{\bkmkend AAAAAAAFEX}
Inheritance diagram for Leap.Unity.Interaction.InteractionController:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_leap_1_1_unity_1_1_interaction_1_1_interaction_controller.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GizmoColors}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NotifyObjectUnregistered} ({\b IInteractionBehaviour} intObj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b LockPrimaryHover} ({\b InteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the argument interaction object to be the current primary hover of this interaction controller and locks the primary hover state of the interaction controller. {\b primaryHoverLocked} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearHoverTracking} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all hover tracking state and fires the hover-end callbacks immediately. If objects are still in the hover radius around this controller and the controller and manager are still active, HoverBegin callbacks will be invoked again on the next fixed frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearHoverTrackingForObject} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the hover tracking state for an object and fires the hover-end callback for that object immediately. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearPrimaryHoverTracking} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears primary hover tracking state for the current primary hovered object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EnableSoftContact} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DisableSoftContact} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NotifySoftContactCollisionEnter} ({\b ContactBone} bone, {\b IInteractionBehaviour} intObj, Collider collider)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NotifySoftContactCollisionExit} ({\b ContactBone} bone, {\b IInteractionBehaviour} intObj, Collider collider)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NotifyContactBoneCollisionEnter} ({\b ContactBone} contactBone, {\b IInteractionBehaviour} interactionObj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NotifyContactBoneCollisionStay} ({\b ContactBone} contactBone, {\b IInteractionBehaviour} interactionObj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NotifyContactBoneCollisionExit} ({\b ContactBone} contactBone, {\b IInteractionBehaviour} interactionObj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearContactTracking} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears contact state for this controller and fires the appropriate ContactEnd callbacks on currently-contacted interaction objects immediately. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearContactTrackingForObject} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears contact state for the specified object and fires its ContactEnd callbacks immediately. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract Vector3 {\b GetGraspPoint} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns approximately where the controller is grasping the currently grasped {\b InteractionBehaviour}. This method will print an error if the controller is not currently grasping an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b TryGrasp} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the provided interaction object can be grasped by this interaction controller in its current state. If so, the controller will initiate a grasp and this method will return true, otherwise this method returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SwapGrasp} ({\b IInteractionBehaviour} replacement)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seamlessly swap the currently grasped object for a replacement object. It will behave like the hand released the current object, and then grasped the new object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ReleaseGrasp} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases the object this hand is holding and returns true if the hand was holding an object, or false if there was no object to release. The released object will dispatch {\b OnGraspEnd()} immediately. The hand is guaranteed not to be holding an object directly after this method is called. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ReleaseGrasp} (out {\b IInteractionBehaviour} releasedObject)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As {\b ReleaseGrasp()}, but also outputs the released object into releasedObject if the hand successfully released an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ReleaseObject} ({\b IInteractionBehaviour} toRelease)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to release this hand's object, but only if the argument object is the object currently grasped by this hand. If the hand was holding the argument object, returns true, otherwise returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnDrawRuntimeGizmos} ({\b RuntimeGizmoDrawer} drawer)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, this method will draw all of the colliders found in the contactBoneParent hierarchy, or draw the controller's soft contact representation when in soft contact mode. Optionally override this method to modify its behavior. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static float {\b GetHoverDistance} (Vector3 {\b hoverPoint}, {\b IInteractionBehaviour} behaviour)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the hover distance from the hoverPoint to the specified object, automatically accounting for ISpaceComponent warping if necessary. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static Vector3 {\b TransformPoint} (Vector3 worldPoint, {\b ISpaceComponent} element)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the spatial warping of the provided ISpaceComponent to a world-space point. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ReleaseGrasps} ({\b IInteractionBehaviour} graspedObj, {\b ReadonlyHashSet}< {\b InteractionController} > controllers)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper static method for forcing multiple controllers to release their grasps on a single object simultaneously. All of the provided controllers must be grasping the argument interaction object. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InteractionManager} {\b manager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionBehaviour} > {\b OnBeginPrimaryHoveringObject} = (intObj) => \{ \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when this {\b InteractionController} begins primarily hovering over an {\b InteractionBehaviour}. If the controller transitions to primarily hovering a new object, OnEndPrimaryHoveringObject will first be called on the old object, then OnBeginPrimaryHoveringObject will be called for the new object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionBehaviour} > {\b OnEndPrimaryHoveringObject} = (intObj) => \{ \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when this {\b InteractionController} stops primarily hovering over an {\b InteractionBehaviour}. If the controller transitions to primarily-hovering a new object, OnEndPrimaryHoveringObject will first be called on the old object, then OnBeginPrimaryHoveringObject will be called for the new object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionBehaviour} > {\b OnStayPrimaryHoveringObject} = (intObj) => \{ \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every (fixed) frame this {\b InteractionController} is primarily hovering over an {\b InteractionBehaviour}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnGraspBegin} = () => \{ \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the {\b InteractionController} begins grasping an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnGraspStay} = () => \{ \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called while the {\b InteractionController} is grasping an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnGraspEnd} = () => \{ \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the {\b InteractionController} releases an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Func< {\b IInteractionBehaviour}, bool > {\b customHoverActivityFilter} = null\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In addition to standard hover validity checks, you can set this filter property to further filter objects for hover consideration. Only objects for which this function returns true will be hover candidates (if the filter is not null). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnable} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Start} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnDisable} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b onObjectUnregistered} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called by the {\b InteractionController} when it is notified by the {\b InteractionManager} that an {\b InteractionBehaviour} has been unregistered from the {\b Interaction} Engine. If your controller has any state that remembers or tracks interaction objects, this method should clear that state, because unregistered objects won't receive state updates or callbacks from this controller's {\b Interaction} Manager anymore. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b fixedUpdateController} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called just before the {\b InteractionController} proceeds with its usual FixedUpdate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b unwarpColliders} (Transform primaryHoverPoint, {\b ISpaceComponent} warpedSpaceElement)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementing this method is necessary to support curved spaces as rendered by a {\b Leap} Graphic Renderer. See {\b InteractionHand} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a {\b Leap} Graphic Renderer.) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b initContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called to initialize contact colliders. See remarks for implementation requirements. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b getColliderBoneTargetPositionRotation} (int contactBoneIndex, out Vector3 targetPosition, out Quaternion targetRotation)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array. (For example, by recording the local position and local rotation of each contact bone in {\b initContact()}). More complex controllers, such as {\b InteractionHand}, uses this method to set {\b ContactBone} target positions and rotations based on the tracked {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b onPreEnableSoftContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before soft contact is enabled for this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b onPostDisableSoftContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just after soft contact is disabled for this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b checkShouldGraspAtemporal} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the provided interaction object can be grasped by this interaction controller in its current state. If so, the controller will initiate a grasp and this method will return true, otherwise this method returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b fixedUpdateGraspingState} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed frame if grasping is enabled in the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b onGraspedObjectForciblyReleased} ({\b IInteractionBehaviour} objectToBeReleased)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before a grasped object is released because it is no longer eligible to be grasped by this controller or {\b ReleaseGrasp()} was manually called on the controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b checkShouldGrasp} (out {\b IInteractionBehaviour} objectToGrasp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b checkShouldRelease} (out {\b IInteractionBehaviour} objectToRelease)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b drawHoverPoint} ({\b RuntimeGizmoDrawer} drawer, Vector3 pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b drawPrimaryHoverPoint} ({\b RuntimeGizmoDrawer} drawer, Vector3 pos)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b DEAD_ZONE_FRACTION} = 0.04F\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b lastObjectTouchedAdjustedMassMass} = 0.2f\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hoverEnabled}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contactEnabled}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b graspingEnabled}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b isTracked}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) is currently in a tracked state. Objects grasped by a controller that becomes untracked will become "suspended" and receive specific suspension callbacks. (Implementing any behaviour during the suspension state is left up to the developer, however.) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b isBeingMoved}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) is currently being moved or being actively manipulated by the player. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract bool {\b isLeft}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) represents or is held by a left hand (true) or a right hand (false). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isRight}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) represents or is held by a right hand (true) or a left hand (false). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract Vector3 {\b position}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current position of this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract Quaternion {\b rotation}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current rotation of this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract Vector3 {\b velocity}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current velocity of this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract {\b ControllerType} {\b controllerType}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the type of controller this object represents underneath the {\b InteractionController} abstraction. If the type is {\b ControllerType.Hand}, the intHand property will contain the {\b InteractionHand} object this object abstracts from. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract {\b InteractionHand} {\b intHand}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this {\b InteractionController}'s controllerType is {\b ControllerType.Hand}, this gets the {\b InteractionHand}, otherwise this returns null. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b scale}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contact requires knowledge of the controller's scale. Non-uniformly scaled controllers are NOT supported. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ActivityManager}< {\b IInteractionBehaviour} > {\b hoverActivityManager}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b primaryHoverLocked}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When set to true, locks the current primarily hovered object, even if the hand gets closer to a different object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract Vector3 {\b hoverPoint}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current position to check against nearby objects for hovering. Position is only used if the controller is currently tracked. For example, {\b InteractionHand} returns the center of the palm of the underlying {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b IInteractionBehaviour} > {\b hoveredObjects}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a set of all {\b Interaction} objects currently hovered by this {\b InteractionController}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract List< Transform > {\b _primaryHoverPoints}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyList}< Transform > {\b primaryHoverPoints}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the list of Transforms to consider against nearby objects to determine the closest object (primary hover) of this controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPrimaryHovering}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the {\b InteractionController} is currently primarily hovering over any interaction object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IInteractionBehaviour} {\b primaryHoveredObject}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the {\b InteractionBehaviour} that is currently this {\b InteractionController}'s primary hovered object, if there is one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b primaryHoverDistance}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the distance from the closest primary hover point on this controller to its primarily hovered object, if there are any. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Vector3? {\b primaryHoveringPoint}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the position of the primary hovering point that is closest to its primary hovered object, if this controller has a primary hover. Otherwise, returns Vector3.zero. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b primaryHoveringPointIndex}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the index in the primaryHoverPoints array of the primary hover point that is currently closest to this controller's primary hover object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b IInteractionBehaviour} > {\b contactingObjects}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of interaction objects that are currently touching this interaction controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b softContactDislocationDistance}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static PhysicMaterial {\b defaultContactBoneMaterial}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b _wasContactInitialized}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract {\b ContactBone} [] {\b contactBones}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract GameObject {\b contactBoneParent}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b softContactEnabled}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isGraspingObject}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the controller is currently grasping an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IInteractionBehaviour} {\b graspedObject}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the object the controller is currently grasping, or null if there is no such object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b IInteractionBehaviour} > {\b graspCandidates}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of objects currently considered graspable. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract List< Vector3 > {\b graspManipulatorPoints}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the points of the controller to add to the calculation to determine how held objects should move as the controller moves. {\b Interaction} Controllers utilize the Kabsch algorithm to determine this, which is most noticeable when using {\b Leap} hands via InteractionHands to manipulate held objects. Rigid controllers may simply return a single rigid point on the controller. Refer to {\b InteractionHand} for a reference implementation for dynamic controllers (e.g. hands). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 39 of file InteractionController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v checkShouldGrasp\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:checkShouldGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.checkShouldGrasp (out {\b IInteractionBehaviour}  {\i objectToGrasp}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFEY}
{\bkmkend AAAAAAAFEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFEZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v checkShouldGraspAtemporal\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:checkShouldGraspAtemporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.checkShouldGraspAtemporal ({\b IInteractionBehaviour}  {\i intObj}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFFB}
{\bkmkend AAAAAAAFFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the provided interaction object can be grasped by this interaction controller in its current state. If so, the controller will initiate a grasp and this method will return true, otherwise this method returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is useful if the controller requires conditions to initiate a grasp that differ from the conditions necessary to maintain a grasp after it has been initiated. This method allows a grasp to occur if certain initiation conditions are not met, such as the motion of a hand's fingers towards the palm, but if the grasp holding conditions are met, such as the penetration of a hand's fingers inside the interaction object. \par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v checkShouldRelease\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:checkShouldRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.checkShouldRelease (out {\b IInteractionBehaviour}  {\i objectToRelease}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFFE}
{\bkmkend AAAAAAAFFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFF \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ClearContactTracking\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ClearContactTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.ClearContactTracking ()}}
\par
{\bkmkstart AAAAAAAFFH}
{\bkmkend AAAAAAAFFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears contact state for this controller and fires the appropriate ContactEnd callbacks on currently-contacted interaction objects immediately. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the controller is still contacting objects and it and its manager are still active, contact will begin anew on the next fixed frame. \par
}{
Definition at line 1480 of file InteractionController.cs.}\par
}
{\xe \v ClearContactTrackingForObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ClearContactTrackingForObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.ClearContactTrackingForObject ({\b IInteractionBehaviour}  {\i intObj})}}
\par
{\bkmkstart AAAAAAAFFI}
{\bkmkend AAAAAAAFFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears contact state for the specified object and fires its ContactEnd callbacks immediately. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the controller is still contacting the object and it and its manager are still active, contact will begin anew on the next fixed frame. \par
}{
Definition at line 1510 of file InteractionController.cs.}\par
}
{\xe \v ClearHoverTracking\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ClearHoverTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.ClearHoverTracking ()}}
\par
{\bkmkstart AAAAAAAFFJ}
{\bkmkend AAAAAAAFFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all hover tracking state and fires the hover-end callbacks immediately. If objects are still in the hover radius around this controller and the controller and manager are still active, HoverBegin callbacks will be invoked again on the next fixed frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 615 of file InteractionController.cs.}\par
}
{\xe \v ClearHoverTrackingForObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ClearHoverTrackingForObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.ClearHoverTrackingForObject ({\b IInteractionBehaviour}  {\i intObj})}}
\par
{\bkmkstart AAAAAAAFFK}
{\bkmkend AAAAAAAFFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the hover tracking state for an object and fires the hover-end callback for that object immediately. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the object is still in the hover radius of this controller and the controller and manager are still active, the hover will begin anew on the next fixed frame. \par
}{
Definition at line 649 of file InteractionController.cs.}\par
}
{\xe \v ClearPrimaryHoverTracking\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ClearPrimaryHoverTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.ClearPrimaryHoverTracking ()}}
\par
{\bkmkstart AAAAAAAFFL}
{\bkmkend AAAAAAAFFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears primary hover tracking state for the current primary hovered object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the current primary hover is still the most eligible hovered object and this controller and its manager are still active, primary hover will begin anew on the next fixed frame. \par
}{
Definition at line 745 of file InteractionController.cs.}\par
}
{\xe \v DisableSoftContact\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:DisableSoftContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.DisableSoftContact ()}}
\par
{\bkmkstart AAAAAAAFFM}
{\bkmkend AAAAAAAFFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1328 of file InteractionController.cs.}\par
}
{\xe \v drawHoverPoint\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:drawHoverPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void Leap.Unity.Interaction.InteractionController.drawHoverPoint ({\b RuntimeGizmoDrawer}  {\i drawer}, Vector3  {\i pos}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFFN}
{\bkmkend AAAAAAAFFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2094 of file InteractionController.cs.}\par
}
{\xe \v drawPrimaryHoverPoint\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:drawPrimaryHoverPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void Leap.Unity.Interaction.InteractionController.drawPrimaryHoverPoint ({\b RuntimeGizmoDrawer}  {\i drawer}, Vector3  {\i pos}){\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFFO}
{\bkmkend AAAAAAAFFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2099 of file InteractionController.cs.}\par
}
{\xe \v EnableSoftContact\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:EnableSoftContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.EnableSoftContact ()}}
\par
{\bkmkstart AAAAAAAFFP}
{\bkmkend AAAAAAAFFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1304 of file InteractionController.cs.}\par
}
{\xe \v fixedUpdateController\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:fixedUpdateController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.fixedUpdateController (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFQ}
{\bkmkend AAAAAAAFFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called just before the {\b InteractionController} proceeds with its usual FixedUpdate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's generally better to override this method instead of having your {\b InteractionController} implement FixedUpdate because its execution order relative to the {\b Interaction} Manager is fixed. \par
}{
Reimplemented in {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 286 of file InteractionController.cs.}\par
}
{\xe \v fixedUpdateGraspingState\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:fixedUpdateGraspingState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void Leap.Unity.Interaction.InteractionController.fixedUpdateGraspingState (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFFT}
{\bkmkend AAAAAAAFFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed frame if grasping is enabled in the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
graspActivityManager.ActiveObjects will contain objects around the hoverPoint within the grasping radius \'96 in other words, objects eligible to be grasped by the controller. Refer to it to avoid checking grasp eligibility against all graspable objects in your scene. \par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getColliderBoneTargetPositionRotation\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:getColliderBoneTargetPositionRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void Leap.Unity.Interaction.InteractionController.getColliderBoneTargetPositionRotation (int  {\i contactBoneIndex}, out Vector3  {\i targetPosition}, out Quaternion  {\i targetRotation}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFFW}
{\bkmkend AAAAAAAFFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array. (For example, by recording the local position and local rotation of each contact bone in {\b initContact()}). More complex controllers, such as {\b InteractionHand}, uses this method to set {\b ContactBone} target positions and rotations based on the tracked {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v GetGraspPoint\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:GetGraspPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract Vector3 Leap.Unity.Interaction.InteractionController.GetGraspPoint (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFFZ}
{\bkmkend AAAAAAAFFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns approximately where the controller is grasping the currently grasped {\b InteractionBehaviour}. This method will print an error if the controller is not currently grasping an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v GetHoverDistance\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:GetHoverDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static float Leap.Unity.Interaction.InteractionController.GetHoverDistance (Vector3  {\i hoverPoint}, {\b IInteractionBehaviour}  {\i behaviour}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAFGC}
{\bkmkend AAAAAAAFGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the hover distance from the hoverPoint to the specified object, automatically accounting for ISpaceComponent warping if necessary. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 838 of file InteractionController.cs.}\par
}
{\xe \v initContact\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:initContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.initContact (){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFGD}
{\bkmkend AAAAAAAFGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called to initialize contact colliders. See remarks for implementation requirements. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b initContact()} should:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Return false at any time if initialization cannot be performed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ensure the "contactBones" property returns all contact colliders.{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
(Construct contact colliders if they don't already exist.)\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ensure the "contactBoneParent" property returns the common parent of all contact colliders.{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
(Construct the contact bone parent if it doesn't already exist.)\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Return true if initialization was successful.\par}
Contact will only begin updating after initialization succeeds, otherwise it will try to initialize again on the next fixed frame.\par
After initialization, the contact bone parent's layer will be set to the {\b Interaction} Manager's contactBoneLayer. \par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v LockPrimaryHover\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:LockPrimaryHover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.LockPrimaryHover ({\b InteractionBehaviour}  {\i intObj})}}
\par
{\bkmkstart AAAAAAAFGG}
{\bkmkend AAAAAAAFGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the argument interaction object to be the current primary hover of this interaction controller and locks the primary hover state of the interaction controller. {\b primaryHoverLocked} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 351 of file InteractionController.cs.}\par
}
{\xe \v NotifyContactBoneCollisionEnter\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:NotifyContactBoneCollisionEnter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.NotifyContactBoneCollisionEnter ({\b ContactBone}  {\i contactBone}, {\b IInteractionBehaviour}  {\i interactionObj})}}
\par
{\bkmkstart AAAAAAAFGH}
{\bkmkend AAAAAAAFGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1431 of file InteractionController.cs.}\par
}
{\xe \v NotifyContactBoneCollisionExit\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:NotifyContactBoneCollisionExit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.NotifyContactBoneCollisionExit ({\b ContactBone}  {\i contactBone}, {\b IInteractionBehaviour}  {\i interactionObj})}}
\par
{\bkmkstart AAAAAAAFGI}
{\bkmkend AAAAAAAFGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1453 of file InteractionController.cs.}\par
}
{\xe \v NotifyContactBoneCollisionStay\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:NotifyContactBoneCollisionStay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.NotifyContactBoneCollisionStay ({\b ContactBone}  {\i contactBone}, {\b IInteractionBehaviour}  {\i interactionObj})}}
\par
{\bkmkstart AAAAAAAFGJ}
{\bkmkend AAAAAAAFGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1442 of file InteractionController.cs.}\par
}
{\xe \v NotifyObjectUnregistered\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:NotifyObjectUnregistered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.NotifyObjectUnregistered ({\b IInteractionBehaviour}  {\i intObj})}}
\par
{\bkmkstart AAAAAAAFGK}
{\bkmkend AAAAAAAFGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 262 of file InteractionController.cs.}\par
}
{\xe \v NotifySoftContactCollisionEnter\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:NotifySoftContactCollisionEnter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.NotifySoftContactCollisionEnter ({\b ContactBone}  {\i bone}, {\b IInteractionBehaviour}  {\i intObj}, Collider  {\i collider})}}
\par
{\bkmkstart AAAAAAAFGL}
{\bkmkend AAAAAAAFGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1389 of file InteractionController.cs.}\par
}
{\xe \v NotifySoftContactCollisionExit\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:NotifySoftContactCollisionExit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionController.NotifySoftContactCollisionExit ({\b ContactBone}  {\i bone}, {\b IInteractionBehaviour}  {\i intObj}, Collider  {\i collider})}}
\par
{\bkmkstart AAAAAAAFGM}
{\bkmkend AAAAAAAFGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1400 of file InteractionController.cs.}\par
}
{\xe \v OnDisable\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.OnDisable (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGN}
{\bkmkend AAAAAAAFGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 234 of file InteractionController.cs.}\par
}
{\xe \v OnDrawRuntimeGizmos\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnDrawRuntimeGizmos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.OnDrawRuntimeGizmos ({\b RuntimeGizmoDrawer}  {\i drawer}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGO}
{\bkmkend AAAAAAAFGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, this method will draw all of the colliders found in the contactBoneParent hierarchy, or draw the controller's soft contact representation when in soft contact mode. Optionally override this method to modify its behavior. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 2066 of file InteractionController.cs.}\par
}
{\xe \v OnEnable\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.OnEnable (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGP}
{\bkmkend AAAAAAAFGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 222 of file InteractionController.cs.}\par
}
{\xe \v onGraspedObjectForciblyReleased\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:onGraspedObjectForciblyReleased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.onGraspedObjectForciblyReleased ({\b IInteractionBehaviour}  {\i objectToBeReleased}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGQ}
{\bkmkend AAAAAAAFGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before a grasped object is released because it is no longer eligible to be grasped by this controller or {\b ReleaseGrasp()} was manually called on the controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Reimplemented in {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1802 of file InteractionController.cs.}\par
}
{\xe \v onObjectUnregistered\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:onObjectUnregistered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void Leap.Unity.Interaction.InteractionController.onObjectUnregistered ({\b IInteractionBehaviour}  {\i intObj}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFGS}
{\bkmkend AAAAAAAFGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is called by the {\b InteractionController} when it is notified by the {\b InteractionManager} that an {\b InteractionBehaviour} has been unregistered from the {\b Interaction} Engine. If your controller has any state that remembers or tracks interaction objects, this method should clear that state, because unregistered objects won't receive state updates or callbacks from this controller's {\b Interaction} Manager anymore. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v onPostDisableSoftContact\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:onPostDisableSoftContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.onPostDisableSoftContact (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGV}
{\bkmkend AAAAAAAFGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just after soft contact is disabled for this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InteractionHand} implementation takes the opportunity to reset its contact bone's joints, which my have initialized slightly out of alignment on initial construction. \par
}{
Reimplemented in {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1302 of file InteractionController.cs.}\par
}
{\xe \v onPreEnableSoftContact\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:onPreEnableSoftContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.onPreEnableSoftContact (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGX}
{\bkmkend AAAAAAAFGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally override this method to perform logic just before soft contact is enabled for this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InteractionHand} implementation takes the opportunity to reset its contact bone's joints, which may have initialized slightly out of alignment on initial construction. \par
}{
Reimplemented in {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1292 of file InteractionController.cs.}\par
}
{\xe \v ReleaseGrasp\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ReleaseGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.ReleaseGrasp ()}}
\par
{\bkmkstart AAAAAAAFGZ}
{\bkmkend AAAAAAAFGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases the object this hand is holding and returns true if the hand was holding an object, or false if there was no object to release. The released object will dispatch {\b OnGraspEnd()} immediately. The hand is guaranteed not to be holding an object directly after this method is called. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1823 of file InteractionController.cs.}\par
}
{\xe \v ReleaseGrasp\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ReleaseGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.ReleaseGrasp (out {\b IInteractionBehaviour}  {\i releasedObject})}}
\par
{\bkmkstart AAAAAAAFHA}
{\bkmkend AAAAAAAFHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As {\b ReleaseGrasp()}, but also outputs the released object into releasedObject if the hand successfully released an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1911 of file InteractionController.cs.}\par
}
{\xe \v ReleaseGrasps\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ReleaseGrasps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void Leap.Unity.Interaction.InteractionController.ReleaseGrasps ({\b IInteractionBehaviour}  {\i graspedObj}, {\b ReadonlyHashSet}< {\b InteractionController} >  {\i controllers}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAFHB}
{\bkmkend AAAAAAAFHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper static method for forcing multiple controllers to release their grasps on a single object simultaneously. All of the provided controllers must be grasping the argument interaction object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<details> The input controllers List is copied to a temporary (pooled) buffer before release operations are actually carried out. This prevents errors that might arise from modifying a held-controllers list while enumerating through the same list. </details> \par
}{
Definition at line 1863 of file InteractionController.cs.}\par
}
{\xe \v ReleaseObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:ReleaseObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.ReleaseObject ({\b IInteractionBehaviour}  {\i toRelease})}}
\par
{\bkmkstart AAAAAAAFHC}
{\bkmkend AAAAAAAFHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to release this hand's object, but only if the argument object is the object currently grasped by this hand. If the hand was holding the argument object, returns true, otherwise returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1927 of file InteractionController.cs.}\par
}
{\xe \v Reset\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.Reset (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHD}
{\bkmkend AAAAAAAFHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 218 of file InteractionController.cs.}\par
}
{\xe \v Start\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:Start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.Start (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHG}
{\bkmkend AAAAAAAFHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 230 of file InteractionController.cs.}\par
}
{\xe \v SwapGrasp\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:SwapGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionController.SwapGrasp ({\b IInteractionBehaviour}  {\i replacement}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHJ}
{\bkmkend AAAAAAAFHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Seamlessly swap the currently grasped object for a replacement object. It will behave like the hand released the current object, and then grasped the new object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method will not teleport the replacement object or move it in any way, it will just cause it to be grasped. That means that you will be responsible for moving the replacement object into a reasonable position for it to be grasped. \par
}{
Reimplemented in {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1693 of file InteractionController.cs.}\par
}
{\xe \v TransformPoint\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:TransformPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static Vector3 Leap.Unity.Interaction.InteractionController.TransformPoint (Vector3  {\i worldPoint}, {\b ISpaceComponent}  {\i element}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAFHL}
{\bkmkend AAAAAAAFHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the spatial warping of the provided ISpaceComponent to a world-space point. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 850 of file InteractionController.cs.}\par
}
{\xe \v TryGrasp\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:TryGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.TryGrasp ({\b IInteractionBehaviour}  {\i intObj})}}
\par
{\bkmkstart AAAAAAAFHM}
{\bkmkend AAAAAAAFHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the provided interaction object can be grasped by this interaction controller in its current state. If so, the controller will initiate a grasp and this method will return true, otherwise this method returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1674 of file InteractionController.cs.}\par
}
{\xe \v unwarpColliders\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:unwarpColliders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void Leap.Unity.Interaction.InteractionController.unwarpColliders (Transform  {\i primaryHoverPoint}, {\b ISpaceComponent}  {\i warpedSpaceElement}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFHN}
{\bkmkend AAAAAAAFHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementing this method is necessary to support curved spaces as rendered by a {\b Leap} Graphic Renderer. See {\b InteractionHand} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a {\b Leap} Graphic Renderer.) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Warps the collider transforms of this controller by the inverse of the transformation that is applied on the provided warpedSpaceElement, using the primaryHoverPoint as the pivot transform for the transformation.\par
ITransformer.WorldSpaceUnwarp is a useful method here. (ISpaceComponents contain references to their transformers via their anchors.)\par
ISpaceComponents denote game objects whose visual positions are warped from rectilinear (non-warped) space into a curved space (via, for example, a LeapCylindricalSpace, which can only be rendered correctly by the {\b Leap} Graphic Renderer). This method reverses that transformation for the hand, bringing it into the object's rectilinear space, allowing objects curved in this way to correctly collide with the bones in the hand or collider of a held controller.\par
The provided Transform is the closest primary hover point to any given primary hover candidate, so it is used as the pivot point for unwarping the colliders of this {\b InteractionController}. \par
}{
Implemented in {\b Leap.Unity.Interaction.InteractionXRController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionHand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v customHoverActivityFilter\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:customHoverActivityFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Func<{\b IInteractionBehaviour}, bool> Leap.Unity.Interaction.InteractionController.customHoverActivityFilter = null}}
\par
{\bkmkstart AAAAAAAFHQ}
{\bkmkend AAAAAAAFHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In addition to standard hover validity checks, you can set this filter property to further filter objects for hover consideration. Only objects for which this function returns true will be hover candidates (if the filter is not null). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 295 of file InteractionController.cs.}\par
}
{\xe \v DEAD_ZONE_FRACTION\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:DEAD_ZONE_FRACTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float Leap.Unity.Interaction.InteractionController.DEAD_ZONE_FRACTION = 0.04F{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFHR}
{\bkmkend AAAAAAAFHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 872 of file InteractionController.cs.}\par
}
{\xe \v lastObjectTouchedAdjustedMassMass\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:lastObjectTouchedAdjustedMassMass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionController.lastObjectTouchedAdjustedMassMass = 0.2f{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFHS}
{\bkmkend AAAAAAAFHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 907 of file InteractionController.cs.}\par
}
{\xe \v manager\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:manager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InteractionManager} Leap.Unity.Interaction.InteractionController.manager}}
\par
{\bkmkstart AAAAAAAFHT}
{\bkmkend AAAAAAAFHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file InteractionController.cs.}\par
}
{\xe \v OnBeginPrimaryHoveringObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnBeginPrimaryHoveringObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionBehaviour}> Leap.Unity.Interaction.InteractionController.OnBeginPrimaryHoveringObject = (intObj) => \{ \}}}
\par
{\bkmkstart AAAAAAAFHU}
{\bkmkend AAAAAAAFHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when this {\b InteractionController} begins primarily hovering over an {\b InteractionBehaviour}. If the controller transitions to primarily hovering a new object, OnEndPrimaryHoveringObject will first be called on the old object, then OnBeginPrimaryHoveringObject will be called for the new object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 184 of file InteractionController.cs.}\par
}
{\xe \v OnEndPrimaryHoveringObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnEndPrimaryHoveringObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionBehaviour}> Leap.Unity.Interaction.InteractionController.OnEndPrimaryHoveringObject = (intObj) => \{ \}}}
\par
{\bkmkstart AAAAAAAFHV}
{\bkmkend AAAAAAAFHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when this {\b InteractionController} stops primarily hovering over an {\b InteractionBehaviour}. If the controller transitions to primarily-hovering a new object, OnEndPrimaryHoveringObject will first be called on the old object, then OnBeginPrimaryHoveringObject will be called for the new object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 192 of file InteractionController.cs.}\par
}
{\xe \v OnGraspBegin\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnGraspBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionController.OnGraspBegin = () => \{ \}}}
\par
{\bkmkstart AAAAAAAFHW}
{\bkmkend AAAAAAAFHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the {\b InteractionController} begins grasping an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 202 of file InteractionController.cs.}\par
}
{\xe \v OnGraspEnd\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnGraspEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionController.OnGraspEnd = () => \{ \}}}
\par
{\bkmkstart AAAAAAAFHX}
{\bkmkend AAAAAAAFHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the {\b InteractionController} releases an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 212 of file InteractionController.cs.}\par
}
{\xe \v OnGraspStay\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnGraspStay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionController.OnGraspStay = () => \{ \}}}
\par
{\bkmkstart AAAAAAAFHY}
{\bkmkend AAAAAAAFHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called while the {\b InteractionController} is grasping an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 207 of file InteractionController.cs.}\par
}
{\xe \v OnStayPrimaryHoveringObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:OnStayPrimaryHoveringObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionBehaviour}> Leap.Unity.Interaction.InteractionController.OnStayPrimaryHoveringObject = (intObj) => \{ \}}}
\par
{\bkmkstart AAAAAAAFHZ}
{\bkmkend AAAAAAAFHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every (fixed) frame this {\b InteractionController} is primarily hovering over an {\b InteractionBehaviour}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 197 of file InteractionController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v _primaryHoverPoints\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:_primaryHoverPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract List<Transform> Leap.Unity.Interaction.InteractionController._primaryHoverPoints{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFIA}
{\bkmkend AAAAAAAFIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 370 of file InteractionController.cs.}\par
}
{\xe \v _wasContactInitialized\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:_wasContactInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController._wasContactInitialized{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFIB}
{\bkmkend AAAAAAAFIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 904 of file InteractionController.cs.}\par
}
{\xe \v contactBoneParent\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:contactBoneParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract GameObject Leap.Unity.Interaction.InteractionController.contactBoneParent{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFIC}
{\bkmkend AAAAAAAFIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 906 of file InteractionController.cs.}\par
}
{\xe \v contactBones\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:contactBones}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract {\b ContactBone} [] Leap.Unity.Interaction.InteractionController.contactBones{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFID}
{\bkmkend AAAAAAAFID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 905 of file InteractionController.cs.}\par
}
{\xe \v contactEnabled\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:contactEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.contactEnabled{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFIE}
{\bkmkend AAAAAAAFIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file InteractionController.cs.}\par
}
{\xe \v contactingObjects\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:contactingObjects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b IInteractionBehaviour}> Leap.Unity.Interaction.InteractionController.contactingObjects{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIF}
{\bkmkend AAAAAAAFIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of interaction objects that are currently touching this interaction controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 868 of file InteractionController.cs.}\par
}
{\xe \v controllerType\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:controllerType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract {\b ControllerType} Leap.Unity.Interaction.InteractionController.controllerType{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIG}
{\bkmkend AAAAAAAFIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the type of controller this object represents underneath the {\b InteractionController} abstraction. If the type is {\b ControllerType.Hand}, the intHand property will contain the {\b InteractionHand} object this object abstracts from. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 160 of file InteractionController.cs.}\par
}
{\xe \v defaultContactBoneMaterial\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:defaultContactBoneMaterial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PhysicMaterial Leap.Unity.Interaction.InteractionController.defaultContactBoneMaterial{\f2 [static]}, {\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFIH}
{\bkmkend AAAAAAAFIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 881 of file InteractionController.cs.}\par
}
{\xe \v graspCandidates\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:graspCandidates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b IInteractionBehaviour}> Leap.Unity.Interaction.InteractionController.graspCandidates{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFII}
{\bkmkend AAAAAAAFII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of objects currently considered graspable. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1650 of file InteractionController.cs.}\par
}
{\xe \v graspedObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:graspedObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IInteractionBehaviour} Leap.Unity.Interaction.InteractionController.graspedObject{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIJ}
{\bkmkend AAAAAAAFIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the object the controller is currently grasping, or null if there is no such object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1647 of file InteractionController.cs.}\par
}
{\xe \v graspingEnabled\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:graspingEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.graspingEnabled{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFIK}
{\bkmkend AAAAAAAFIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file InteractionController.cs.}\par
}
{\xe \v graspManipulatorPoints\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:graspManipulatorPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract List<Vector3> Leap.Unity.Interaction.InteractionController.graspManipulatorPoints{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIL}
{\bkmkend AAAAAAAFIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the points of the controller to add to the calculation to determine how held objects should move as the controller moves. {\b Interaction} Controllers utilize the Kabsch algorithm to determine this, which is most noticeable when using {\b Leap} hands via InteractionHands to manipulate held objects. Rigid controllers may simply return a single rigid point on the controller. Refer to {\b InteractionHand} for a reference implementation for dynamic controllers (e.g. hands). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1660 of file InteractionController.cs.}\par
}
{\xe \v hoverActivityManager\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:hoverActivityManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ActivityManager}<{\b IInteractionBehaviour}> Leap.Unity.Interaction.InteractionController.hoverActivityManager{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIM}
{\bkmkend AAAAAAAFIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 317 of file InteractionController.cs.}\par
}
{\xe \v hoveredObjects\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:hoveredObjects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b IInteractionBehaviour}> Leap.Unity.Interaction.InteractionController.hoveredObjects{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIN}
{\bkmkend AAAAAAAFIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a set of all {\b Interaction} objects currently hovered by this {\b InteractionController}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 368 of file InteractionController.cs.}\par
}
{\xe \v hoverEnabled\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:hoverEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.hoverEnabled{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFIO}
{\bkmkend AAAAAAAFIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file InteractionController.cs.}\par
}
{\xe \v hoverPoint\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:hoverPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract Vector3 Leap.Unity.Interaction.InteractionController.hoverPoint{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIP}
{\bkmkend AAAAAAAFIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current position to check against nearby objects for hovering. Position is only used if the controller is currently tracked. For example, {\b InteractionHand} returns the center of the palm of the underlying {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 361 of file InteractionController.cs.}\par
}
{\xe \v intHand\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:intHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract {\b InteractionHand} Leap.Unity.Interaction.InteractionController.intHand{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIQ}
{\bkmkend AAAAAAAFIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this {\b InteractionController}'s controllerType is {\b ControllerType.Hand}, this gets the {\b InteractionHand}, otherwise this returns null. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 166 of file InteractionController.cs.}\par
}
{\xe \v isBeingMoved\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:isBeingMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.isBeingMoved{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIR}
{\bkmkend AAAAAAAFIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) is currently being moved or being actively manipulated by the player. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 125 of file InteractionController.cs.}\par
}
{\xe \v isGraspingObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:isGraspingObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.isGraspingObject{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIS}
{\bkmkend AAAAAAAFIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the controller is currently grasping an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1644 of file InteractionController.cs.}\par
}
{\xe \v isLeft\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:isLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.isLeft{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIT}
{\bkmkend AAAAAAAFIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) represents or is held by a left hand (true) or a right hand (false). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 131 of file InteractionController.cs.}\par
}
{\xe \v isPrimaryHovering\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:isPrimaryHovering}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.isPrimaryHovering{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIU}
{\bkmkend AAAAAAAFIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the {\b InteractionController} is currently primarily hovering over any interaction object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 381 of file InteractionController.cs.}\par
}
{\xe \v isRight\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:isRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.isRight{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIV}
{\bkmkend AAAAAAAFIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) represents or is held by a right hand (true) or a left hand (false). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 137 of file InteractionController.cs.}\par
}
{\xe \v isTracked\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:isTracked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract bool Leap.Unity.Interaction.InteractionController.isTracked{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIW}
{\bkmkend AAAAAAAFIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the underlying object ({\b Leap} hand or a held controller) is currently in a tracked state. Objects grasped by a controller that becomes untracked will become "suspended" and receive specific suspension callbacks. (Implementing any behaviour during the suspension state is left up to the developer, however.) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 119 of file InteractionController.cs.}\par
}
{\xe \v position\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract Vector3 Leap.Unity.Interaction.InteractionController.position{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIX}
{\bkmkend AAAAAAAFIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current position of this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 142 of file InteractionController.cs.}\par
}
{\xe \v primaryHoverDistance\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:primaryHoverDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionController.primaryHoverDistance{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIY}
{\bkmkend AAAAAAAFIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the distance from the closest primary hover point on this controller to its primarily hovered object, if there are any. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 395 of file InteractionController.cs.}\par
}
{\xe \v primaryHoveredObject\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:primaryHoveredObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IInteractionBehaviour} Leap.Unity.Interaction.InteractionController.primaryHoveredObject{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFIZ}
{\bkmkend AAAAAAAFIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the {\b InteractionBehaviour} that is currently this {\b InteractionController}'s primary hovered object, if there is one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 388 of file InteractionController.cs.}\par
}
{\xe \v primaryHoveringPoint\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:primaryHoveringPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Vector3? Leap.Unity.Interaction.InteractionController.primaryHoveringPoint{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJA}
{\bkmkend AAAAAAAFJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the position of the primary hovering point that is closest to its primary hovered object, if this controller has a primary hover. Otherwise, returns Vector3.zero. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 402 of file InteractionController.cs.}\par
}
{\xe \v primaryHoveringPointIndex\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:primaryHoveringPointIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Leap.Unity.Interaction.InteractionController.primaryHoveringPointIndex{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJB}
{\bkmkend AAAAAAAFJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the index in the primaryHoverPoints array of the primary hover point that is currently closest to this controller's primary hover object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 413 of file InteractionController.cs.}\par
}
{\xe \v primaryHoverLocked\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:primaryHoverLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.primaryHoverLocked{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFJC}
{\bkmkend AAAAAAAFJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When set to true, locks the current primarily hovered object, even if the hand gets closer to a different object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 340 of file InteractionController.cs.}\par
}
{\xe \v primaryHoverPoints\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:primaryHoverPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyList}<Transform> Leap.Unity.Interaction.InteractionController.primaryHoverPoints{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJD}
{\bkmkend AAAAAAAFJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the list of Transforms to consider against nearby objects to determine the closest object (primary hover) of this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 375 of file InteractionController.cs.}\par
}
{\xe \v rotation\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:rotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract Quaternion Leap.Unity.Interaction.InteractionController.rotation{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJE}
{\bkmkend AAAAAAAFJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current rotation of this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 147 of file InteractionController.cs.}\par
}
{\xe \v scale\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:scale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionController.scale{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJF}
{\bkmkend AAAAAAAFJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contact requires knowledge of the controller's scale. Non-uniformly scaled controllers are NOT supported. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 172 of file InteractionController.cs.}\par
}
{\xe \v softContactDislocationDistance\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:softContactDislocationDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionController.softContactDislocationDistance{\f2 [get]}, {\f2 [set]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFJG}
{\bkmkend AAAAAAAFJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 875 of file InteractionController.cs.}\par
}
{\xe \v softContactEnabled\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:softContactEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionController.softContactEnabled{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJH}
{\bkmkend AAAAAAAFJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1110 of file InteractionController.cs.}\par
}
{\xe \v velocity\:Leap.Unity.Interaction.InteractionController}
{\xe \v Leap.Unity.Interaction.InteractionController\:velocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract Vector3 Leap.Unity.Interaction.InteractionController.velocity{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFJI}
{\bkmkend AAAAAAAFJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current velocity of this controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 152 of file InteractionController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
O:/GitHUBMINIPRoject/Assets/LeapMotion/Modules/InteractionEngine/Scripts/{\b InteractionController.cs}\par
}}