{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Leap.Unity.Interaction.InteractionBehaviour Class Reference\par \pard\plain 
{\tc\tcl2 \v Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour}
{\bkmkstart AAAAAAAEYM}
{\bkmkend AAAAAAAEYM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
InteractionBehaviours are components that enable GameObjects to interact with interaction controllers (InteractionControllerBase) in a physically intuitive way. }}\par
Inheritance diagram for Leap.Unity.Interaction.InteractionBehaviour:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_leap_1_1_unity_1_1_interaction_1_1_interaction_behaviour.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GraspedMovementType} \{ {\b GraspedMovementType.Inherit}, 
{\b GraspedMovementType.Kinematic}, 
{\b GraspedMovementType.Nonkinematic}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EventType} \{ {\b EventType.HoverBegin} = 100, 
{\b EventType.HoverEnd} = 101, 
{\b EventType.HoverStay} = 102, 
{\b EventType.PerControllerHoverBegin} = 110, 
{\b EventType.PerControllerHoverEnd} = 111, 
{\b EventType.PrimaryHoverBegin} = 120, 
{\b EventType.PrimaryHoverEnd} = 121, 
{\b EventType.PrimaryHoverStay} = 122, 
{\b EventType.PerControllerPrimaryHoverBegin} = 130, 
{\b EventType.PerControllerPrimaryHoverEnd} = 132, 
{\b EventType.GraspBegin} = 140, 
{\b EventType.GraspEnd} = 141, 
{\b EventType.GraspStay} = 142, 
{\b EventType.PerControllerGraspBegin} = 150, 
{\b EventType.PerControllerGraspEnd} = 152, 
{\b EventType.SuspensionBegin} = 160, 
{\b EventType.SuspensionEnd} = 161, 
{\b EventType.ContactBegin} = 170, 
{\b EventType.ContactEnd} = 171, 
{\b EventType.ContactStay} = 172, 
{\b EventType.PerControllerContactBegin} = 180, 
{\b EventType.PerControllerContactEnd} = 181
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ReleaseFromGrasp} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases this object from the interaction controller currently grasping it, if it is grasped, and returns true. If the object was not grasped, this method returns false. Directly after calling this method, the object is guaranteed not to be held. However, a grasp may retrigger on the next frame, if the {\b Interaction} {\b Controller} determines that the released object should be grasped. The safest way to ensure an object is released and ungraspable is to use the interaction object's ignoreGrasp property. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Vector3 {\b GetGraspPoint} ({\b InteractionController} intController)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns (approximately) where the argument hand is grasping this object. If the interaction controller is not currently grasping this object, returns Vector3.zero, and logs an error to the {\b Unity} console. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddLinearAcceleration} (Vector3 acceleration)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a linear acceleration to the center of mass of this object. Use this instead of Rigidbody.AddForce() to accelerate an {\b Interaction} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddAngularAcceleration} (Vector3 acceleration)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an angular acceleration to the center of mass of this object. Use this instead of Rigidbody.AddTorque() to add angular acceleration to an {\b Interaction} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FixedUpdateObject} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InteractionManager} manually calls method this after all InteractionControllerBase objects are updated via the {\b InteractionManager}'s FixedUpdate(). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual float {\b GetHoverDistance} (Vector3 worldPosition)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a comparative distance to this interaction object. Calculated by finding the smallest distance to each of the object's colliders. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BeginHover} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EndHover} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StayHovered} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearHoverTracking} (bool onlyInvalidControllers=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears hover tracking state for this object on all of the currently-hovering controllers. New hover state will begin anew on the next fixed frame if the appropriate conditions for hover are still fulfilled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BeginPrimaryHover} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EndPrimaryHover} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StayPrimaryHovered} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearPrimaryHoverTracking} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears primary hover tracking state for this object on all of the currently- primary-hovering controllers. New priamry hover state will begin anew on the next fixed frame if the appropriate conditions for primary hover are still fulfilled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BeginContact} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EndContact} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StayContacted} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearContactTracking} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears contact tracking for this object on any currently-contacting controllers. If the object is still contacting controllers and they are appropriately enabled, contact will begin anew on the next fixed frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BeginGrasp} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EndGrasp} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StayGrasped} (List< {\b InteractionController} > controllers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BeginSuspension} ({\b InteractionController} controller)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EndSuspension} ({\b InteractionController} controller)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FixedUpdateForces} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RefreshInteractionColliders} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Recursively searches the hierarchy of this {\b Interaction} object to find all of the Colliders that are attached to its Rigidbody. These will be the colliders used to calculate distance from the controller to determine which object will become the primary hover. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RefreshPositionLockedState} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this method if the {\b InteractionBehaviour}'s Rigidbody becomes or unbecomes fully positionally locked (X, Y, Z) or if a Joint attached to the Rigidbody no longer locks its position (e.g. by being destroyed or disabled). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b MAX_ANGULAR_VELOCITY} = 100F\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnHoverBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object becomes hovered by any nearby interaction controllers. The hover activity radius is a setting specified by the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnHoverEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object stops being hovered by any nearby interaction controllers. The hover activity radius is a setting specified by the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnHoverStay}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called during every fixed (physics) frame in which one or more interaction controller is within the hover activity radius around this object. The hover activity radius is a setting specified by the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerHoverBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller enters the hover activity radius around this interaction object. The hover activity radius is a setting specified by the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerHoverEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller leaves the hover activity radius around this interaction object. The hover activity radius is a setting specified by the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnPrimaryHoverBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object becomes primarily hovered by any interaction controllers, if the object was not primarily hovered by any controllers on the previous frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnPrimaryHoverEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object ceases being the primary hover of any interaction controllers, if the object was primarily hovered by one or more controllers on the previous frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnPrimaryHoverStay}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed (physics) frame in which one or more interaction controllers is primarily hovering over this object. Only one object may be the primary hover of a given controller at any one time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerPrimaryHoverBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller (a {\b Leap} hand or supported VR controller) begins primarily hovering over this object. Only one interaction object can be the primary hover of a given controller at a time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerPrimaryHoverEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controler (a {\b Leap} hand or supported VR controller) stops primarily hovering over this object. Only one interaction object can be the primary hover of a given controller at a time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose}? {\b latestScheduledGraspPose} = null\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nonkinematic grasping motion applies clamped velocities to {\b Interaction} Behaviours when they are grasped to move them to their target position and rotation in the grasping hand. If a controller applies its SwapGrasp method to an interaction object that didn't reach its target pose due to velocity clamping, the swapped-out object will inherit the offset as a new target pose relative to the hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GraspedMovementEvent {\b OnGraspedMovement}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called directly after this grasped object's Rigidbody has had its position and rotation set by its currently grasping controller(s). Subscribe to this callback if you'd like to override the default behaviour for grasping objects, for example, to constrain the object's position or rotation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnGraspBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object becomes grasped, if it was not already held by any interaction controllers on the previous frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnGraspEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object is no longer grasped by any interaction controllers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnGraspStay}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed (physics) frame during which this object is grasped by one or more hands. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerGraspBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller grasps this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerGraspEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller stops grasping this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnSuspensionBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the interaction controller that is grasping this interaction object loses tracking. This can occur if the controller is occluded from the sensor that is tracking it, e.g. by as the user's body or an object in the real world. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnSuspensionEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when an object ceases being suspended. An object is suspended if it is currently grasped by an untracked controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnContactBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when this object begins colliding with any interaction controllers, if the object was not colliding with any interaction controllers last frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnContactEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object ceases colliding with any interaction controllers, if the }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action {\b OnContactStay}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every frame during which one or more interaction controllers is colliding with this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerContactBegin}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller begins colliding with this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Action< {\b InteractionController} > {\b OnPerControllerContactEnd}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller stops colliding with this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GraspedMovementType} {\b graspedMovementType}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnValidate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Awake} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnable} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnDisable} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Start} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b fixedUpdateGraspedMovement} ({\b Pose} origPose, {\b Pose} newPose, List< {\b InteractionController} > controllers)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InteractionController} {\b _suspendingController} = null\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Vector3 {\b _accumulatedLinearAcceleration} = Vector3.zero\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Vector3 {\b _accumulatedAngularAcceleration} = Vector3.zero\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< Collider > {\b _interactionColliders} = new List<Collider>()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHovered}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether any interaction controller is nearby. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InteractionController} {\b closestHoveringController}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the closest interaction controller to this object, or null if no controller is nearby. {\b Leap} hands and supported VR controllers both count as "controllers" for the purposes of this getter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hand}? {\b closestHoveringHand}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the closest {\b Leap} hand to this object, or null if no hand is nearby. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b closestHoveringControllerDistance}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the distance from this object to the palm of the closest hand to this object, or float.PositiveInfinity of no hand is nearby. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b InteractionController} > {\b hoveringControllers}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets all of the interaction controllers hovering near this object, whether they are {\b Leap} hands or supported VR controllers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPrimaryHovered}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether this object is the primary hover for any interaction controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InteractionController} {\b primaryHoveringController}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the closest primary hovering interaction controller for this object, if it has one. An interaction controller can be a {\b Leap} hand or a supported VR controller. Any of these controllers can be the primary hover for this interaction object only if the controller is closer to it than any other interaction object. If there are multiple such controllers, this getter will return the closest one. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b InteractionController} > {\b primaryHoveringControllers}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of all interaction controllers primarily hovering over this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hand}? {\b primaryHoveringHand}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the primary hovering hand for this interaction object, if it has one. A hand is the primary hover for an interaction object only if it is closer to that object than any other interaction object. If there are multiple such hands, returns the hand closest to this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Finger} {\b primaryHoveringFinger}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the finger that is currently primarily hovering over this object, of the closest primarily hovering hand. Will return null if this object is not currently any {\b Leap} hand's primary hover. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Vector3 {\b primaryHoveringControllerPoint}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the position of the primaryHoverPoint on the primary hovering interaction controller that is primarily hovering over this object. For example, if the primarily hovering controller is a {\b Leap} hand, this will be the position of the fingertip that is closest to this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b primaryHoverDistance}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the distance to the primary hover point whose controller is primarily hovering over this object. For example, if the primary hovering controller is a {\b Leap} hand, this will return the distance to the fingertip that is closest to this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isGrasped}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether this object is grasped by any interaction controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InteractionController} {\b graspingController}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the controller currently grasping this object. Warning: If allowMultigrasp is enabled on this object, it might have multiple grasping controllers, in which case this will only return one of the controllers grasping this object, and there is no guarantee on which controller is returned! If no controllers ({\b Leap} hands or supported VR controllers) are currently grasping this object, returns null. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b InteractionController} > {\b graspingControllers}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of all interaction controllers currently grasping this object. {\b Interaction} controllers include {\b Leap} hands via {\b InteractionHand} and supported VR controllers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b InteractionHand} > {\b graspingHands}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a set of all {\b Leap} hands currently grasping this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSuspended}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the object is currently suspended. An object is "suspended" if it is currently grasped by an untracked controller. For more details, refer to OnSuspensionBegin. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReadonlyHashSet}< {\b InteractionController} > {\b contactingControllers}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a set of all InteractionControllers currently contacting this interaction object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InteractionManager} {\b manager}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Rigidbody {\b rigidbody}{\f2  [get, protected set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Rigidbody associated with this interaction object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ISpaceComponent} {\b space}{\f2  [get, protected set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IgnoreHoverMode} {\b ignoreHoverMode}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ignorePrimaryHover}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ignoreContact}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ignoreGrasping}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ContactForceMode} {\b contactForceMode}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allowMultiGrasp}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveObjectWhenGrasped}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b overrideInteractionLayer}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SingleLayer} {\b interactionLayer}{\f2  [get, protected set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b overrideNoContactLayer}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SingleLayer} {\b noContactLayer}{\f2  [get, protected set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< Collider > {\b primaryHoverColliders}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the List of Colliders used for hover distance checking for this {\b Interaction} object. Hover distancing checking will affect which object is chosen for an interaction controller's primary hover, as well as for determining this object's closest hovering controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGraspedPoseHandler} {\b graspedPoseHandler}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets or sets the grasped pose handler for this {\b Interaction} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IThrowHandler} {\b throwHandler}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets or sets the throw handler for this {\b Interaction} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPositionLocked}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the {\b InteractionBehaviour} has its position fully locked by its Rigidbody settings or by any attached PhysX Joints. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
InteractionBehaviours are components that enable GameObjects to interact with interaction controllers (InteractionControllerBase) in a physically intuitive way. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, they represent objects that can be poked, prodded, smacked, grasped, and thrown around by {\b Interaction} controllers, including {\b Leap} hands. They also provide a thorough public API with settings and hovering, contact, and grasping callbacks for creating physical interfaces or overriding the default physical behavior of the object.\par
In documentation and some method calls, GameObjects with an {\b InteractionBehaviour} component may be referred to as interaction objects. \par
}{
Definition at line 37 of file InteractionBehaviour.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v EventType\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:EventType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Leap.Unity.Interaction.InteractionBehaviour.EventType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAEYN}
{\bkmkend AAAAAAAEYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v HoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:HoverBegin}
{\qr HoverBegin{\bkmkstart AAAAAAAEYO}
{\bkmkend AAAAAAAEYO}
\cell }{\cell }{\row }
{\xe \v HoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:HoverEnd}
{\qr HoverEnd{\bkmkstart AAAAAAAEYP}
{\bkmkend AAAAAAAEYP}
\cell }{\cell }{\row }
{\xe \v HoverStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:HoverStay}
{\qr HoverStay{\bkmkstart AAAAAAAEYQ}
{\bkmkend AAAAAAAEYQ}
\cell }{\cell }{\row }
{\xe \v PerControllerHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerHoverBegin}
{\qr PerControllerHoverBegin{\bkmkstart AAAAAAAEYR}
{\bkmkend AAAAAAAEYR}
\cell }{\cell }{\row }
{\xe \v PerControllerHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerHoverEnd}
{\qr PerControllerHoverEnd{\bkmkstart AAAAAAAEYS}
{\bkmkend AAAAAAAEYS}
\cell }{\cell }{\row }
{\xe \v PrimaryHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PrimaryHoverBegin}
{\qr PrimaryHoverBegin{\bkmkstart AAAAAAAEYT}
{\bkmkend AAAAAAAEYT}
\cell }{\cell }{\row }
{\xe \v PrimaryHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PrimaryHoverEnd}
{\qr PrimaryHoverEnd{\bkmkstart AAAAAAAEYU}
{\bkmkend AAAAAAAEYU}
\cell }{\cell }{\row }
{\xe \v PrimaryHoverStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PrimaryHoverStay}
{\qr PrimaryHoverStay{\bkmkstart AAAAAAAEYV}
{\bkmkend AAAAAAAEYV}
\cell }{\cell }{\row }
{\xe \v PerControllerPrimaryHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerPrimaryHoverBegin}
{\qr PerControllerPrimaryHoverBegin{\bkmkstart AAAAAAAEYW}
{\bkmkend AAAAAAAEYW}
\cell }{\cell }{\row }
{\xe \v PerControllerPrimaryHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerPrimaryHoverEnd}
{\qr PerControllerPrimaryHoverEnd{\bkmkstart AAAAAAAEYX}
{\bkmkend AAAAAAAEYX}
\cell }{\cell }{\row }
{\xe \v GraspBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:GraspBegin}
{\qr GraspBegin{\bkmkstart AAAAAAAEYY}
{\bkmkend AAAAAAAEYY}
\cell }{\cell }{\row }
{\xe \v GraspEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:GraspEnd}
{\qr GraspEnd{\bkmkstart AAAAAAAEYZ}
{\bkmkend AAAAAAAEYZ}
\cell }{\cell }{\row }
{\xe \v GraspStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:GraspStay}
{\qr GraspStay{\bkmkstart AAAAAAAEZA}
{\bkmkend AAAAAAAEZA}
\cell }{\cell }{\row }
{\xe \v PerControllerGraspBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerGraspBegin}
{\qr PerControllerGraspBegin{\bkmkstart AAAAAAAEZB}
{\bkmkend AAAAAAAEZB}
\cell }{\cell }{\row }
{\xe \v PerControllerGraspEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerGraspEnd}
{\qr PerControllerGraspEnd{\bkmkstart AAAAAAAEZC}
{\bkmkend AAAAAAAEZC}
\cell }{\cell }{\row }
{\xe \v SuspensionBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:SuspensionBegin}
{\qr SuspensionBegin{\bkmkstart AAAAAAAEZD}
{\bkmkend AAAAAAAEZD}
\cell }{\cell }{\row }
{\xe \v SuspensionEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:SuspensionEnd}
{\qr SuspensionEnd{\bkmkstart AAAAAAAEZE}
{\bkmkend AAAAAAAEZE}
\cell }{\cell }{\row }
{\xe \v ContactBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ContactBegin}
{\qr ContactBegin{\bkmkstart AAAAAAAEZF}
{\bkmkend AAAAAAAEZF}
\cell }{\cell }{\row }
{\xe \v ContactEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ContactEnd}
{\qr ContactEnd{\bkmkstart AAAAAAAEZG}
{\bkmkend AAAAAAAEZG}
\cell }{\cell }{\row }
{\xe \v ContactStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ContactStay}
{\qr ContactStay{\bkmkstart AAAAAAAEZH}
{\bkmkend AAAAAAAEZH}
\cell }{\cell }{\row }
{\xe \v PerControllerContactBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerContactBegin}
{\qr PerControllerContactBegin{\bkmkstart AAAAAAAEZI}
{\bkmkend AAAAAAAEZI}
\cell }{\cell }{\row }
{\xe \v PerControllerContactEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:PerControllerContactEnd}
{\qr PerControllerContactEnd{\bkmkstart AAAAAAAEZJ}
{\bkmkend AAAAAAAEZJ}
\cell }{\cell }{\row }
}
\par
{
Definition at line 1583 of file InteractionBehaviour.cs.}\par
}
{\xe \v GraspedMovementType\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:GraspedMovementType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Leap.Unity.Interaction.InteractionBehaviour.GraspedMovementType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAEZK}
{\bkmkend AAAAAAAEZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Inherit\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:Inherit}
{\qr Inherit{\bkmkstart AAAAAAAEZL}
{\bkmkend AAAAAAAEZL}
\cell }{\cell }{\row }
{\xe \v Kinematic\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:Kinematic}
{\qr Kinematic{\bkmkstart AAAAAAAEZM}
{\bkmkend AAAAAAAEZM}
\cell }{\cell }{\row }
{\xe \v Nonkinematic\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:Nonkinematic}
{\qr Nonkinematic{\bkmkstart AAAAAAAEZN}
{\bkmkend AAAAAAAEZN}
\cell }{\cell }{\row }
}
\par
{
Definition at line 687 of file InteractionBehaviour.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddAngularAcceleration\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:AddAngularAcceleration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.AddAngularAcceleration (Vector3  {\i acceleration})}}
\par
{\bkmkstart AAAAAAAEZO}
{\bkmkend AAAAAAAEZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an angular acceleration to the center of mass of this object. Use this instead of Rigidbody.AddTorque() to add angular acceleration to an {\b Interaction} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rigidbody.AddTorque() will work in most scenarios, but will produce unexpected behavior when interaction controllers are embedded inside an object due to soft contact. Calling this method instead solves that problem. \par
}{
Definition at line 533 of file InteractionBehaviour.cs.}\par
}
{\xe \v AddLinearAcceleration\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:AddLinearAcceleration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.AddLinearAcceleration (Vector3  {\i acceleration})}}
\par
{\bkmkstart AAAAAAAEZP}
{\bkmkend AAAAAAAEZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a linear acceleration to the center of mass of this object. Use this instead of Rigidbody.AddForce() to accelerate an {\b Interaction} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rigidbody.AddForce() will work in most scenarios, but will produce unexpected behavior when interaction controllers are embedded inside an object due to soft contact. Calling this method instead solves that problem. \par
}{
Definition at line 518 of file InteractionBehaviour.cs.}\par
}
{\xe \v Awake\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:Awake}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionBehaviour.Awake (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZQ}
{\bkmkend AAAAAAAEZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionToggle} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 764 of file InteractionBehaviour.cs.}\par
}
{\xe \v BeginContact\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:BeginContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.BeginContact (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEVW}
{\bkmkend AAAAAAAEVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEVV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1107 of file InteractionBehaviour.cs.}\par
}
{\xe \v BeginGrasp\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:BeginGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.BeginGrasp (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEVY}
{\bkmkend AAAAAAAEVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEVX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1217 of file InteractionBehaviour.cs.}\par
}
{\xe \v BeginHover\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:BeginHover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.BeginHover (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWA}
{\bkmkend AAAAAAAEWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEVZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 894 of file InteractionBehaviour.cs.}\par
}
{\xe \v BeginPrimaryHover\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:BeginPrimaryHover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.BeginPrimaryHover (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWC}
{\bkmkend AAAAAAAEWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 996 of file InteractionBehaviour.cs.}\par
}
{\xe \v BeginSuspension\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:BeginSuspension}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.BeginSuspension ({\b InteractionController}  {\i controller})}}
\par
{\bkmkstart AAAAAAAEWE}
{\bkmkend AAAAAAAEWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1345 of file InteractionBehaviour.cs.}\par
}
{\xe \v ClearContactTracking\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ClearContactTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.ClearContactTracking ()}}
\par
{\bkmkstart AAAAAAAEZS}
{\bkmkend AAAAAAAEZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears contact tracking for this object on any currently-contacting controllers. If the object is still contacting controllers and they are appropriately enabled, contact will begin anew on the next fixed frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1140 of file InteractionBehaviour.cs.}\par
}
{\xe \v ClearHoverTracking\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ClearHoverTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.ClearHoverTracking (bool  {\i onlyInvalidControllers} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAEZT}
{\bkmkend AAAAAAAEZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears hover tracking state for this object on all of the currently-hovering controllers. New hover state will begin anew on the next fixed frame if the appropriate conditions for hover are still fulfilled. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optionally, only clear hover tracking state for controllers that should be ignoring hover for this interaction object due to its ignoreHoverMode. \par
}{
Definition at line 973 of file InteractionBehaviour.cs.}\par
}
{\xe \v ClearPrimaryHoverTracking\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ClearPrimaryHoverTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.ClearPrimaryHoverTracking ()}}
\par
{\bkmkstart AAAAAAAEZU}
{\bkmkend AAAAAAAEZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears primary hover tracking state for this object on all of the currently- primary-hovering controllers. New priamry hover state will begin anew on the next fixed frame if the appropriate conditions for primary hover are still fulfilled. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1056 of file InteractionBehaviour.cs.}\par
}
{\xe \v EndContact\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:EndContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.EndContact (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWG}
{\bkmkend AAAAAAAEWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1119 of file InteractionBehaviour.cs.}\par
}
{\xe \v EndGrasp\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:EndGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.EndGrasp (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWI}
{\bkmkend AAAAAAAEWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1269 of file InteractionBehaviour.cs.}\par
}
{\xe \v EndHover\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:EndHover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.EndHover (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWK}
{\bkmkend AAAAAAAEWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 910 of file InteractionBehaviour.cs.}\par
}
{\xe \v EndPrimaryHover\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:EndPrimaryHover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.EndPrimaryHover (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWM}
{\bkmkend AAAAAAAEWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1012 of file InteractionBehaviour.cs.}\par
}
{\xe \v EndSuspension\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:EndSuspension}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.EndSuspension ({\b InteractionController}  {\i controller})}}
\par
{\bkmkstart AAAAAAAEWO}
{\bkmkend AAAAAAAEWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1351 of file InteractionBehaviour.cs.}\par
}
{\xe \v FixedUpdateForces\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:FixedUpdateForces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.FixedUpdateForces ()}}
\par
{\bkmkstart AAAAAAAEZV}
{\bkmkend AAAAAAAEZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1365 of file InteractionBehaviour.cs.}\par
}
{\xe \v fixedUpdateGraspedMovement\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:fixedUpdateGraspedMovement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionBehaviour.fixedUpdateGraspedMovement ({\b Pose}  {\i origPose}, {\b Pose}  {\i newPose}, List< {\b InteractionController} >  {\i controllers}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZW}
{\bkmkend AAAAAAAEZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1329 of file InteractionBehaviour.cs.}\par
}
{\xe \v FixedUpdateObject\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:FixedUpdateObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.FixedUpdateObject ()}}
\par
{\bkmkstart AAAAAAAEWQ}
{\bkmkend AAAAAAAEWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InteractionManager} manually calls method this after all InteractionControllerBase objects are updated via the {\b InteractionManager}'s FixedUpdate(). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 825 of file InteractionBehaviour.cs.}\par
}
{\xe \v GetGraspPoint\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:GetGraspPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Vector3 Leap.Unity.Interaction.InteractionBehaviour.GetGraspPoint ({\b InteractionController}  {\i intController})}}
\par
{\bkmkstart AAAAAAAEZX}
{\bkmkend AAAAAAAEZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns (approximately) where the argument hand is grasping this object. If the interaction controller is not currently grasping this object, returns Vector3.zero, and logs an error to the {\b Unity} console. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 454 of file InteractionBehaviour.cs.}\par
}
{\xe \v GetHoverDistance\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:GetHoverDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual float Leap.Unity.Interaction.InteractionBehaviour.GetHoverDistance (Vector3  {\i worldPosition}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEWS}
{\bkmkend AAAAAAAEWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a comparative distance to this interaction object. Calculated by finding the smallest distance to each of the object's colliders. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Any MeshColliders, however, will not have their distances calculated precisely; the squared distance to their bounding box is calculated instead. It is possible to use a custom set of colliders against which to test primary hover calculations: see primaryHoverColliders. \par
}{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 848 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnDisable\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionBehaviour.OnDisable (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZY}
{\bkmkend AAAAAAAEZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionSlider} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Leap.Unity.Interaction.InteractionButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionToggle} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 803 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnEnable\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionBehaviour.OnEnable (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFAC}
{\bkmkend AAAAAAAFAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionSlider} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAD \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionToggle} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 771 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnValidate\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnValidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionBehaviour.OnValidate (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFAF}
{\bkmkend AAAAAAAFAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionSlider} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 757 of file InteractionBehaviour.cs.}\par
}
{\xe \v RefreshInteractionColliders\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:RefreshInteractionColliders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.RefreshInteractionColliders ()}}
\par
{\bkmkstart AAAAAAAFAH}
{\bkmkend AAAAAAAFAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Recursively searches the hierarchy of this {\b Interaction} object to find all of the Colliders that are attached to its Rigidbody. These will be the colliders used to calculate distance from the controller to determine which object will become the primary hover. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this method manually if you change an {\b Interaction} object's colliders after its {\b Start()} method has been called! (Called automatically in OnEnable.) \par
}{
Definition at line 1399 of file InteractionBehaviour.cs.}\par
}
{\xe \v RefreshPositionLockedState\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:RefreshPositionLockedState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.RefreshPositionLockedState ()}}
\par
{\bkmkstart AAAAAAAFAI}
{\bkmkend AAAAAAAFAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call this method if the {\b InteractionBehaviour}'s Rigidbody becomes or unbecomes fully positionally locked (X, Y, Z) or if a Joint attached to the Rigidbody no longer locks its position (e.g. by being destroyed or disabled). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1529 of file InteractionBehaviour.cs.}\par
}
{\xe \v ReleaseFromGrasp\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ReleaseFromGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.ReleaseFromGrasp ()}}
\par
{\bkmkstart AAAAAAAFAJ}
{\bkmkend AAAAAAAFAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases this object from the interaction controller currently grasping it, if it is grasped, and returns true. If the object was not grasped, this method returns false. Directly after calling this method, the object is guaranteed not to be held. However, a grasp may retrigger on the next frame, if the {\b Interaction} {\b Controller} determines that the released object should be grasped. The safest way to ensure an object is released and ungraspable is to use the interaction object's ignoreGrasp property. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 440 of file InteractionBehaviour.cs.}\par
}
{\xe \v Start\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:Start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionBehaviour.Start (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFAK}
{\bkmkend AAAAAAAFAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b Leap.Unity.Interaction.InteractionSlider} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Leap.Unity.Interaction.InteractionButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAM \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Leap.Unity.Interaction.InteractionToggle} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 812 of file InteractionBehaviour.cs.}\par
}
{\xe \v StayContacted\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:StayContacted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.StayContacted (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWU}
{\bkmkend AAAAAAAEWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1131 of file InteractionBehaviour.cs.}\par
}
{\xe \v StayGrasped\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:StayGrasped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.StayGrasped (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWW}
{\bkmkend AAAAAAAEWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1308 of file InteractionBehaviour.cs.}\par
}
{\xe \v StayHovered\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:StayHovered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.StayHovered (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEWY}
{\bkmkend AAAAAAAEWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 926 of file InteractionBehaviour.cs.}\par
}
{\xe \v StayPrimaryHovered\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:StayPrimaryHovered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionBehaviour.StayPrimaryHovered (List< {\b InteractionController} >  {\i controllers})}}
\par
{\bkmkstart AAAAAAAEXA}
{\bkmkend AAAAAAAEXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Leap.Unity.Interaction.IInteractionBehaviour} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEWZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 1028 of file InteractionBehaviour.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _accumulatedAngularAcceleration\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:_accumulatedAngularAcceleration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Vector3 Leap.Unity.Interaction.InteractionBehaviour._accumulatedAngularAcceleration = Vector3.zero{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFAO}
{\bkmkend AAAAAAAFAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1363 of file InteractionBehaviour.cs.}\par
}
{\xe \v _accumulatedLinearAcceleration\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:_accumulatedLinearAcceleration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Vector3 Leap.Unity.Interaction.InteractionBehaviour._accumulatedLinearAcceleration = Vector3.zero{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFAP}
{\bkmkend AAAAAAAFAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1362 of file InteractionBehaviour.cs.}\par
}
{\xe \v _interactionColliders\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:_interactionColliders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<Collider> Leap.Unity.Interaction.InteractionBehaviour._interactionColliders = new List<Collider>(){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFAQ}
{\bkmkend AAAAAAAFAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1388 of file InteractionBehaviour.cs.}\par
}
{\xe \v _suspendingController\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:_suspendingController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InteractionController} Leap.Unity.Interaction.InteractionBehaviour._suspendingController = null{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFAR}
{\bkmkend AAAAAAAFAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1343 of file InteractionBehaviour.cs.}\par
}
{\xe \v graspedMovementType\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:graspedMovementType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GraspedMovementType} Leap.Unity.Interaction.InteractionBehaviour.graspedMovementType}}
\par
{\bkmkstart AAAAAAAFAS}
{\bkmkend AAAAAAAFAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 699 of file InteractionBehaviour.cs.}\par
}
{\xe \v latestScheduledGraspPose\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:latestScheduledGraspPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose}? Leap.Unity.Interaction.InteractionBehaviour.latestScheduledGraspPose = null}}
\par
{\bkmkstart AAAAAAAFAT}
{\bkmkend AAAAAAAFAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nonkinematic grasping motion applies clamped velocities to {\b Interaction} Behaviours when they are grasped to move them to their target position and rotation in the grasping hand. If a controller applies its SwapGrasp method to an interaction object that didn't reach its target pose due to velocity clamping, the swapped-out object will inherit the offset as a new target pose relative to the hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To prevent slippage in this scenario, we always track the latest scheduled grasp pose for interaction objects here, and use it whenever possible in the SwapGrasp method. \par
}{
Definition at line 330 of file InteractionBehaviour.cs.}\par
}
{\xe \v MAX_ANGULAR_VELOCITY\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:MAX_ANGULAR_VELOCITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float Leap.Unity.Interaction.InteractionBehaviour.MAX_ANGULAR_VELOCITY = 100F}}
\par
{\bkmkstart AAAAAAAFAU}
{\bkmkend AAAAAAAFAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnContactBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnContactBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnContactBegin}}
\par
{\bkmkstart AAAAAAAFAV}
{\bkmkend AAAAAAAFAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when this object begins colliding with any interaction controllers, if the object was not colliding with any interaction controllers last frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 481 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnContactEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnContactEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnContactEnd}}
\par
{\bkmkstart AAAAAAAFAW}
{\bkmkend AAAAAAAFAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object ceases colliding with any interaction controllers, if the }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
object was colliding with interaction controllers last frame. \par
}{
Definition at line 487 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnContactStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnContactStay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnContactStay}}
\par
{\bkmkstart AAAAAAAFAX}
{\bkmkend AAAAAAAFAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every frame during which one or more interaction controllers is colliding with this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 493 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnGraspBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnGraspBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnGraspBegin}}
\par
{\bkmkstart AAAAAAAFAY}
{\bkmkend AAAAAAAFAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object becomes grasped, if it was not already held by any interaction controllers on the previous frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is fired on a given frame, it will occur after OnGraspEnd and before OnGraspStay. \par
}{
Definition at line 359 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnGraspedMovement\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnGraspedMovement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GraspedMovementEvent Leap.Unity.Interaction.InteractionBehaviour.OnGraspedMovement}}
\par
{\bkmkstart AAAAAAAFAZ}
{\bkmkend AAAAAAAFAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = (preSolvedPos, preSolvedRot,\par
                                                     solvedPos,    solvedRot,\par
                                                     graspingControllers) => \{ \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called directly after this grasped object's Rigidbody has had its position and rotation set by its currently grasping controller(s). Subscribe to this callback if you'd like to override the default behaviour for grasping objects, for example, to constrain the object's position or rotation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use InteractionBehaviour.rigidbody.position and InteractionBehaviour.rigidbody.rotation to set the object's position and rotation. Merely setting the object's Transform's position and rotation is not recommended unless you understand the difference. \par
This method is called after any OnGraspBegin or OnGraspEnd callbacks, but before OnGraspStay. It is also valid to move the {\b Interaction} object (via its Rigidbody) in OnGraspStay, although OnGraspStay does not provide pre- and post-solve data in its callback signature. \par
}{
Definition at line 348 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnGraspEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnGraspEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnGraspEnd}}
\par
{\bkmkstart AAAAAAAFBA}
{\bkmkend AAAAAAAFBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object is no longer grasped by any interaction controllers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is fired on a given frame, it will occur before OnGraspBegin and OnGraspStay. \par
}{
Definition at line 367 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnGraspStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnGraspStay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnGraspStay}}
\par
{\bkmkstart AAAAAAAFBB}
{\bkmkend AAAAAAAFBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed (physics) frame during which this object is grasped by one or more hands. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unless allowMultigrasp is set to true, only one hand will ever be grasping an object at any given time. \par
If this event is fired on a given frame, it will be fired after all other grasping callbacks, including OnGraspedMovement. \par
}{
Definition at line 379 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnHoverBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnHoverBegin}}
\par
{\bkmkstart AAAAAAAFBC}
{\bkmkend AAAAAAAFBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object becomes hovered by any nearby interaction controllers. The hover activity radius is a setting specified by the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is to be fired on a given frame, it will be called before OnHoverStay, OnPerControllerHoverEnd, and OnHoverEnd, and it will be called after OnPerControllerHoverBegin. \par
}{
Definition at line 177 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnHoverEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnHoverEnd}}
\par
{\bkmkstart AAAAAAAFBD}
{\bkmkend AAAAAAAFBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object stops being hovered by any nearby interaction controllers. The hover activity radius is a setting specified by the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is to be fired on a given frame, it will be called before OnPerControllerHoverBegin, OnHoverBegin, and OnHoverStay, and it will be called after OnPerControllerHoverEnd. \par
}{
Definition at line 187 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnHoverStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnHoverStay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnHoverStay}}
\par
{\bkmkstart AAAAAAAFBE}
{\bkmkend AAAAAAAFBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called during every fixed (physics) frame in which one or more interaction controller is within the hover activity radius around this object. The hover activity radius is a setting specified by the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"Stay" methods are always called after their "Begin" and "End" counterparts. \par
}{
Definition at line 197 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerContactBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerContactBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerContactBegin}}
\par
{\bkmkstart AAAAAAAFBF}
{\bkmkend AAAAAAAFBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller begins colliding with this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 498 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerContactEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerContactEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerContactEnd}}
\par
{\bkmkstart AAAAAAAFBG}
{\bkmkend AAAAAAAFBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller stops colliding with this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 503 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerGraspBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerGraspBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerGraspBegin}}
\par
{\bkmkstart AAAAAAAFBH}
{\bkmkend AAAAAAAFBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller grasps this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unless allowMultigrasp is set to true, only one controller will ever be grasping an object at any given time. \par
If this event is fired on a given frame, it will be called after OnPreControllerGraspEnd and before OnGraspStay. \par
}{
Definition at line 391 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerGraspEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerGraspEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerGraspEnd}}
\par
{\bkmkstart AAAAAAAFBI}
{\bkmkend AAAAAAAFBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller stops grasping this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unless allowMultigrasp is set to true, only one controller will ever be grasping an object at any given time. If a new controller grasps an object while allowMultigrasp is disabled, the object will first receive the end grasp event before receiving the begin grasp event for the newly grasping controller. \par
If this event is fired on a given frame, it will be before all other grasping callbacks. \par
}{
Definition at line 403 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerHoverBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerHoverBegin}}
\par
{\bkmkstart AAAAAAAFBJ}
{\bkmkend AAAAAAAFBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller enters the hover activity radius around this interaction object. The hover activity radius is a setting specified by the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is to be fired on a given frame, it will be called after OnPerControllerHandHoverEnd and before OnHoverStay. \par
}{
Definition at line 207 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerHoverEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerHoverEnd}}
\par
{\bkmkstart AAAAAAAFBK}
{\bkmkend AAAAAAAFBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller leaves the hover activity radius around this interaction object. The hover activity radius is a setting specified by the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is to be fired on a given frame, it will be called before OnPerControllerHoverBegin and before OnHoverStay. \par
}{
Definition at line 217 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerPrimaryHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerPrimaryHoverBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerPrimaryHoverBegin}}
\par
{\bkmkstart AAAAAAAFBL}
{\bkmkend AAAAAAAFBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controller (a {\b Leap} hand or supported VR controller) begins primarily hovering over this object. Only one interaction object can be the primary hover of a given controller at a time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is to be fired on a given frame, it will be called before OnPrimaryHoverStay, and it will be called after OnPerControllerPrimaryHoverEnd. \par
}{
Definition at line 262 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPerControllerPrimaryHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPerControllerPrimaryHoverEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnPerControllerPrimaryHoverEnd}}
\par
{\bkmkstart AAAAAAAFBM}
{\bkmkend AAAAAAAFBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called whenever an interaction controler (a {\b Leap} hand or supported VR controller) stops primarily hovering over this object. Only one interaction object can be the primary hover of a given controller at a time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is to be fired on a given frame, it will be called before OnPerControllerPrimaryHoverBegin and OnPrimaryHoverStay. \par
}{
Definition at line 273 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPrimaryHoverBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPrimaryHoverBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnPrimaryHoverBegin}}
\par
{\bkmkstart AAAAAAAFBN}
{\bkmkend AAAAAAAFBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object becomes primarily hovered by any interaction controllers, if the object was not primarily hovered by any controllers on the previous frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is fired on a given frame, it will be called before OnPrimaryHoverStay, and it will be called after OnPrimaryHoverEnd. \par
}{
Definition at line 231 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPrimaryHoverEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPrimaryHoverEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnPrimaryHoverEnd}}
\par
{\bkmkstart AAAAAAAFBO}
{\bkmkend AAAAAAAFBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the object ceases being the primary hover of any interaction controllers, if the object was primarily hovered by one or more controllers on the previous frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this event is fired on a given frame, it will be called before OnPrimaryHoverStay and OnPrimaryHoverBegin. \par
}{
Definition at line 241 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnPrimaryHoverStay\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnPrimaryHoverStay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action Leap.Unity.Interaction.InteractionBehaviour.OnPrimaryHoverStay}}
\par
{\bkmkstart AAAAAAAFBP}
{\bkmkend AAAAAAAFBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed (physics) frame in which one or more interaction controllers is primarily hovering over this object. Only one object may be the primary hover of a given controller at any one time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"Stay" events are fired after any "End" and "Begin" events have been fired. \par
}{
Definition at line 251 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnSuspensionBegin\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnSuspensionBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnSuspensionBegin}}
\par
{\bkmkstart AAAAAAAFBQ}
{\bkmkend AAAAAAAFBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when the interaction controller that is grasping this interaction object loses tracking. This can occur if the controller is occluded from the sensor that is tracking it, e.g. by as the user's body or an object in the real world. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An object is "suspended" if it is currently grasped by an untracked controller.\par
By default, suspended objects will hang in the air until the interaction controller grasping them resumes tracking. Subscribe to this callback and OnResume to implement, e.g., the object disappearing and re-appearing. \par
}{
Definition at line 416 of file InteractionBehaviour.cs.}\par
}
{\xe \v OnSuspensionEnd\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:OnSuspensionEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Action<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.OnSuspensionEnd}}
\par
{\bkmkstart AAAAAAAFBR}
{\bkmkend AAAAAAAFBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called when an object ceases being suspended. An object is suspended if it is currently grasped by an untracked controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grasping a suspended object with a different controller will cease suspension of the object, and will invoke OnSuspensionEnd, although the input to OnSuspensionEnd will be the newly grasping controller, not the controller that suspended the object. OnGraspEnd will also be called for the interaction controller that was formerly causing suspension. \par
}{
Definition at line 427 of file InteractionBehaviour.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v allowMultiGrasp\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:allowMultiGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.allowMultiGrasp{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFBS}
{\bkmkend AAAAAAAFBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 664 of file InteractionBehaviour.cs.}\par
}
{\xe \v closestHoveringController\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:closestHoveringController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InteractionController} Leap.Unity.Interaction.InteractionBehaviour.closestHoveringController{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFBT}
{\bkmkend AAAAAAAFBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the closest interaction controller to this object, or null if no controller is nearby. {\b Leap} hands and supported VR controllers both count as "controllers" for the purposes of this getter. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 53 of file InteractionBehaviour.cs.}\par
}
{\xe \v closestHoveringControllerDistance\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:closestHoveringControllerDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionBehaviour.closestHoveringControllerDistance{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFBU}
{\bkmkend AAAAAAAFBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the distance from this object to the palm of the closest hand to this object, or float.PositiveInfinity of no hand is nearby. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 71 of file InteractionBehaviour.cs.}\par
}
{\xe \v closestHoveringHand\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:closestHoveringHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hand}? Leap.Unity.Interaction.InteractionBehaviour.closestHoveringHand{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFBV}
{\bkmkend AAAAAAAFBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the closest {\b Leap} hand to this object, or null if no hand is nearby. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 60 of file InteractionBehaviour.cs.}\par
}
{\xe \v contactForceMode\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:contactForceMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ContactForceMode} Leap.Unity.Interaction.InteractionBehaviour.contactForceMode{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFBW}
{\bkmkend AAAAAAAFBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 653 of file InteractionBehaviour.cs.}\par
}
{\xe \v contactingControllers\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:contactingControllers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.contactingControllers{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFBX}
{\bkmkend AAAAAAAFBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a set of all InteractionControllers currently contacting this interaction object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 473 of file InteractionBehaviour.cs.}\par
}
{\xe \v graspedPoseHandler\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:graspedPoseHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IGraspedPoseHandler} Leap.Unity.Interaction.InteractionBehaviour.graspedPoseHandler{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFBY}
{\bkmkend AAAAAAAFBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets or sets the grasped pose handler for this {\b Interaction} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1171 of file InteractionBehaviour.cs.}\par
}
{\xe \v graspingController\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:graspingController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InteractionController} Leap.Unity.Interaction.InteractionBehaviour.graspingController{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFBZ}
{\bkmkend AAAAAAAFBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the controller currently grasping this object. Warning: If allowMultigrasp is enabled on this object, it might have multiple grasping controllers, in which case this will only return one of the controllers grasping this object, and there is no guarantee on which controller is returned! If no controllers ({\b Leap} hands or supported VR controllers) are currently grasping this object, returns null. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 291 of file InteractionBehaviour.cs.}\par
}
{\xe \v graspingControllers\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:graspingControllers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.graspingControllers{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCA}
{\bkmkend AAAAAAAFCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of all interaction controllers currently grasping this object. {\b Interaction} controllers include {\b Leap} hands via {\b InteractionHand} and supported VR controllers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 297 of file InteractionBehaviour.cs.}\par
}
{\xe \v graspingHands\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:graspingHands}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b InteractionHand}> Leap.Unity.Interaction.InteractionBehaviour.graspingHands{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCB}
{\bkmkend AAAAAAAFCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a set of all {\b Leap} hands currently grasping this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 303 of file InteractionBehaviour.cs.}\par
}
{\xe \v hoveringControllers\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:hoveringControllers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.hoveringControllers{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCC}
{\bkmkend AAAAAAAFCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets all of the interaction controllers hovering near this object, whether they are {\b Leap} hands or supported VR controllers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 81 of file InteractionBehaviour.cs.}\par
}
{\xe \v ignoreContact\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ignoreContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.ignoreContact{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCD}
{\bkmkend AAAAAAAFCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 619 of file InteractionBehaviour.cs.}\par
}
{\xe \v ignoreGrasping\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ignoreGrasping}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.ignoreGrasping{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCE}
{\bkmkend AAAAAAAFCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 634 of file InteractionBehaviour.cs.}\par
}
{\xe \v ignoreHoverMode\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ignoreHoverMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IgnoreHoverMode} Leap.Unity.Interaction.InteractionBehaviour.ignoreHoverMode{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCF}
{\bkmkend AAAAAAAFCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 585 of file InteractionBehaviour.cs.}\par
}
{\xe \v ignorePrimaryHover\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:ignorePrimaryHover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.ignorePrimaryHover{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCG}
{\bkmkend AAAAAAAFCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 604 of file InteractionBehaviour.cs.}\par
}
{\xe \v interactionLayer\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:interactionLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SingleLayer} Leap.Unity.Interaction.InteractionBehaviour.interactionLayer{\f2 [get]}, {\f2 [protected set]}}}
\par
{\bkmkstart AAAAAAAFCH}
{\bkmkend AAAAAAAFCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 722 of file InteractionBehaviour.cs.}\par
}
{\xe \v isGrasped\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:isGrasped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.isGrasped{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCI}
{\bkmkend AAAAAAAFCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether this object is grasped by any interaction controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 282 of file InteractionBehaviour.cs.}\par
}
{\xe \v isHovered\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:isHovered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.isHovered{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCJ}
{\bkmkend AAAAAAAFCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether any interaction controller is nearby. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 46 of file InteractionBehaviour.cs.}\par
}
{\xe \v isPositionLocked\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:isPositionLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.isPositionLocked{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCK}
{\bkmkend AAAAAAAFCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the {\b InteractionBehaviour} has its position fully locked by its Rigidbody settings or by any attached PhysX Joints. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is useful for the GraspedMovementController to determine whether it should attempt to move the interaction object or merely rotate it.\par
If the state of the underlying Rigidbody or Joints changes what this value should be, it will not automatically update (as an optimization) at runtime; instead, manually call {\b RefreshPositionLockedState()}. This is because the type-checks required are relatively expensive and mustn't occur every frame. \par
}{
Definition at line 1522 of file InteractionBehaviour.cs.}\par
}
{\xe \v isPrimaryHovered\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:isPrimaryHovered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.isPrimaryHovered{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCL}
{\bkmkend AAAAAAAFCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether this object is the primary hover for any interaction controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 90 of file InteractionBehaviour.cs.}\par
}
{\xe \v isSuspended\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:isSuspended}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.isSuspended{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCM}
{\bkmkend AAAAAAAFCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the object is currently suspended. An object is "suspended" if it is currently grasped by an untracked controller. For more details, refer to OnSuspensionBegin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 316 of file InteractionBehaviour.cs.}\par
}
{\xe \v manager\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:manager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InteractionManager} Leap.Unity.Interaction.InteractionBehaviour.manager{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCN}
{\bkmkend AAAAAAAFCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 547 of file InteractionBehaviour.cs.}\par
}
{\xe \v moveObjectWhenGrasped\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:moveObjectWhenGrasped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.moveObjectWhenGrasped{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCO}
{\bkmkend AAAAAAAFCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 675 of file InteractionBehaviour.cs.}\par
}
{\xe \v noContactLayer\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:noContactLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SingleLayer} Leap.Unity.Interaction.InteractionBehaviour.noContactLayer{\f2 [get]}, {\f2 [protected set]}}}
\par
{\bkmkstart AAAAAAAFCP}
{\bkmkend AAAAAAAFCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 748 of file InteractionBehaviour.cs.}\par
}
{\xe \v overrideInteractionLayer\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:overrideInteractionLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.overrideInteractionLayer{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCQ}
{\bkmkend AAAAAAAFCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 709 of file InteractionBehaviour.cs.}\par
}
{\xe \v overrideNoContactLayer\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:overrideNoContactLayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionBehaviour.overrideNoContactLayer{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFCR}
{\bkmkend AAAAAAAFCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 734 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoverColliders\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoverColliders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<Collider> Leap.Unity.Interaction.InteractionBehaviour.primaryHoverColliders{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCS}
{\bkmkend AAAAAAAFCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the List of Colliders used for hover distance checking for this {\b Interaction} object. Hover distancing checking will affect which object is chosen for an interaction controller's primary hover, as well as for determining this object's closest hovering controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RefreshInteractionColliders()} will automatically populate the colliders List with the this rigidbody's colliders, but is only called once on {\b Start()}. If you change the colliders for this object at runtime, you should call {\b RefreshInteractionColliders()} to keep the _hoverColliders list up-to-date. \par
If you're feeling brave, you can manually modify this list yourself.\par
Hover candidacy is determined by a hand-centric PhysX sphere-check against the {\b Interaction} object's rigidbody's attached colliders. This behavior cannot be changed, even if you modify the contents of primaryHoverColliders.\par
However, primary hover is determined by performing distance checks against the colliders in the primaryHoverColliders list, so it IS possible to use different collider(s) for primary hover checks than are used for hover candidacy, by modifying the collider contents of this list. This will also affect which hand is chosen by this object as its closestHoveringHand. \par
}{
Definition at line 1097 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoverDistance\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoverDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionBehaviour.primaryHoverDistance{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCT}
{\bkmkend AAAAAAAFCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the distance to the primary hover point whose controller is primarily hovering over this object. For example, if the primary hovering controller is a {\b Leap} hand, this will return the distance to the fingertip that is closest to this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this object is not the primary hover of any interaction controller, returns positive infinity. \par
}{
Definition at line 160 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoveringController\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoveringController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InteractionController} Leap.Unity.Interaction.InteractionBehaviour.primaryHoveringController{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCU}
{\bkmkend AAAAAAAFCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the closest primary hovering interaction controller for this object, if it has one. An interaction controller can be a {\b Leap} hand or a supported VR controller. Any of these controllers can be the primary hover for this interaction object only if the controller is closer to it than any other interaction object. If there are multiple such controllers, this getter will return the closest one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 99 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoveringControllerPoint\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoveringControllerPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Vector3 Leap.Unity.Interaction.InteractionBehaviour.primaryHoveringControllerPoint{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCV}
{\bkmkend AAAAAAAFCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the position of the primaryHoverPoint on the primary hovering interaction controller that is primarily hovering over this object. For example, if the primarily hovering controller is a {\b Leap} hand, this will be the position of the fingertip that is closest to this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 146 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoveringControllers\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoveringControllers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReadonlyHashSet}<{\b InteractionController}> Leap.Unity.Interaction.InteractionBehaviour.primaryHoveringControllers{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCW}
{\bkmkend AAAAAAAFCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the set of all interaction controllers primarily hovering over this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 108 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoveringFinger\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoveringFinger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Finger} Leap.Unity.Interaction.InteractionBehaviour.primaryHoveringFinger{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCX}
{\bkmkend AAAAAAAFCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the finger that is currently primarily hovering over this object, of the closest primarily hovering hand. Will return null if this object is not currently any {\b Leap} hand's primary hover. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 132 of file InteractionBehaviour.cs.}\par
}
{\xe \v primaryHoveringHand\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:primaryHoveringHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hand}? Leap.Unity.Interaction.InteractionBehaviour.primaryHoveringHand{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFCY}
{\bkmkend AAAAAAAFCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the primary hovering hand for this interaction object, if it has one. A hand is the primary hover for an interaction object only if it is closer to that object than any other interaction object. If there are multiple such hands, returns the hand closest to this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 120 of file InteractionBehaviour.cs.}\par
}
{\xe \v rigidbody\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:rigidbody}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Rigidbody Leap.Unity.Interaction.InteractionBehaviour.rigidbody{\f2 [get]}, {\f2 [protected set]}}}
\par
{\bkmkstart AAAAAAAFCZ}
{\bkmkend AAAAAAAFCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Rigidbody associated with this interaction object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 571 of file InteractionBehaviour.cs.}\par
}
{\xe \v space\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:space}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ISpaceComponent} Leap.Unity.Interaction.InteractionBehaviour.space{\f2 [get]}, {\f2 [protected set]}}}
\par
{\bkmkstart AAAAAAAFDA}
{\bkmkend AAAAAAAFDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 576 of file InteractionBehaviour.cs.}\par
}
{\xe \v throwHandler\:Leap.Unity.Interaction.InteractionBehaviour}
{\xe \v Leap.Unity.Interaction.InteractionBehaviour\:throwHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IThrowHandler} Leap.Unity.Interaction.InteractionBehaviour.throwHandler{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFDB}
{\bkmkend AAAAAAAFDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets or sets the throw handler for this {\b Interaction} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 1205 of file InteractionBehaviour.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
O:/GitHUBMINIPRoject/Assets/LeapMotion/Modules/InteractionEngine/Scripts/{\b InteractionBehaviour.cs}\par
}}