{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Leap.Unity.Interaction.InteractionXRController Class Reference\par \pard\plain 
{\tc\tcl2 \v Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController}
{\bkmkstart AAAAAAAFNR}
{\bkmkend AAAAAAAFNR}
Inheritance diagram for Leap.Unity.Interaction.InteractionXRController:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_leap_1_1_unity_1_1_interaction_1_1_interaction_x_r_controller.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RefreshControllerConnection} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3 {\b GetGraspPoint} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns approximately where the controller is grasping the currently grasped {\b InteractionBehaviour}. This method will print an error if the controller is not currently grasping an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b OnDrawRuntimeGizmos} ({\b RuntimeGizmos.RuntimeGizmoDrawer} drawer)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b pollConnectionInterval} = 2f\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
new List< Transform > {\b primaryHoverPoints}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Transform {\b graspPoint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b maxGraspDistance} = 0.06F\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b graspButtonAxis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b graspTimingSlop} = 0.10F\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Func< float > {\b graspAxisOverride} = null\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, InteractionVRController uses Input.GetAxis(graspButtonAxis) to determine the "depression" state for the grasp button. By setting this value to something other than null, it is possible to modify this behavior to instead retrieve a grasping axis value based on arbitrary code. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnValidate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b Start} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b fixedUpdateController} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called just before the {\b InteractionController} proceeds with its usual FixedUpdate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b onObjectUnregistered} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
InteractionVRController doesn't need to do anything when an object is unregistered. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b unwarpColliders} (Transform primaryHoverPoint, {\b ISpaceComponent} warpedSpaceElement)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementing this method is necessary to support curved spaces as rendered by a {\b Leap} Graphic Renderer. See {\b InteractionHand} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a {\b Leap} Graphic Renderer.) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b initContact} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called to initialize contact colliders. See remarks for implementation requirements. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b getColliderBoneTargetPositionRotation} (int contactBoneIndex, out Vector3 targetPosition, out Quaternion targetRotation)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array. (For example, by recording the local position and local rotation of each contact bone in {\b initContact()}). More complex controllers, such as {\b InteractionHand}, uses this method to set {\b ContactBone} target positions and rotations based on the tracked {\b Leap} hand. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override void {\b fixedUpdateGraspingState} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed frame if grasping is enabled in the {\b Interaction} Manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b checkShouldGrasp} (out {\b IInteractionBehaviour} objectToGrasp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b checkShouldGraspAtemporal} ({\b IInteractionBehaviour} intObj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the provided object is within range of this VR controller's grasp point and the grasp button is currently held down, this method will manually initiate a grasp and return true. Otherwise, the method returns false. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b checkShouldRelease} (out {\b IInteractionBehaviour} objectToRelease)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Properties\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isUsingCustomTracking}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b deviceJoystickTokens}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chirality} {\b chirality}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pollConnection}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to continuously poll attached joystick data for a joystick that matches the device joystick tokens, using Input.GetJoystickNames(). This call allocates garbage, so be wary of setting a low polling interval. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
List< GameObject > {\b enableObjectsOnlyWhenTracked}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These objects will be made active only while the controller is tracked. For more fine-tuned behavior, we recommend implementing your own logic. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isJoystickDetected}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the device joystick tokens matched an entry in Input.GetJoystickNames(). If pollConnection is set to true, this status is refreshed periodically based on the pollConnectionInterval, but only while the joystick tokens have not been detected from Input.GetJoystickNames(). Call {\b RefreshControllerConnection()} to detect if the controller has been disconnected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IXRControllerTrackingProvider} {\b trackingProvider}{\f2  [get, set]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b isTracked}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether or not the underlying controller is currently tracked and any joystick token filtering has confirmed that this controller has been detected as a connected joystick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b isBeingMoved}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether or not the underlying controller is currently being moved in world space, but relative to the {\b Interaction} Manager's transform. The {\b Interaction} Manager is usually a sibling of the main camera beneath the camera rig transform, so that if your application is only translating the player rig in space, this method won't incorrectly return true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
VRNode? {\b xrNode}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the XRNode associated with this XR controller. Note: If the tracking mode for this controller is specified as {\b ControllerTrackingMode.Custom}, this value may be ignored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override bool {\b isLeft}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the controller is a left-hand controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3 {\b position}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked position of the controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Quaternion {\b rotation}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked rotation of the controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3 {\b velocity}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current velocity of the controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override {\b ControllerType} {\b controllerType}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the type of controller this is. For InteractionVRController, the type is always ControllerType.VRController. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override {\b InteractionHand} {\b intHand}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This implementation of InteractionControllerBase does not represent a {\b Leap} hand, so it need not return an {\b InteractionHand} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override Vector3? {\b hoverPoint}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the center point used for hover distance checking. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override List< Transform > {\b _primaryHoverPoints}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the list of points to be used to perform higher-fidelity "primary hover" checks. Only one interaction object may be the primary hover of an interaction controller ({\b Leap} hand or otherwise) at a time. Interface objects such as buttons can only be pressed when they are primarily hovered by an interaction controller, so it's best to return points on whatever you expect to be able to use to push buttons with the controller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override {\b ContactBone} [] {\b contactBones}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override GameObject {\b contactBoneParent}{\f2  [get]}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b graspDepressedValue}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value between 0 and 1 past which the grasping axis value will cause an attempt to grasp a graspable interaction object near the grasp point. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b graspReleasedValue}{\f2  [get, set]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the grasping axis value passes the graspDepressedValue, it must then drop underneath this value in order to release the grasp attempt (potentially releasing a held object) and allow a new grasp attempt to occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
override List< Vector3 > {\b graspManipulatorPoints}{\f2  [get]}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a list returning this controller's hoverPoint. Because the InteractionVRController represents a rigid controller, any two points that rigidly move with the controller position and orientation will provide enough information. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 28 of file InteractionXRController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v checkShouldGrasp\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:checkShouldGrasp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.checkShouldGrasp (out {\b IInteractionBehaviour}  {\i objectToGrasp}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFEZ}
{\bkmkend AAAAAAAFEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should grasp an object this fixed frame, and if so, sets objectToGrasp to the object the controller should grasp. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFEY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 780 of file InteractionXRController.cs.}\par
}
{\xe \v checkShouldGraspAtemporal\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:checkShouldGraspAtemporal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.checkShouldGraspAtemporal ({\b IInteractionBehaviour}  {\i intObj}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFC}
{\bkmkend AAAAAAAFFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the provided object is within range of this VR controller's grasp point and the grasp button is currently held down, this method will manually initiate a grasp and return true. Otherwise, the method returns false. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 796 of file InteractionXRController.cs.}\par
}
{\xe \v checkShouldRelease\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:checkShouldRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.checkShouldRelease (out {\b IInteractionBehaviour}  {\i objectToRelease}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFF}
{\bkmkend AAAAAAAFFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether this controller should release an object this fixed frame, and if so, sets objectToRelease to the object the controller should release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 814 of file InteractionXRController.cs.}\par
}
{\xe \v fixedUpdateController\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:fixedUpdateController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.fixedUpdateController (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFS}
{\bkmkend AAAAAAAFFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called just before the {\b InteractionController} proceeds with its usual FixedUpdate. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It's generally better to override this method instead of having your {\b InteractionController} implement FixedUpdate because its execution order relative to the {\b Interaction} Manager is fixed. \par
}{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 179 of file InteractionXRController.cs.}\par
}
{\xe \v fixedUpdateGraspingState\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:fixedUpdateGraspingState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.fixedUpdateGraspingState (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFV}
{\bkmkend AAAAAAAFFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called every fixed frame if grasping is enabled in the {\b Interaction} Manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
graspActivityManager.ActiveObjects will contain objects around the hoverPoint within the grasping radius \'96 in other words, objects eligible to be grasped by the controller. Refer to it to avoid checking grasp eligibility against all graspable objects in your scene. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 703 of file InteractionXRController.cs.}\par
}
{\xe \v getColliderBoneTargetPositionRotation\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:getColliderBoneTargetPositionRotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.getColliderBoneTargetPositionRotation (int  {\i contactBoneIndex}, out Vector3  {\i targetPosition}, out Quaternion  {\i targetRotation}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFX}
{\bkmkend AAAAAAAFFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If your controller features no moving colliders relative to itself, simply return the desired position and rotation for the given indexed contact bone in the contactBones array. (For example, by recording the local position and local rotation of each contact bone in {\b initContact()}). More complex controllers, such as {\b InteractionHand}, uses this method to set {\b ContactBone} target positions and rotations based on the tracked {\b Leap} hand. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 630 of file InteractionXRController.cs.}\par
}
{\xe \v GetGraspPoint\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:GetGraspPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3 Leap.Unity.Interaction.InteractionXRController.GetGraspPoint (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGA}
{\bkmkend AAAAAAAFGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns approximately where the controller is grasping the currently grasped {\b InteractionBehaviour}. This method will print an error if the controller is not currently grasping an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 699 of file InteractionXRController.cs.}\par
}
{\xe \v initContact\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:initContact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.initContact (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGE}
{\bkmkend AAAAAAAFGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Called to initialize contact colliders. See remarks for implementation requirements. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b initContact()} should:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Return false at any time if initialization cannot be performed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ensure the "contactBones" property returns all contact colliders.{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
(Construct contact colliders if they don't already exist.)\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ensure the "contactBoneParent" property returns the common parent of all contact colliders.{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
(Construct the contact bone parent if it doesn't already exist.)\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Return true if initialization was successful.\par}
Contact will only begin updating after initialization succeeds, otherwise it will try to initialize again on the next fixed frame.\par
After initialization, the contact bone parent's layer will be set to the {\b Interaction} Manager's contactBoneLayer. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 536 of file InteractionXRController.cs.}\par
}
{\xe \v OnDrawRuntimeGizmos\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:OnDrawRuntimeGizmos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.OnDrawRuntimeGizmos ({\b RuntimeGizmos.RuntimeGizmoDrawer}  {\i drawer})}}
\par
{\bkmkstart AAAAAAAFNS}
{\bkmkend AAAAAAAFNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 827 of file InteractionXRController.cs.}\par
}
{\xe \v onObjectUnregistered\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:onObjectUnregistered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.onObjectUnregistered ({\b IInteractionBehaviour}  {\i intObj}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFGT}
{\bkmkend AAAAAAAFGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
InteractionVRController doesn't need to do anything when an object is unregistered. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 468 of file InteractionXRController.cs.}\par
}
{\xe \v OnValidate\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:OnValidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Leap.Unity.Interaction.InteractionXRController.OnValidate (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFNT}
{\bkmkend AAAAAAAFNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 169 of file InteractionXRController.cs.}\par
}
{\xe \v RefreshControllerConnection\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:RefreshControllerConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Leap.Unity.Interaction.InteractionXRController.RefreshControllerConnection ()}}
\par
{\bkmkstart AAAAAAAFNU}
{\bkmkend AAAAAAAFNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 229 of file InteractionXRController.cs.}\par
}
{\xe \v Reset\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.Reset (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHE}
{\bkmkend AAAAAAAFHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 153 of file InteractionXRController.cs.}\par
}
{\xe \v Start\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:Start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.Start (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHH}
{\bkmkend AAAAAAAFHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 173 of file InteractionXRController.cs.}\par
}
{\xe \v unwarpColliders\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:unwarpColliders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override void Leap.Unity.Interaction.InteractionXRController.unwarpColliders (Transform  {\i primaryHoverPoint}, {\b ISpaceComponent}  {\i warpedSpaceElement}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFHO}
{\bkmkend AAAAAAAFHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementing this method is necessary to support curved spaces as rendered by a {\b Leap} Graphic Renderer. See {\b InteractionHand} for an example implementation. (Implementing this method is optional if you are not using a curved space as rendered by a {\b Leap} Graphic Renderer.) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Warps the collider transforms of this controller by the inverse of the transformation that is applied on the provided warpedSpaceElement, using the primaryHoverPoint as the pivot transform for the transformation.\par
ITransformer.WorldSpaceUnwarp is a useful method here. (ISpaceComponents contain references to their transformers via their anchors.)\par
ISpaceComponents denote game objects whose visual positions are warped from rectilinear (non-warped) space into a curved space (via, for example, a LeapCylindricalSpace, which can only be rendered correctly by the {\b Leap} Graphic Renderer). This method reverses that transformation for the hand, bringing it into the object's rectilinear space, allowing objects curved in this way to correctly collide with the bones in the hand or collider of a held controller.\par
The provided Transform is the closest primary hover point to any given primary hover candidate, so it is used as the pivot point for unwarping the colliders of this {\b InteractionController}. \par
}{
Implements {\b Leap.Unity.Interaction.InteractionController} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 497 of file InteractionXRController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v graspAxisOverride\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspAxisOverride}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Func<float> Leap.Unity.Interaction.InteractionXRController.graspAxisOverride = null}}
\par
{\bkmkstart AAAAAAAFNV}
{\bkmkend AAAAAAAFNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By default, InteractionVRController uses Input.GetAxis(graspButtonAxis) to determine the "depression" state for the grasp button. By setting this value to something other than null, it is possible to modify this behavior to instead retrieve a grasping axis value based on arbitrary code. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A grasp is attempted when the grasp button axis value returned by this method becomes larger than the graspButtonDepressedValue, and a grasp is released when the grasp button axis value returned by this method becomes smaller than the graspButtonReleasedValue. Both of these values provide public setters. \par
}{
Definition at line 652 of file InteractionXRController.cs.}\par
}
{\xe \v graspButtonAxis\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspButtonAxis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Leap.Unity.Interaction.InteractionXRController.graspButtonAxis}}
\par
{\bkmkstart AAAAAAAFNW}
{\bkmkend AAAAAAAFNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 118 of file InteractionXRController.cs.}\par
}
{\xe \v graspPoint\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Transform Leap.Unity.Interaction.InteractionXRController.graspPoint}}
\par
{\bkmkstart AAAAAAAFNX}
{\bkmkend AAAAAAAFNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file InteractionXRController.cs.}\par
}
{\xe \v graspTimingSlop\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspTimingSlop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionXRController.graspTimingSlop = 0.10F}}
\par
{\bkmkstart AAAAAAAFNY}
{\bkmkend AAAAAAAFNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 125 of file InteractionXRController.cs.}\par
}
{\xe \v maxGraspDistance\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:maxGraspDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionXRController.maxGraspDistance = 0.06F}}
\par
{\bkmkstart AAAAAAAFNZ}
{\bkmkend AAAAAAAFNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file InteractionXRController.cs.}\par
}
{\xe \v pollConnectionInterval\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:pollConnectionInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionXRController.pollConnectionInterval = 2f}}
\par
{\bkmkstart AAAAAAAFOA}
{\bkmkend AAAAAAAFOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file InteractionXRController.cs.}\par
}
{\xe \v primaryHoverPoints\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:primaryHoverPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
new List<Transform> Leap.Unity.Interaction.InteractionXRController.primaryHoverPoints}}
\par
{\bkmkstart AAAAAAAFOB}
{\bkmkend AAAAAAAFOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file InteractionXRController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Property Documentation\par
\pard\plain 
{\xe \v _primaryHoverPoints\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:_primaryHoverPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override List<Transform> Leap.Unity.Interaction.InteractionXRController._primaryHoverPoints{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFOC}
{\bkmkend AAAAAAAFOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the list of points to be used to perform higher-fidelity "primary hover" checks. Only one interaction object may be the primary hover of an interaction controller ({\b Leap} hand or otherwise) at a time. Interface objects such as buttons can only be pressed when they are primarily hovered by an interaction controller, so it's best to return points on whatever you expect to be able to use to push buttons with the controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 489 of file InteractionXRController.cs.}\par
}
{\xe \v chirality\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:chirality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Chirality} Leap.Unity.Interaction.InteractionXRController.chirality{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOD}
{\bkmkend AAAAAAAFOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file InteractionXRController.cs.}\par
}
{\xe \v contactBoneParent\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:contactBoneParent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override GameObject Leap.Unity.Interaction.InteractionXRController.contactBoneParent{\f2 [get]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFOE}
{\bkmkend AAAAAAAFOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 532 of file InteractionXRController.cs.}\par
}
{\xe \v contactBones\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:contactBones}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override {\b ContactBone} [] Leap.Unity.Interaction.InteractionXRController.contactBones{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOF}
{\bkmkend AAAAAAAFOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 527 of file InteractionXRController.cs.}\par
}
{\xe \v controllerType\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:controllerType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override {\b ControllerType} Leap.Unity.Interaction.InteractionXRController.controllerType{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOG}
{\bkmkend AAAAAAAFOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the type of controller this is. For InteractionVRController, the type is always ControllerType.VRController. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 452 of file InteractionXRController.cs.}\par
}
{\xe \v deviceJoystickTokens\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:deviceJoystickTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Leap.Unity.Interaction.InteractionXRController.deviceJoystickTokens{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOH}
{\bkmkend AAAAAAAFOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file InteractionXRController.cs.}\par
}
{\xe \v enableObjectsOnlyWhenTracked\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:enableObjectsOnlyWhenTracked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
List<GameObject> Leap.Unity.Interaction.InteractionXRController.enableObjectsOnlyWhenTracked{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOI}
{\bkmkend AAAAAAAFOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These objects will be made active only while the controller is tracked. For more fine-tuned behavior, we recommend implementing your own logic. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
controller.isJoystickDetected and controller.isTracked are useful for this. \par
}{
Definition at line 140 of file InteractionXRController.cs.}\par
}
{\xe \v graspDepressedValue\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspDepressedValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionXRController.graspDepressedValue{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFOJ}
{\bkmkend AAAAAAAFOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value between 0 and 1 past which the grasping axis value will cause an attempt to grasp a graspable interaction object near the grasp point. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 659 of file InteractionXRController.cs.}\par
}
{\xe \v graspManipulatorPoints\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspManipulatorPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override List<Vector3> Leap.Unity.Interaction.InteractionXRController.graspManipulatorPoints{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOK}
{\bkmkend AAAAAAAFOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a list returning this controller's hoverPoint. Because the InteractionVRController represents a rigid controller, any two points that rigidly move with the controller position and orientation will provide enough information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 682 of file InteractionXRController.cs.}\par
}
{\xe \v graspReleasedValue\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:graspReleasedValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Leap.Unity.Interaction.InteractionXRController.graspReleasedValue{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFOL}
{\bkmkend AAAAAAAFOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the grasping axis value passes the graspDepressedValue, it must then drop underneath this value in order to release the grasp attempt (potentially releasing a held object) and allow a new grasp attempt to occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 670 of file InteractionXRController.cs.}\par
}
{\xe \v hoverPoint\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:hoverPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3? Leap.Unity.Interaction.InteractionXRController.hoverPoint{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOM}
{\bkmkend AAAAAAAFOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the center point used for hover distance checking. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 477 of file InteractionXRController.cs.}\par
}
{\xe \v intHand\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:intHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override {\b InteractionHand} Leap.Unity.Interaction.InteractionXRController.intHand{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFON}
{\bkmkend AAAAAAAFON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This implementation of InteractionControllerBase does not represent a {\b Leap} hand, so it need not return an {\b InteractionHand} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 460 of file InteractionXRController.cs.}\par
}
{\xe \v isBeingMoved\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:isBeingMoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.isBeingMoved{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOO}
{\bkmkend AAAAAAAFOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether or not the underlying controller is currently being moved in world space, but relative to the {\b Interaction} Manager's transform. The {\b Interaction} Manager is usually a sibling of the main camera beneath the camera rig transform, so that if your application is only translating the player rig in space, this method won't incorrectly return true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 387 of file InteractionXRController.cs.}\par
}
{\xe \v isJoystickDetected\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:isJoystickDetected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionXRController.isJoystickDetected{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOP}
{\bkmkend AAAAAAAFOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the device joystick tokens matched an entry in Input.GetJoystickNames(). If pollConnection is set to true, this status is refreshed periodically based on the pollConnectionInterval, but only while the joystick tokens have not been detected from Input.GetJoystickNames(). Call {\b RefreshControllerConnection()} to detect if the controller has been disconnected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Joystick detection is skipped if deviceJoystickTokens is null or empty, causing this check to always return true. \par
}{
Definition at line 211 of file InteractionXRController.cs.}\par
}
{\xe \v isLeft\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:isLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.isLeft{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOQ}
{\bkmkend AAAAAAAFOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether the controller is a left-hand controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 412 of file InteractionXRController.cs.}\par
}
{\xe \v isTracked\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:isTracked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override bool Leap.Unity.Interaction.InteractionXRController.isTracked{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOR}
{\bkmkend AAAAAAAFOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets whether or not the underlying controller is currently tracked and any joystick token filtering has confirmed that this controller has been detected as a connected joystick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 374 of file InteractionXRController.cs.}\par
}
{\xe \v isUsingCustomTracking\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:isUsingCustomTracking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionXRController.isUsingCustomTracking{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOS}
{\bkmkend AAAAAAAFOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file InteractionXRController.cs.}\par
}
{\xe \v pollConnection\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:pollConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Leap.Unity.Interaction.InteractionXRController.pollConnection{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFOT}
{\bkmkend AAAAAAAFOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to continuously poll attached joystick data for a joystick that matches the device joystick tokens, using Input.GetJoystickNames(). This call allocates garbage, so be wary of setting a low polling interval. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The connection is polled only until a joystick is detected to minimize allocation. Once a joystick has been detected (isJoystickDetected), you must manually call {\b RefreshControllerConnection()} to check if the joystick is no longer detected. \par
}{
Definition at line 74 of file InteractionXRController.cs.}\par
}
{\xe \v position\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3 Leap.Unity.Interaction.InteractionXRController.position{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOU}
{\bkmkend AAAAAAAFOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked position of the controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 419 of file InteractionXRController.cs.}\par
}
{\xe \v rotation\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:rotation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Quaternion Leap.Unity.Interaction.InteractionXRController.rotation{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOV}
{\bkmkend AAAAAAAFOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the last-tracked rotation of the controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 428 of file InteractionXRController.cs.}\par
}
{\xe \v trackingProvider\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:trackingProvider}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IXRControllerTrackingProvider} Leap.Unity.Interaction.InteractionXRController.trackingProvider{\f2 [get]}, {\f2 [set]}}}
\par
{\bkmkstart AAAAAAAFOW}
{\bkmkend AAAAAAAFOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 254 of file InteractionXRController.cs.}\par
}
{\xe \v velocity\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:velocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
override Vector3 Leap.Unity.Interaction.InteractionXRController.velocity{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOX}
{\bkmkend AAAAAAAFOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current velocity of the controller. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 437 of file InteractionXRController.cs.}\par
}
{\xe \v xrNode\:Leap.Unity.Interaction.InteractionXRController}
{\xe \v Leap.Unity.Interaction.InteractionXRController\:xrNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
VRNode? Leap.Unity.Interaction.InteractionXRController.xrNode{\f2 [get]}}}
\par
{\bkmkstart AAAAAAAFOY}
{\bkmkend AAAAAAAFOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the XRNode associated with this XR controller. Note: If the tracking mode for this controller is specified as {\b ControllerTrackingMode.Custom}, this value may be ignored. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line 404 of file InteractionXRController.cs.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
O:/GitHUBMINIPRoject/Assets/LeapMotion/Modules/InteractionEngine/Scripts/{\b InteractionXRController.cs}\par
}}